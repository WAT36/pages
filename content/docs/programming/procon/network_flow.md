---
title: "ネットワークフロー"
weight: 1
# bookFlatSection: false
# bookShowToC: true
---

# ネットワークフロー

グラフにおける最大流・最小流問題についてを述べる。

以下に例題を示す。

```

ネットワーク上の2台のコンピュータS,Tがあり、SからTにデータを送りたいとする。
このネットワークには全部でN台のコンピュータがあり、いくつかのコンピュータの間は一方向性の通信ケーブルで接続されていて、
それぞれ１秒間に通信できる最大のデータ量が決まっています。他のコンピュータが通信を行なっていない時、
sからtへどれだけのデータを送信することができるでしょうか。

```

![ネットワークフロー](/img/procon/networkflow1.png)

まずは、貪欲法を用いて流せるところに目一杯データを流すという方法が考えられる。以下のアルゴリズムを考える。

1. 流れているデータ量が最大に達していない辺のみを用いたsからtへのパスを見つける
2. そのようなパスが存在しなければ終了。存在すれば、そのパスに沿って目一杯流し、1.へ戻る

このアルゴリズムで試した場合、以下のような流れになる。

<img src="/img/procon/networkflow2.png" width=50%>

<img src="/img/procon/networkflow3.png" width=50%>

これが最適なのか？というと、実はもっと最適な方法があり、以下の通りである。

<img src="/img/procon/networkflow4.png" width=50%>

最初の貪欲法では最適解を導けないという事だろうか。

ここで、最適解と貪欲法で導いた解との、各辺におけるフローの差をとると以下の通りになる。

<img src="/img/procon/networkflow5.png" width=50%>

この図から、最適解は貪欲法で求めた解から更に一部のフローを押し戻す(図中の-1の辺)形で、新たにフローを足していると見ることができる。

ここで、先程のアルゴリズムを改良し、以下のように考えてみよう。

1. 流れているデータ量が最大に達していない辺、またはすでにデータが流れている辺の逆辺を用いたsからtへのパスを見つける
2. そのようなパスが存在しなければ終了。存在すれば、そのパスに沿って目一杯流し、1.へ戻る

これを最初の貪欲法で求めた状態から適用すると、s→2→1→3→tと大きさ1のフローを流せば最適解になる。(2→1は逆辺)

このアルゴリズムをコードで実装した例を以下に記載する。