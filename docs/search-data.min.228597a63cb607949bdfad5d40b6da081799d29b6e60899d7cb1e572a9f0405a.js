(function(){const pages=[{"idx":0,"href":"/docs/programming/list/tuple/","title":"(Python)タプル","content":" (Python)タプル Pythonで使うタプルについてを述べる。\nPython  タプルとはPythonで使われるデータ構造で、リストと同様に複数のデータを格納できるシーケンス型のデータ構造である。丸括弧 ( ) で表記される。\nリストと同じように見えるが、違う点はタプルは 変更不能 という点であり、中の値は変えることはできない。\n実行例を以下に示す。\n\u0026gt;\u0026gt;\u0026gt; #タプルの宣言 \u0026gt;\u0026gt;\u0026gt; a = (1,2,3) \u0026gt;\u0026gt;\u0026gt; a (1, 2, 3) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #リストと同様にインデックスを指定した値の参照は行える \u0026gt;\u0026gt;\u0026gt; a[0] 1 \u0026gt;\u0026gt;\u0026gt; a[1] 2 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #タプルでは値の書き換えは行えない \u0026gt;\u0026gt;\u0026gt; a[0] = 4 Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; TypeError: \u0026#39;tuple\u0026#39; object does not support item assignment \u0026gt;\u0026gt;\u0026gt;   "},{"idx":1,"href":"/docs/programming/class_func/default_arg/","title":"(Python)引数のデフォルト値","content":" (Python)引数のデフォルト値 関数の引数にデフォルト値を設定できる言語がある。\n定義した引数に何も値が入力されなかった場合に、自動でデフォルト値が指定された引数に入るという仕組みである。ここではそれについてを示す。\nPython  Pythonでは関数の定義時に引数に引数名=デフォルト値と書くとデフォルト値を設定できる。\n実行例を以下に示す。\n\u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #関数greet、引数の文字をそのまま返す。引数のデフォルト値は\u0026#34;Hello!\u0026#34; \u0026gt;\u0026gt;\u0026gt; def greet(s=\u0026#39;Hello!\u0026#39;): ... return s ... \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #引数に\u0026#34;World!\u0026#34; -\u0026gt; 引数sに\u0026#34;World!\u0026#34;が入りそれが返る \u0026gt;\u0026gt;\u0026gt; greet(\u0026#39;World!\u0026#39;) \u0026#39;World!\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #引数無し -\u0026gt; 引数sにはデフォルト値\u0026#34;Hello!\u0026#34;が入りそれが返る \u0026gt;\u0026gt;\u0026gt; greet() \u0026#39;Hello!\u0026#39; \u0026gt;\u0026gt;\u0026gt;   "},{"idx":2,"href":"/docs/programming/graph/plot/","title":"(折れ線)グラフを描画する","content":" (折れ線)グラフを描画する Python  グラフを描くためにはmatplotlibのpyplotライブラリを利用する。\nここでは2次元の折れ線グラフを作成する。 そのために、グラフに描画するための座標データを作成する。\n\u0026gt;\u0026gt;\u0026gt; import numpy as np \u0026gt;\u0026gt;\u0026gt; import matplotlib.pyplot as plt \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #x軸データ \u0026gt;\u0026gt;\u0026gt; x = np.array([1,2,3,4,5,6,7,8,9,10]) \u0026gt;\u0026gt;\u0026gt; #y軸データ \u0026gt;\u0026gt;\u0026gt; y = np.array([100,400,200,700,800,300,500,600,900,400]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; x array([ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) \u0026gt;\u0026gt;\u0026gt; y array([100, 400, 200, 700, 800, 300, 500, 600, 900, 400]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #グラフ描画 \u0026gt;\u0026gt;\u0026gt; plt.plot(x,y) [\u0026lt;matplotlib.lines.Line2D object at 0x105dd6a58\u0026gt;] \u0026gt;\u0026gt;\u0026gt; #グラフ描写 \u0026gt;\u0026gt;\u0026gt; plt.show() \u0026gt;\u0026gt;\u0026gt;  実行結果\n  "},{"idx":3,"href":"/docs/programming/number/hex/","title":"16進数に変換して表示","content":" 16進数に変換して表示 数値を16進数に変換して表示する方法についてを示す。\nJava  JavaではラッパークラスIntegerに数値を16進数に変換するメソッドtoHexString()があるのでそれを利用する。\npublic static String toHexString(int i)\n戻り値はStringであり、引数の数値を16進数に表記したものが出力される。\nclass Main{ public static void main(String args[]){ int a = 10; System.out.println(Integer.toHexString(a)); } } 実行結果\n\u0026gt; java Main a   Python  pythonに関しては、数値を16進数に変換して表示する組み込み関数hex()がある。\n表示される文字はプレフィックスとして\u0026rdquo;0x\u0026rdquo;が頭について表示される。\n\u0026gt;\u0026gt;\u0026gt; a = 10 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; hex(a) \u0026#39;0xa\u0026#39; \u0026gt;\u0026gt;\u0026gt;    "},{"idx":4,"href":"/docs/programming/number/dec/","title":"2,8,16進数を10進数に変換して表示","content":" 2,8,16進数を10進数に変換して表示 2,8,16進数を10進数に変換する方法についてを示す。\nJava  Javaでは文字列を数値に変換する の所で述べたメソッドInteger.parseInt()を利用する。\npublic static int parseInt(String s,int radix)\n前述の章で述べたところのメソッドとは別に、オーバーロードとして引数にint radixを加えたものが定義されている。\n入力された(文字列で表した)数値sを、radix進数の数値とみて10進数に変換し、返すというメソッドである。\n変換できないような組み合わせを入力するとエラーが発生する。\nclass Main{ public static void main(String args[]){ System.out.println(Integer.parseInt(\u0026#34;0\u0026#34;, 10)); System.out.println(Integer.parseInt(\u0026#34;777\u0026#34;, 10)); System.out.println(Integer.parseInt(\u0026#34;+77\u0026#34;, 10)); System.out.println(Integer.parseInt(\u0026#34;0101\u0026#34;, 2)); System.out.println(Integer.parseInt(\u0026#34;FF\u0026#34;, 16)); System.out.println(Integer.parseInt(\u0026#34;2147483647\u0026#34;, 10)); System.out.println(Integer.parseInt(\u0026#34;2147483648\u0026#34;, 10)); //Intのオーバーフローなのでエラー  System.out.println(Integer.parseInt(\u0026#34;0b0101\u0026#34;, 2)); //接頭辞0b等は含めなくてよい。これもエラー  } } 実行結果\n\u0026gt; java Main 0 777 77 5 255 2147483647 Exception in thread \u0026quot;main\u0026quot; java.lang.NumberFormatException: For input string: \u0026quot;2147483648\u0026quot; at java.lang.NumberFormatException.forInputString(Unknown Source) at java.lang.Integer.parseInt(Unknown Source) at Main.main(Main.java:12)   Python  Pythonでも文字列を数値に変換する の所で述べたint()関数を利用する。\nclass int(x, base=10)\nこの通り、int関数には第1引数に数値に変換したい文字列、第2引数baseには変換元の(文字列で表した)数値の基数を入力する。\n変換できないような値を入力するとエラーになる。\n実行例を以下に示す。\n\u0026gt;\u0026gt;\u0026gt; int(\u0026#39;010101\u0026#39;,2) 21 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #接頭辞0b,0xは合ってもなくてもよい \u0026gt;\u0026gt;\u0026gt; int(\u0026#39;0b010101\u0026#39;,2) 21 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; int(\u0026#39;0xAA\u0026#39;,16) 170 \u0026gt;\u0026gt;\u0026gt; #接頭辞と基数の組み合わせに注意する \u0026gt;\u0026gt;\u0026gt; int(\u0026#39;0b010101\u0026#39;,16) 184615169 \u0026gt;\u0026gt;\u0026gt; int(\u0026#39;abe\u0026#39;,16) 2750 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #変換できない組み合わせだとエラー \u0026gt;\u0026gt;\u0026gt; int(\u0026#39;0xAA\u0026#39;,2) Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; ValueError: invalid literal for int() with base 2: \u0026#39;0xAA\u0026#39; \u0026gt;\u0026gt;\u0026gt;   "},{"idx":5,"href":"/docs/programming/graph/pcolor/","title":"2変数関数のグラフ(ヒートマップ)を作成する","content":" 2変数関数のグラフ(ヒートマップ)を作成する Python  2変数関数のグラフとして、、ヒートマップで表示するにはpyplotの関数pcolorを利用する。\n前述の2変数関数を定義するで定義した関数をヒートマップに表示する例を示す。\n\u0026gt;\u0026gt;\u0026gt; import math \u0026gt;\u0026gt;\u0026gt; import numpy as np \u0026gt;\u0026gt;\u0026gt; import matplotlib.pyplot as plt \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; def f(x,y): ... return math.sqrt(x**2 + y**2) ... \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; x = np.linspace(-3,3,61) \u0026gt;\u0026gt;\u0026gt; y = np.linspace(-3,3,61) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; z = np.zeros((len(x),len(y))) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; for xi in range(len(x)): ... for yi in range(len(y)): ... z[yi,xi] = f(x[xi],y[yi]) ... \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #zをpcolorでヒートマップにプロット  \u0026gt;\u0026gt;\u0026gt; plt.pcolor(z) \u0026lt;matplotlib.collections.PolyCollection object at 0x113347a58\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #ヒートマップの横にカラーバーを表示させる \u0026gt;\u0026gt;\u0026gt; plt.colorbar() \u0026lt;matplotlib.colorbar.Colorbar object at 0x113bf8eb8\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; plt.show() \u0026gt;\u0026gt;\u0026gt;  実行結果\nヒートマップのグラデーションの色はユーザー側で指定できる。指定したい場合は、plt.gray()、plt.jet()、plt.pink()など色を指定して行う。\n指定できる色はhelp(pyplot.colormaps)を参照すると記載されている。\n試しに、gray()を指定した例を示す。\n\u0026gt;\u0026gt;\u0026gt; #ヒートマップの色調の指定。グレー \u0026gt;\u0026gt;\u0026gt; plt.gray() \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; plt.pcolor(z) \u0026lt;matplotlib.collections.PolyCollection object at 0x113f6fa20\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; plt.colorbar() \u0026lt;matplotlib.colorbar.Colorbar object at 0x115835e48\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; plt.show() \u0026gt;\u0026gt;\u0026gt;  実行結果\n  "},{"idx":6,"href":"/docs/programming/graph/contour/","title":"2変数関数のグラフ(等高線プロット)を作成する","content":" 2変数関数のグラフ(等高線プロット)を作成する Python  2変数関数のグラフとして、等高線プロットで表示するにはpyplotの関数contourを利用する。\n前述の2変数関数のグラフ(３D面グラフ)を作成するで定義した関数を等高線プロットに表示する例を示す。\n\u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; import math \u0026gt;\u0026gt;\u0026gt; import numpy as np \u0026gt;\u0026gt;\u0026gt; import matplotlib.pyplot as plt \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; def f(x,y): ... return math.sqrt(x**2 + y**2) ... \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; x = np.linspace(-3,3,61) \u0026gt;\u0026gt;\u0026gt; y = np.linspace(-3,3,61) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; z = np.zeros((len(x),len(y))) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; for xi in range(len(x)): ... for yi in range(len(y)): ... z[yi,xi] = f(x[xi],y[yi]) ... \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #x,yの交点の座標（格子点）を作成する。xxには格子点のx座標、yyには格子点のy座標が入る \u0026gt;\u0026gt;\u0026gt; xx,yy = np.meshgrid(x,y) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #contour関数で等高線プロット \u0026gt;\u0026gt;\u0026gt; cont = plt.contour(xx,yy,z,5,colors=\u0026#39;black\u0026#39;) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #等高線に表示する高さラベル \u0026gt;\u0026gt;\u0026gt; cont.clabel(fmt=\u0026#39;%3.2f\u0026#39;,fontsize=8) \u0026lt;a list of 7 text.Text objects\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; # x軸 \u0026gt;\u0026gt;\u0026gt; plt.xlabel(\u0026#39;$x_0$\u0026#39;,fontsize=14) Text(0.5, 0, \u0026#39;$x_0$\u0026#39;) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; # y軸 \u0026gt;\u0026gt;\u0026gt; plt.ylabel(\u0026#39;$y_0$\u0026#39;,fontsize=14) Text(0, 0.5, \u0026#39;$y_0$\u0026#39;) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; plt.show() \u0026gt;\u0026gt;\u0026gt;  実行結果\ncontour関数にはx,y,z軸の値に加え、表示する高さのレベル（この例では5）を設定する。\n  "},{"idx":7,"href":"/docs/programming/graph/surface/","title":"2変数関数のグラフ(３D面グラフ)を作成する","content":" 2変数関数のグラフ(３D面グラフ)を作成する Python  2変数関数のグラフとして、3D面グラフで表示するにはmpl_toolkits.mplot3dの関数Axes3Dを利用する。\n前述の2変数関数を定義するで定義した関数を3D面グラフに表示する例を示す。\n\u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; from mpl_toolkits.mplot3d import Axes3D \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; import math \u0026gt;\u0026gt;\u0026gt; import numpy as np \u0026gt;\u0026gt;\u0026gt; import matplotlib.pyplot as plt \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; def f(x,y): ... return math.sqrt(x**2 + y**2) ... \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; x = np.linspace(-3,3,61) \u0026gt;\u0026gt;\u0026gt; y = np.linspace(-3,3,61) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; z=np.zeros((len(x),len(y))) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; for xi in range(len(x)): ... for yi in range(len(y)): ... z[yi,xi] = f(x[xi],y[yi]) ... \u0026gt;\u0026gt;\u0026gt; #x,yの交点の座標（格子点）を作成する。xxには格子点のx座標、yyには格子点のy座標が入る \u0026gt;\u0026gt;\u0026gt; xx,yy = np.meshgrid(x,y) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; xx array([[-3. , -2.9, -2.8, ..., 2.8, 2.9, 3. ], [-3. , -2.9, -2.8, ..., 2.8, 2.9, 3. ], [-3. , -2.9, -2.8, ..., 2.8, 2.9, 3. ], ..., [-3. , -2.9, -2.8, ..., 2.8, 2.9, 3. ], [-3. , -2.9, -2.8, ..., 2.8, 2.9, 3. ], [-3. , -2.9, -2.8, ..., 2.8, 2.9, 3. ]]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; yy array([[-3. , -3. , -3. , ..., -3. , -3. , -3. ], [-2.9, -2.9, -2.9, ..., -2.9, -2.9, -2.9], [-2.8, -2.8, -2.8, ..., -2.8, -2.8, -2.8], ..., [ 2.8, 2.8, 2.8, ..., 2.8, 2.8, 2.8], [ 2.9, 2.9, 2.9, ..., 2.9, 2.9, 2.9], [ 3. , 3. , 3. , ..., 3. , 3. , 3. ]]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; # subplot。projection=\u0026#39;3d\u0026#39;の指定をする \u0026gt;\u0026gt;\u0026gt; ax = plt.subplot(1,1,1,projection=\u0026#39;3d\u0026#39;) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; # plot_surfaceで3D面グラフをプロットする \u0026gt;\u0026gt;\u0026gt; ax.plot_surface(xx,yy,z,rstride=1,cstride=1,alpha=0.3,color=\u0026#39;blue\u0026#39;,edgecolor=\u0026#39;black\u0026#39;) \u0026lt;mpl_toolkits.mplot3d.art3d.Poly3DCollection object at 0x11bbfcac8\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; ax.set_zticks((0,0.2)) [\u0026lt;matplotlib.axis.XTick object at 0x11bbf5400\u0026gt;, \u0026lt;matplotlib.axis.XTick object at 0x1120316a0\u0026gt;] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; ax.view_init(75,-95) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; plt.show() \u0026gt;\u0026gt;\u0026gt;  実行結果\nAxes3Dは3Dグラフを表示するのに使うライブラリである。\nplot_surfaceは3次元面グラフを作成するAxes3Dの関数である。plot_surfaceにグラフ表示したいx,y,z座標のデータを入力する。rstride,cstrideには表示するグリッド線の間隔を指定する。\n  "},{"idx":8,"href":"/docs/programming/graph/2varfunc/","title":"2変数関数を定義する","content":" 2変数関数を定義する Python  2変数関数の定義は関数定義の時に引数を２つ設定すれば良い。\n試しに、f(x,y) = √(x2 + y2)を定義する例を示す。\n\u0026gt;\u0026gt;\u0026gt; import math \u0026gt;\u0026gt;\u0026gt; import numpy as np \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; def f(x,y): ... return math.sqrt(x**2 + y**2) ... \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; x = np.linspace(-3,3,61) \u0026gt;\u0026gt;\u0026gt; y = np.linspace(-3,3,61) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; z = np.zeros((len(x),len(y))) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; for xi in range(len(x)): ... for yi in range(len(y)): ... z[yi,xi] = f(x[xi],y[yi]) ... \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(z) [[4.24264069 4.17252921 4.10365691 ... 4.10365691 4.17252921 4.24264069] [4.17252921 4.10121933 4.03112887 ... 4.03112887 4.10121933 4.17252921] [4.10365691 4.03112887 3.95979797 ... 3.95979797 4.03112887 4.10365691] ... [4.10365691 4.03112887 3.95979797 ... 3.95979797 4.03112887 4.10365691] [4.17252921 4.10121933 4.03112887 ... 4.03112887 4.10121933 4.17252921] [4.24264069 4.17252921 4.10365691 ... 4.10365691 4.17252921 4.24264069]] \u0026gt;\u0026gt;\u0026gt;  実際にグラフに描画する例は次節で示す。\n  "},{"idx":9,"href":"/docs/programming/machine_learning/2dmodel/","title":"2次元入力の面モデル","content":" 2次元入力の面モデル 先程の勾配法の例では入力データは1次元であったが、2次元であった場合はどうだろうか。\n例として、以下のようなデータを用意する。\n   年齢 身長 体重     6 117.9 28.0   16 164.3 58.2   19 171.6 60.1   18 172.7 65.2   9 132.8 35.0   16 170.2 60.9   12 152.3 51.9   14 163.8 56.4   15 168.8 62.9   7 127.2 27.0   10 142.3 44.9   12 156.4 45.9   17 173.1 68.0   18 176.9 67.9   15 158.4 59.1   8 127.1 30.8   11 147.4 45.6   7 123.7 36.1   11 152.0 39.9   19 174.1 69.5    念のため、上記のデータをグラフに表す。\nコードは以下の通り。\nimport numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D x0 = np.array([117.9,164.3,171.6,172.7,132.8,170.2,152.3,163.8,168.8,127.2,142.3,156.4,173.1,176.9,158.4,127.1,147.4,123.7,152.0,174.1]) x1 = np.array([28.0,58.2,60.1,65.2,35.0,60.9,51.9,56.4,62.9,27.0,44.9,45.9,68.0,67.9,59.1,30.8,45.6,36.1,39.9,69.5]) t = np.array([6,16,19,18,9,16,12,14,15,7,10,12,17,18,15,8,11,7,11,19]) fig=plt.figure() ax = Axes3D(fig) ax.set_xlabel(\u0026#34;height\u0026#34;) ax.set_ylabel(\u0026#34;weight\u0026#34;) ax.set_zlabel(\u0026#34;old\u0026#34;) ax.plot(x0,x1,t,marker=\u0026#34;o\u0026#34;,linestyle=\u0026#39;None\u0026#39;) plt.show() グラフを以下の図に示す。\nこれらに対して、身長と体重が与えられたときに年齢を予測するような面を作ることを考えてみよう。\nまず面の式についてだが、一般的に3次元において座標(x,y,z)を通る面の式は\n  $$ ax+by+cz+d=0 (a,b,c,dは実数) $$ となっているが、これを変形することにより、(x0,x1)を入力したときに予測値yを返すような面の式は以下のように表される。\n$$ y=w_{0} x_{0} + w_{1} x_{1} + w_{2} (w_{0} , w_{1} , w_{2} は実数) $$ この式を利用し、予測値と正解値の差の合計が最も小さくなるようなw0,w1,w2を算出することを考える。\n先程の1次元の時と同様に、平均二乗誤差を算出し、解析解を求めてみる。\n正解値をtとおくと、まず平均二乗誤差Jは\n$$ \\begin{aligned} J \u0026= \\frac{1}{N} \\sum_{n=0}^{N-1} (y(x_{n}) - t_{n})^2 \\\\ \u0026= \\frac{1}{N} \\sum_{n=0}^{N-1} (w_{0} x_{n,0} + w_{1} x_{n,1} + w_{2} - t_{n})^2 \\end{aligned} $$ となり、このJが最も小さくなるようなw0,w1,w2を求めれば良い。\nそうなるようなw0,w1,w2の値は、Jをw0,w1,w2でそれぞれ偏微分した時の値が０になる時である。\nJをw0,w1,w2でそれぞれ偏微分、また先ほどと同様に、avg(x)をxの平均値を算出する関数とおくと、各式は以下のように整理される。\n$$ \\begin{aligned} \\frac{\\partial J}{\\partial w_{0} } \u0026= \\frac{2}{N} \\sum_{n=0}^{N-1} (w_{0} x_{n,0} + w_{1} x_{n,1} + w_{2} - t_{n}) x_{n,0} \\\\ \u0026= 2( w_{0} avg((x_{0})^2) + w_{1} avg(x_{0} x_{1}) + w_{2} avg(x_{0}) - avg(t x_{0} ) ) = 0 \\\\ \\frac{\\partial J}{\\partial w_{1} } \u0026= \\frac{2}{N} \\sum_{n=0}^{N-1} (w_{0} x_{n,0} + w_{1} x_{n,1} + w_{2} - t_{n}) x_{n,1} \\\\ \u0026= 2( w_{0} avg(x_{0} x_{1}) + w_{1} avg( (x_{1})^2 ) + w_{2} avg(x_{1}) - avg(t x_{1} ) ) = 0 \\\\ \\frac{\\partial J}{\\partial w_{0} } \u0026= \\frac{2}{N} \\sum_{n=0}^{N-1} (w_{0} x_{n,0} + w_{1} x_{n,1} + w_{2} - t_{n}) x_{n,0} \\\\ \u0026= 2( w_{0} avg(x_{0}) + w_{1} avg(x_{0} x_{1}) + w_{2} avg(x_{0}) - avg(t x_{0} ) ) = 0 \\end{aligned} $$ この３式をそれぞれw0,w1,w2について解くと、w0,w1,w2は以下のように表される。\n$$ \\begin{aligned} w_{0} \u0026= \\frac{cov(t,x_{1}) cov(x_{0},x_{1}) - var(x_{1}) cov(t,x_{0})}{ cov(x_{0},x_{1})^2 - var(x_{0}) var(x_{1})} \\\\ w_{1} \u0026= \\frac{cov(t,x_{0}) cov(x_{0},x_{1}) - var(x_{0}) cov(t,x_{1})}{ cov(x_{0},x_{1})^2 - var(x_{0}) var(x_{1})} \\\\ w_{2} \u0026= - w_{0} avg(x_{0}) - w_{1} avg(x_{1}) + avg(t) \\end{aligned} $$ ここで、\nvar(a) = avg(a2) - avg(a)2\ncov(a,b) = avg(ab)-avg(a)avg(b)\nとする。var(a)はaの分散と呼ばれ、aのばらつき具合を示す値である。\ncov(a,b)はa,bの共分散と呼ばれる値で、a,bがどれぐらい影響しあっているかを示す。\nでは、これらより求める面を実装し、図示してみよう。\nコードを以下に示す。\nimport numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D x0 = np.array([117.9,164.3,171.6,172.7,132.8,170.2,152.3,163.8,168.8,127.2,142.3,156.4,173.1,176.9,158.4,127.1,147.4,123.7,152.0,174.1]) x1 = np.array([28.0,58.2,60.1,65.2,35.0,60.9,51.9,56.4,62.9,27.0,44.9,45.9,68.0,67.9,59.1,30.8,45.6,36.1,39.9,69.5]) t = np.array([6,16,19,18,9,16,12,14,15,7,10,12,17,18,15,8,11,7,11,19]) fig=plt.figure() ax = Axes3D(fig) ax.set_xlabel(\u0026#34;height\u0026#34;) ax.set_ylabel(\u0026#34;weight\u0026#34;) ax.set_zlabel(\u0026#34;old\u0026#34;) ax.plot(x0,x1,t,marker=\u0026#34;o\u0026#34;,linestyle=\u0026#39;None\u0026#39;) ### #t,x0の共分散をcov_tx0とする。以下同様 cov_tx0 = np.mean(t*x0) - np.mean(t)*np.mean(x0) cov_tx1 = np.mean(t*x1) - np.mean(t)*np.mean(x1) cov_x0x1 = np.mean(x0*x1) - np.mean(x0)*np.mean(x1) w0 = (cov_tx1*cov_x0x1 - np.var(x1)*cov_tx0)/(cov_x0x1*cov_x0x1 - np.var(x0)*np.var(x1)) w1 = (cov_tx0*cov_x0x1 - np.var(x0)*cov_tx1)/(cov_x0x1*cov_x0x1 - np.var(x0)*np.var(x1)) w2 = -1 * w0 * np.mean(x0) - w1 * np.mean(x1) + np.mean(t) print(\u0026#34;w0:{0}\u0026#34;.format(w0)) print(\u0026#34;w1:{0}\u0026#34;.format(w1)) print(\u0026#34;w2:{0}\u0026#34;.format(w2)) def plane(x0,x1): return w0*x0 + w1*x1 + w2 h = np.linspace(110,180,71) w = np.linspace(25,75,71) old=np.zeros((len(w),len(h))) for hi in range(len(h)): for wi in range(len(w)): old[wi,hi] = plane(h[hi],w[wi]) hh,ww = np.meshgrid(h,w) ax.plot_surface(hh,ww,old,rstride=1,cstride=1,alpha=0.3,color=\u0026#39;red\u0026#39;,edgecolor=\u0026#39;black\u0026#39;) plt.show() 実行結果\nw0:0.1338551780532153 w1:0.11625116831025058 w2:-13.456713550315381  となり、入力データにおいて面モデルでの最も誤差が少ない最適な面が求められる。\n"},{"idx":10,"href":"/docs/programming/number/oct/","title":"8進数に変換して表示","content":" 8進数に変換して表示 数値を8進数に変換して表示する方法についてを示す。\nJava  JavaではラッパークラスIntegerに数値を8進数に変換するメソッドtoOctalString()があるのでそれを利用する。\npublic static String toOctalString(int i)\n戻り値はStringであり、引数の数値を8進数に表記したものが出力される。\nclass Main{ public static void main(String args[]){ int a = 10; System.out.println(Integer.toOctalString(a)); } } 実行結果\n\u0026gt; java Main 12   Python  pythonに関しては、数値を8進数に変換して表示する組み込み関数oct()がある。\n表示される文字はプレフィックスとして\u0026rdquo;0o\u0026rdquo;が頭について表示される。\n\u0026gt;\u0026gt;\u0026gt; a = 10 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; oct(a) \u0026#39;0o12\u0026#39; \u0026gt;\u0026gt;\u0026gt;   "},{"idx":11,"href":"/docs/about/aboutme/","title":"About me","content":" About Me 自己紹介\nHN WAT\n昔から使っているHNのWATで通しています。Github等一部のSNSではTatsuroh Wakasugiの名を使っていますが、念のため言うと本名ではありません。どちらも由来は本名のスペルから来ております。\n本職は某IT企業に勤務しているSEです。最近はDB設計、バッチ開発(Shell,Python)、画面開発保守(HTML,Flash)等やっております。個人では資格取得、iOSアプリ開発、競技プログラミング(Atcoder,AOJ,Leetcode)、CTF等にも興味があり取り組んでおります。本ブログには日頃の業務及び業務外で得た知見などについてを書き記して行きます。\nSNS等  Twitter  細々と呟いてます\n Qiita  基本このブログに書いているものと内容は同じです。こっちに載せても良さそうな記事があったら載せています\n GitHub  このブログもあります\n AtCoder  緑で停滞中。最近伸び悩んでます\n LeetCode  最近やってなし・・取り組みたい\n LAPRAS  ポートフォリオ自動作成サービス。色んなSNSからデータを取ってきてくれて面白い\n利用経験のある技術  言語\n Java C Python HTML CSS Swift VBA Shell Script(bash) SQL Javascript  フレームワーク・ライブラリ・ツール等\n IBM WebSphere Application Server IBM Cloud AWS GCP   資格  基本情報技術者\n 応用情報技術者\n Oracle Certified Java Programmer, Silver SE 8\n LinuC Level 1\n AWS Cloud Practitioner\n HTML5プロフェッショナル認定試験 レベル1\n TOEIC 720\n 普通自動車第一種免許\n  他に何書こうか・・\n"},{"idx":12,"href":"/docs/front-end/api/","title":"API","content":" API HTMLに関連する各種APIについて。\nマルチメディアグラフィックスAPI HTMLでの音声・動画といったマルチメディアに関する設定や操作を、JavaScript等といった外部ソースから制御することができる。詳しい実装方法については現在は述べないが、設定できる内容の種類についてを述べる。\nマルチメディア HTMLでは、audio要素で音声コンテンツ、video要素で動画コンテンツを埋め込むことができる。\nこの埋め込んだマルチメディアコンテンツを、JavaScriptを使って制御することができる。\n制御できる内容は以下の通り。\n 音声・動画プレイヤーのデザイン変更 コンテンツの再読み込み 再生開始・中断  また、マルチメディアコンテンツの以下のような情報をJavaScriptで取得することができる。\n コンテンツが再生・早送り可能な状態か ネットワーク状況 コンテンツの場所 音量 トラック情報  ストリーミング ストリーミングとは、マルチメディアコンテンツをダウンロードと同時に(ダウンロードできている部分の)再生を行う技術である。\n通常はコンテンツのダウンロードが全て終わってから再生するが、通信状況が悪い場合やコンテンツの容量が大きい場合は非常に時間がかかる場合もあり、コンテンツの利用をスムーズに行えない場合が多い。そのためにストリーミング技術を利用する方法が増えている。\nそのような通信状況等に応じて、適切なビットレートのコンテンツを選択し、ストリーミング再生を実現する技術をAdaptive Streaming技術と呼ぶ。\nAdaptive Streaming技術には、Apple社が開発したプロトコルであるHLS(HTTP Live Streaming)、Adobe社やMicrosoft社などにより開発されたMPEG-DASHのようなプロトコルも存在する。\nまた、JavaScriptのAPIにもストリーミングに対応したものが用意されている。例としてMedia Source ExtensionsはHLSやMPEG-DASHのように、ストリーミング配信されるコンテンツを再生するために作られたAPIである。\nグラフィックス 画像ファイルは、jpegやpngファイルを用意して表示するが、HTML5ではJavascript等の外部ソースを利用しても表示できる。\nJavaScriptを使って画像を描画し、HTMLで表示するにはCanvas要素を利用する。canvasは画像をビットマップ形式で描画する。そのため、拡大縮小すると画像が粗くなる。\n利用方法は以下の通り。\n HTMLにcanvas要素を用意する。 Javascriptでcanvas要素を参照し、描画用のcontextオブジェクトを取得する Javascriptを使って描画する  Javascriptを使った描画では、以下のような操作が可能である。\n 線を描く 円、四角を描く 色を塗る テキストを書く 画像ファイルを読み込む 拡大・縮小・回転する  デバイスアクセスAPI デバイスに関する情報を取得できるAPIについてを述べる。\nGeolocation API GeoLocation APIは、ユーザーの位置情報を取得するためのAPIである。\nGeolocation APIは、無線LAN、Wi-Fi、携帯キャリアの基地局、GPS、IPアドレスなどといったソースを基にユーザーの位置情報を取得する。\n取得できる情報の例は、以下の通り。\n 緯度 経度 高度 方角 速度  DeviceOrientation Event DeviceOrientation Eventは、デバイスの傾きが変化したときに発生するイベントである。\n取得できる情報の例は以下の通り。\n デバイスが差す方角 デバイスの上下方向の傾き デバイスの左右方向の傾き  Touch Events Touch Eventsは、タッチパネルなどの画面を指で操作しているときに発生するイベント類である。\n取得できる情報の例は以下の通り。\n 画面をタッチ 画面をタッチしたまま動かす 画面から離す  Pointer Events Pointer Eventsは、マウスカーソルなどといったポインタと呼ばれる要素に関するイベントである。\n取得できる情報の例は以下の通り。\n ポインタが要素の上に乗る ポインタが要素の上から離れる ポインタが動作状態になる ポインタが非動作状態になる ポインタが動く  DOM3 Events (UI Events) DOM3 Events (UI Events)は、マウスやキーボードなどの入力操作を取り扱うためのイベントである。\n例は以下の通り。\n  イベントの種類 概要   UIイベント UIやHTML文書の操作に関するイベント   フォーカスイベント フォーカスの状態変化に関するイベント   マウスイベント マウス操作に関するイベント   ホイールイベント マウス等ホイールの操作に関するイベント   入力イベント キーボード入力の操作に関するイベント   オフラインストレージAPI 外部のインフラやリソースを利用せずとも、ブラウザ上でデータを保存できる方法がある。ここでは主にその方法についてを述べる。\nWeb Storage Web Storageは、キーと値の組み合わせによってブラウザにデータを蓄積し、利用するAPIである。\nWeb Storageは、大きくセッションストレージとローカルストレージの２種類に分けられる。セッションストレージはウィンドウやタブが閉じられるとデータも消失するが、ローカルストレージはデータが消失されず、次にページを開いたときにでもそのデータを利用することができる。\nIndexed Database API Indexed Database APIはWeb Storageと同様にキーと値のペアによってデータを蓄積するAPIである。蓄積するのはJavaScriptのオブジェクトである。\nWeb Storageと比べると、インデックスやトランザクションを利用できることが特徴である。トランザクションとは、データベースの一連の処理のことである。\nApplication cache Application cacheは、マニフェストファイルと呼ばれる設定ファイルに指定したファイルをローカルのブラウザにキャッシュとして置くことで、オフラインでのページ閲覧を可能にするものである。このキャッシュの制御は、APIを通じて行う。\nWeb Workers Web Workersは、ブラウザでのスクリプト処理をバックグラウンドで実行するためのものである。\n通常は、HTMLのパース、外部ソースなどのスクリプト処理が終わるまでユーザーは画面の操作が行えず、またそのスクリプト処理が大きいとユーザーの操作が行えない時間が増えてしまう。\nそこで、Web Workersでバックグラウンドで実行することで、画面の操作への影響を減らし、またスクリプト処理を並列で多種動かせるので、大量の処理を行わせることができる。\nService Workers Service Workersは、Webページとは別にバックグラウンドでスクリプトを実行する環境である。\n先程のWeb WorkersがWebページの内部で動作するのに対し、Service WorkersはWebページとは別に動作する。\nService Workersを利用することで、リソースをキャッシュしてオフラインでも利用可能にしたり、バックグラウンドでの同期など、Webページやユーザの操作を必要としない機能を提供することができる。\n別環境なので、Webページを開いたタブが閉じられても、Service Workersは必要に応じて動作する。\nPush API Push APIは、アプリケーションがサーバーからのプッシュ通知を受信できるようにするAPIである。\nService Workerと組み合わせることで、アプリケーションが動作にかかわらず受信できる。\nPush APIはあくまでプッシュ通知を受信するだけなので、プッシュ通知の表示やメッセージの表示などは、これとは別に実施する必要がある。\nfetch fetchは、Service Worker上で指定したリソースを取得する際に利用するAPIである。\n通信系API 通信に関するAPIを述べる。\nXMLHttpRequest XMLHttpRequestは、JavaScriptでHTTP通信を実現するAPIである。\nこれにより、ページを遷移せずにHTTP通信を行い、データを取得することが可能になる。\nWebSocket API WebSocket APIは、JavaScriptでWebSocketプロトコル通信を実現するAPIである。\nWebSocketプロトコルは、ブラウザとサーバのどちらからもデータを送信可能な双方向通信を実現するための仕様である。\nWebSocketを利用することで、チャットのような双方向通信が頻繁に発生するアプリケーションを作ることができる。\nServer-Sent Events Server-Sent Eventsは、サーバからのプッシュ通信を実現するAPIである。\n通常のHTTPではクライアントからサーバにリクエストを送信し、レスポンスが変えると通信が終了するが、Server-Sent Eventsでは、サーバからレスポンスを受け取っても通信を終了せず、接続を維持する。\nサーバはその接続を利用してメッセージを継続して送信するが、サーバからしかデータを送信できないという特徴がある。\nWebRTC WebRTC(Web Real-Time Communication)は、ブラウザでリアルタイムなコミュニケーションを実現するための仕組みである。WebRTCを使うことで、ブラウザ間のビデオチャットやボイスチャット、会議システムなどが実現可能です。\n"},{"idx":13,"href":"/docs/programming/procon/binary_indexed_tree-2/","title":"Binary Indexed Tree","content":" Binary Indexed Tree Binary Indexed Tree(BIT)は、セグメント木を応用したデータ構造で、リスト(数列)anが与えられた時、次のことが行える。\n iが与えられた時、a0\u0026hellip;ai-1の和を計算する。 i,xが与えられた時、ai-1+=xとする。  BITをどのように表すかだが、セグメント木と同様に、リストの各要素を木の葉の要素にならべる。\n例として、以下のリストをBITで表すと、以下のような図で表される。\na=[5,2,3,7,4,1,9,10]  BITでは、節点の値にその節点が示す区間の値の和を設定する。\nここから、例えばi=5を入力した時、a0〜a4までの和を求めるが、この求め方もセグメント木の時と同様に、a0〜a4の区間を示す節点を取り出してきて、その値の和を求めれば良い。この例の時、以下のような図で表され、和は17+4=21が返る。\nここで、BITにおいては、区間内の和を示しているので、実は各節点の2つ目の子になっている節点は必要ないことがわかる。(iが与えられた時は2つ目の子の要素は計算に使わない。i,xが与えられた時でai-1が親節点の2つ目の子になっていた場合、ai-1を示す節点の値を書き換えなくても、その親接点から上の接点の要素を書き換えれば、その他の計算には影響を与えないため。)\nそのため、BITは以下のようにも置き換えられる。\nこの図で、灰色の節点は必要のない節点を表す。\nここで、BITを表すリスト(及び配列)とBITの節点を以下の図のように対応づける。\n"},{"idx":14,"href":"/docs/programming/procon/binary_indexed_tree/","title":"Binary Indexed Tree","content":" Binary Indexed Tree Binary Indexed Tree(BIT)は、セグメント木を応用したデータ構造で、リスト(数列)anが与えられた時、次のことが行える。\n iが与えられた時、a1\u0026hellip;aiの和を計算する。 i,xが与えられた時、ai+=xとする。  BITをどのように表すかだが、セグメント木と同様に、リストの各要素を木の葉の要素にならべる。\n例として、以下のリストをBITで表すと、以下のような図で表される。\na=[5,2,3,7,4,1,9,10]  BITでは、節点の値にその節点が示す区間の値の和を設定する。\nここから、例えばi=5を入力した時、a1〜a5までの和を求めるが、この求め方もセグメント木の時と同様に、a1〜a5の区間を示す節点を取り出してきて、その値の和を求めれば良い。この例の時、以下のような図で表され、和は17+4=21が返る。\nここで、BITにおいては、区間内の和を示しているので、実は各節点の2つ目の子になっている節点は必要ないことがわかる。(iが与えられた時は2つ目の子の要素は計算に使わない。i,xが与えられた時でaiが親節点の2つ目の子になっていた場合、aiを示す節点の値を書き換えなくても、その親節点から上の接点の要素を書き換えれば、その他の計算には影響を与えないため。)\nそのため、BITは以下のようにも置き換えられる。\nこの図で、灰色の節点は必要のない節点を表す。\nここで、BITを表すリスト(及び配列)とBITの節点を以下の図のように対応づける。\nここで、リストのインデックスを２進数で表したとき、２進数の1桁目が0のところは一番深いところの要素(要素1つ分の区間の節点)を表し、その1つ上の要素はリストのインデックス(２進数)の1桁目が1で2桁目が0である・・・というように表せる。BITでは、この性質を用いて計算をすることが多い。\nではまず、このデータ構造を用いて、「iが与えられた時、a1\u0026hellip;aiの和を計算する」方法を以下に示す。\naiまでの和を求めるには、\n"},{"idx":15,"href":"/docs/programming/control/break/","title":"break文","content":" break文 ループを抜け出す際に用いるbreak文についてを示す。\nJava  ループ処理のfor文、while文において、処理の途中にbreakがあった場合、ループを途中で中断し、ループから抜け出してくれる。\nループを何重にも重ねていた場合は、そのbreakがある一番内側のループにbreakが適用される。\nclass Main{ public static void main(String args[]){ for(int i=0;i\u0026lt;5;i++){ //i\u0026gt;3になったらループ中断して抜け出す  if(i\u0026gt;3){ break; } //0..3までprint それより上はbreakで中断されるためここには来ない  System.out.println(i); } System.out.println(); for(int i=0;i\u0026lt;3;i++){ System.out.println(i); for(int j=0;j\u0026lt;3;j++){ //j\u0026gt;1になったらループ中断して抜け出す　が、抜け出せるのはjのループだけ  //iのループを抜け出したい時は、その階層内でbreakを設ける  if(j\u0026gt;1){ break; } //j=0..1までprintされる  System.out.println(i+\u0026#34; \u0026#34;+j); } } } } 実行結果\n\u0026gt; java Main 0 1 2 3 0 0 0 0 1 1 1 0 1 1 2 2 0 2 1  ちなみに、switch文ではこのbreak文は必須である。\nbreak文がない場合、該当したcase文以下のcase文の処理が行われてしまうので注意。\n実行例を以下に示す。\nclass Main{ public static void main(String args[]){ int k=1; switch(k){ case 1: System.out.println(1); //break;  case 2: System.out.println(2); //break;  default: System.out.println(\u0026#34;default\u0026#34;); //break;  } } } 実行結果\n\u0026gt; java Main 1 2 default  この例の場合、本当はcase 1の所の処理だけ行わせたいのだが、breakを置かない場合case 1の下、case 2やdefaultの処理も順に行ってしまう。switch文でbreakを設けるのはこれが理由。\n Python  break文の使い方はPythonもjavaと同じ。\n途中で中断したいfor,whileループの中に設定する。\n\u0026gt;\u0026gt;\u0026gt; for i in range(5): ... if(i\u0026gt;3): ... break ... print(i) ... 0 1 2 3 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; for i in range(3): ... for j in range(3): ... if(j\u0026gt;1): ... break ... print(i,j) ... 0 0 0 1 1 0 1 1 2 0 2 1 \u0026gt;\u0026gt;\u0026gt;   "},{"idx":16,"href":"/docs/programming/other/comment/","title":"Comment","content":" コメントアウト プログラミングでコメント（注釈）を付け加えたい時、或いはある箇所だけを実行(・コンパイル)の対象外としたい時にはコメントアウトを使う。ここではコメントアウトの方法についてを示す。\nJava  Javaでのコメントアウトの仕方は以下の通り。\n// (コメント) /* (コメント) */  1行だけをコメントアウトしたい時は//を利用した方が良い。これを利用すると、その行内で//から後は全てコメントアウトされる。\n複数行をコメントアウトするときは/* */を利用する。これを利用すると、/* から */ までの間は全てコメントアウトされる。\n Python  Pythonでは # がコメントアウトの役割を成す。\n＃を書くと、その行で#以後の部分はコメントアウトされる。\n＃は１行に対してのコメントアウトである。\n複数行に対して行うには、コメントアウトしたい行をシングルクォート(\u0026lsquo;)またはダブルクォート(\u0026ldquo;)３つで囲むと、コメントアウトされる。\n# (コメント) ''' (コメント) '''    "},{"idx":17,"href":"/docs/programming/control/continue/","title":"continue文","content":" continue文 continue文はfor文、while文のループ処理において、そのループ1回分の処理をそこで終了し、 条件式の判定（for文の場合は変化式を行ってから）に移らせる文である。\ncontinue文についてを示す。\nJava  Javaでcontinue文を設定したい時は、設定したいfor文、while文のループ処理内に設定する。\n実行例を以下に示す。\nclass Main{ public static void main(String args[]){ for(int i=0;i\u0026lt;5;i++){ if(i\u0026lt;3){ //i\u0026lt;3のときは処理終了 -\u0026gt; i++へ  continue; } System.out.println(i); } System.out.println(); for(int i=0;i\u0026lt;3;i++){ System.out.println(i); for(int j=0;j\u0026lt;3;j++){ if(j\u0026lt;1){ //j\u0026lt;1のときは処理終了 -\u0026gt; j++へ  continue; } System.out.println(i+\u0026#34; \u0026#34;+j); } } } } 実行結果\n\u0026gt; java Main 3 4 0 0 1 0 2 1 1 1 1 2 2 2 1 2 2   Python  Pythonにもcontinue文があり、使い方はjavaと同じ。\nfor,whileループの中で設定する。\n\u0026gt;\u0026gt;\u0026gt; for i in range(5): ... if(i\u0026lt;3): ... continue ... print(i) ... 3 4 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; for i in range(3): ... for j in range(3): ... if(j\u0026lt;1): ... continue ... print(i,j) ... 0 1 0 2 1 1 1 2 2 1 2 2 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt;    "},{"idx":18,"href":"/docs/front-end/css_text/","title":"CSSでのテキスト","content":" CSSでのテキスト CSSでのテキストの表現方法についてを示す。\ntext-shadowプロパティ text-shadowプロパティは、テキストに影を表示させるプロパティである。\n設定できる値は以下の通り。\n none ・・ 影を表示させない   色 ・・ 影の色   数値(2~3個、単位付) ・・ 影の表示位置(1番目から左右、上下、ぼかし範囲の指定)   使用例\n\u0026lt;p style=\u0026quot;text-shadow: 5px 5px 5px red\u0026quot;\u0026gt; テキストに影を表示させる \u0026lt;/p\u0026gt;  表示例\n テキストに影を表示させる \ntext-decoration関連のプロパティ text-decoration系のプロパティは、文字に下線・上線・取消線を引いたり、及びその線種を指定するプロパティである。\nプロパティ名・指定する値・意味は以下の通り。\n  text-decoration-line underline ・・ 下線   overline ・・ 上線   line-through ・・ 取消線   text-decoration-color (色を示す値) ・・ 線に色を付ける   text-decoration-style solid ・・ 実線   double ・・ 二重線   dotted ・・ 点線   dashed ・・ 破線   wavy ・・ 波線   text-decoration 上記で指定する値を空白区切りで区切ってまとめて指定   使用例\n\u0026lt;p\u0026gt;テキストに\u0026lt;span style=\u0026quot;text-decoration:underline;\u0026quot;\u0026gt;下線\u0026lt;/span\u0026gt;を付けてみる\u0026lt;/p\u0026gt;  表示例\n テキストに下線を付けてみる\n\nword-breakプロパティ word-breakプロパティは、行の折り返しの設定を行うプロパティである。\n設定できる値は以下の通り。\n break-all ・・ 全ての文字で折り返しが行える   keep-all ・・ 空白文字が連続しないところでは折り返されない   normal ・・ テキストの言語のルールに従い折り返される   使用例\n\u0026lt;p style=\u0026quot;word-break:break-all\u0026quot;\u0026gt;break-allbreak-allbreak-allbreak-allbreak-allbreak-allbreak-allbreak-allbreak-allbreak-allbreak-allbreak-allbreak-allbreak-allbreak-allbreak-allbreak-allbreak-allbreak-allbreak-allbreak-all\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026quot;word-break:keep-all\u0026quot; \u0026gt;keep-allkeep-allkeep-allkeep-allkeep-allkeep-allkeep-allkeep-allkeep-allkeep-allkeep-allkeep-allkeep-allkeep-allkeep-allkeep-allkeep-allkeep-allkeep-allkeep-allkeep-all\u0026lt;/p\u0026gt;  表示例\n break-allbreak-allbreak-allbreak-allbreak-allbreak-allbreak-allbreak-allbreak-allbreak-allbreak-allbreak-allbreak-allbreak-allbreak-allbreak-allbreak-allbreak-allbreak-allbreak-allbreak-all\nkeep-allkeep-allkeep-allkeep-allkeep-allkeep-allkeep-allkeep-allkeep-allkeep-allkeep-allkeep-allkeep-allkeep-allkeep-allkeep-allkeep-allkeep-allkeep-allkeep-allkeep-all\n\nhyphensプロパティ hyphensプロパティは、ハイフネーションの設定を行うプロパティである。\nハイフネーションとは、語の途中でハイフン(-)を使って改行させる仕様のことである。\n設定できる値は以下の通り。\n manual ・・ \u0026 shy;の場所でのみハイフネーションが行われる   none ・・ ハイフネーションは一切行わない(\u0026 shy;も無視される)   auto ・・ 言語に応じてブラウザが適当な箇所でハイフネーションを行う(lang属性による言語の指定が必要となる)   使用例\n\u0026lt;p style=\u0026quot;hyphens:manual\u0026quot;\u0026gt;au\u0026amp;shy;toau\u0026amp;shy;toau\u0026amp;shy;toau\u0026amp;shy;toau\u0026amp;shy;toau\u0026amp;shy;toau\u0026amp;shy;toau\u0026amp;shy;toau\u0026amp;shy;toau\u0026amp;shy;toau\u0026amp;shy;toau\u0026amp;shy;toau\u0026amp;shy;toau\u0026amp;shy;toau\u0026amp;shy;toau\u0026amp;shy;toau\u0026amp;shy;toau\u0026amp;shy;toau\u0026amp;shy;toau\u0026amp;shy;toau\u0026amp;shy;toau\u0026amp;shy;toau\u0026amp;shy;toau\u0026amp;shy;toau\u0026amp;shy;toau\u0026amp;shy;toau\u0026amp;shy;toau\u0026amp;shy;toau\u0026amp;shy;toau\u0026amp;shy;toau\u0026amp;shy;to\u0026lt;/p\u0026gt;  表示例\n au\u0026shy;toau\u0026shy;toau\u0026shy;toau\u0026shy;toau\u0026shy;toau\u0026shy;toau\u0026shy;toau\u0026shy;toau\u0026shy;toau\u0026shy;toau\u0026shy;toau\u0026shy;toau\u0026shy;toau\u0026shy;toau\u0026shy;toau\u0026shy;toau\u0026shy;toau\u0026shy;toau\u0026shy;toau\u0026shy;toau\u0026shy;toau\u0026shy;toau\u0026shy;toau\u0026shy;toau\u0026shy;toau\u0026shy;toau\u0026shy;toau\u0026shy;toau\u0026shy;toau\u0026shy;toau\u0026shy;to\n\nwhite-spaceプロパティ white-spaceプロパティは、「連続する空白文字を１つにまとめるか」など、空白文字に関する設定を行うプロパティである。\n設定できる値と意味は以下の通り。\n normal ・・ 半角スペース・改行・タブを一つの半角スペースにまとめる。幅が広くなった場合、行を折り返す。   nowrap ・・ 半角スペース・改行・タブを一つの半角スペースにまとめる。幅が広くなっても行は折り返さない。   pre ・・ 半角スペース・改行・タブはまとめず、入力した通りに表示される。幅が広くなっても行は折り返さない。   pre-wrap ・・ 半角スペース・改行・タブはまとめず、入力した通りに表示される。幅が広くなった場合、行を折り返す。   使用例\n\u0026lt;p style=\u0026quot;white-space:normal\u0026quot; \u0026gt; あ い う え お か き く け こ \u0026lt;/p\u0026gt; \u0026lt;p style=\u0026quot;white-space:pre-wrap\u0026quot;\u0026gt; あ い う え お か き く け こ \u0026lt;/p\u0026gt;  表示例\n あ い う え お か き く け こ あ い う え お か き く け こ \ntext-alignプロパティ text-alignプロパティは、要素の行揃えを設定するプロパティである。\n設定できる値と意味は以下の通り。\n left ・・ 左揃え   right ・・ 右揃え   center ・・ 中央揃え   justify ・・ 両端揃え   使用例\n\u0026lt;p style=\u0026quot;text-align:left\u0026quot; \u0026gt;あいうえおかきくけこさしすせそ\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026quot;text-align:right\u0026quot; \u0026gt;あいうえおかきくけこさしすせそ\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026quot;text-align:center\u0026quot; \u0026gt;あいうえおかきくけこさしすせそ\u0026lt;/p\u0026gt;  表示例\n あいうえおかきくけこさしすせそ\nあいうえおかきくけこさしすせそ\nあいうえおかきくけこさしすせそ\n\nvertical-alignプロパティ vertical-alignプロパティは、行の中での文字の縦方向の揃え位置を設定するプロパティである。\n設定できる値と意味は以下の通り。\n baseline ・・ 親要素(アルファベット)のベースラインに合わせる   top ・・ 上揃え   middle ・・ 中央揃え   bottom ・・ 下揃え   super ・・ 上付き文字の位置に揃える   sub ・・ 下付き文字の位置に揃える   使用例\n\u0026lt;div\u0026gt; \u0026lt;span style=\u0026quot;font-size:30px\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;font-size:10px;vertical-align:baseline\u0026quot;\u0026gt;bcde\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;font-size:10px;vertical-align:top\u0026quot;\u0026gt;fghi\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;font-size:10px;vertical-align:middle\u0026quot;\u0026gt;jklm\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;font-size:10px;vertical-align:bottom\u0026quot;\u0026gt;nopq\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt;  表示例\n  a bcde fghi jklm nopq  \nline-heightプロパティ line-heightプロパティは、行間を設定するプロパティである。\n設定できる値と意味は以下の通り。\n 数値(単位なし) ・・ この数値とフォントサイズを掛けた値が行間になる   数値(単位px) ・・ pxの長さが行間になる   パーセンテージ ・・ フォントサイズに対するパーセンテージが行間になる   normal ・・ ブラウザが妥当とする行間に設定する   使用例\n\u0026lt;p style=\u0026quot;line-height:100px\u0026quot;\u0026gt; あいうえお\u0026lt;br\u0026gt; かきくけこ\u0026lt;br\u0026gt; さしすせそ\u0026lt;br\u0026gt; たちつてと\u0026lt;br\u0026gt; なにぬねの\u0026lt;br\u0026gt; \u0026lt;/p\u0026gt;  表示例\n あいうえお\nかきくけこ\nさしすせそ\nたちつてと\nなにぬねの\n\ntext-indentプロパティ text-indentプロパティは、要素の１行目のインデントを設定するプロパティである。\n設定できる値と意味は以下の通り。\n 数値(単位px) ・・ pxの値に応じてインデントされる   パーセンテージ ・・ 幅に対するパーセンテージの分だけ   使用例\n\u0026lt;p style=\u0026quot;text-indent:10px\u0026quot;\u0026gt;あいうえお\u0026lt;p\u0026gt; \u0026lt;p style=\u0026quot;text-indent:20px\u0026quot;\u0026gt;かきくけこ\u0026lt;p\u0026gt; \u0026lt;p style=\u0026quot;text-indent:30px\u0026quot;\u0026gt;さしすせそ\u0026lt;p\u0026gt; \u0026lt;p style=\u0026quot;text-indent:5%\u0026quot;\u0026gt;たちつてと\u0026lt;p\u0026gt; \u0026lt;p style=\u0026quot;text-indent:10%\u0026quot;\u0026gt;なにぬねの\u0026lt;p\u0026gt; \u0026lt;p style=\u0026quot;text-indent:15%\u0026quot;\u0026gt;はひふへほ\u0026lt;p\u0026gt;  表示例\n あいうえお かきくけこ さしすせそ たちつてと なにぬねの はひふへほ \nletter-spacingプロパティ letter-spacingプロパティは、文字の間隔を設定するプロパティである。\n設定できる値と意味は以下の通り。\n 数値(単位px) ・・ pxの値に応じて文字間隔が設定される   normal ・・ 標準の間隔にする   使用例\n\u0026lt;p style=\u0026quot;letter-spacing:10px\u0026quot;\u0026gt;あいうえお\u0026lt;p\u0026gt; \u0026lt;p style=\u0026quot;letter-spacing:20px\u0026quot;\u0026gt;かきくけこ\u0026lt;p\u0026gt;  表示例\n あいうえお かきくけこ \nword-spacing プロパティ word-spacingプロパティは、単語の間隔を設定するプロパティである。\n設定できる値と意味は以下の通り。\n 数値(単位px) ・・ pxの値に応じて文字間隔が設定される   normal ・・ 標準の間隔にする   使用例\n\u0026lt;p style=\u0026quot;word-spacing:10px\u0026quot;\u0026gt;I do my best.\u0026lt;p\u0026gt; \u0026lt;p style=\u0026quot;word-spacing:20px\u0026quot;\u0026gt;I will pass HTML5 Proffesinal Certification examination.\u0026lt;p\u0026gt;  表示例\n I do my best. I will pass HTML5 Proffesinal Certification examination. \ntext-transformプロパティ text-transformプロパティは、アルファベットの大文字小文字を変換して表示させるプロパティである。\n設定できる値と意味は以下の通り。\n uppercase ・・ 半角アルファベットを全て大文字にする   normal ・・ 半角アルファベットを全て小文字にする   capitalize ・・ 半角アルファベットの単語の先頭一文字のみを大文字にする   none ・・ 変化させない   使用例\n\u0026lt;p style=\u0026quot;text-transform:uppercase\u0026quot;\u0026gt;How are you?\u0026lt;p\u0026gt; \u0026lt;p style=\u0026quot;text-transform:lowercase\u0026quot;\u0026gt;I do my best.\u0026lt;p\u0026gt; \u0026lt;p style=\u0026quot;text-transform:capitalize\u0026quot;\u0026gt;I will pass html5 proffesinal certification examination.\u0026lt;p\u0026gt;  表示例\n How are you? I do my best. I will pass html5 proffesinal certification examination. \ndirectionプロパティ directionプロパティは、テキストの表記の方向を設定するプロパティである。\n設定できる値と意味は以下の通り。\n ltr ・・ 左から右に表記する   rtl ・・ 右から左に表記する   使用例は下のunicode-bidiプロパティで示す。\nunicode-bidiプロパティ unicode-bidiプロパティは、Unicodeの文字表記の方向を上書きするプロパティである。\n設定できる値と意味は以下の通り。\n normal ・・ 上書きしない   embed ・・ directionプロパティで設定した値を組み込む   bidi-override ・・ 既存のunicodeの文字表記の設定を無効にし、directionプロパティで設定した値で上書きする。   使用例\n\u0026lt;p style=\u0026quot;direction:ltr\u0026quot;\u0026gt;How are you?\u0026lt;p\u0026gt; \u0026lt;p style=\u0026quot;direction:rtl\u0026quot;\u0026gt;I do my best.\u0026lt;p\u0026gt; \u0026lt;p style=\u0026quot;direction:rtl;unicode-bidi:bidi-override\u0026quot;\u0026gt;I will pass html5 proffesinal certification examination.\u0026lt;p\u0026gt;  表示例\n How are you? I do my best. I will pass html5 proffesinal certification examination. \n"},{"idx":19,"href":"/docs/front-end/css_font/","title":"CSSでのフォント","content":" CSSでのフォント CSSでのフォントについて示す。\nWebフォント CSSでフォントを指定しても、ユーザーの環境にそのフォントがインストールされていなければ使用することは基本できない。\nしかし、@font-faceという書式を使用することで、Web上にあるフォントを利用でき、自身のブラウザに表示させることができる。\n設定できる値は以下の通り。\n font-family ・・ 利用するフォントの名前   src ・・ フォントのURL。url(...)の形で指定する   使用例として、下記のhtmlをiframeに組み込んで表示させてみる。\n(フォントはGoogle Fonts(https://fonts.google.com/specimen/Rowdies?sidebar.open\u0026amp;selection.family=Rowdies)から拝借しました)\n\u0026lt;!DOCTYPE HTML\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;font-faceサンプル\u0026lt;/title\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; @font-face { font-family: Rowdies; src: url(../fonts/Rowdies-Regular.ttf) } h1 { font-family: Rowdies } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;The sample of font-face.\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; iframe使用例\n\u0026lt;iframe width=\u0026quot;500\u0026quot; height=\u0026quot;200\u0026quot; src=\u0026quot;/css_sample_pages/font-face.html\u0026quot;\u0026gt; \u0026lt;/iframe\u0026gt;  表示例\n  \nfont-familyプロパティ font-familyプロパティは、フォントの種類を設定するプロパティである。\n値にはフォントの種類名を記述する。スペース区切りで複数入力することもできる。その際は、左にあるものから優先されて使われる。\n使用例\n\u0026lt;p style=\u0026quot;font-family:serif;\u0026quot;\u0026gt;The example of font 1\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026quot;font-family:cursive;\u0026quot;\u0026gt;The example of font 2\u0026lt;/p\u0026gt;  表示例\n The example of font 1\nThe example of font 2\n\nfont-sizeプロパティ font-sizeプロパティは、フォントサイズを設定するプロパティである。\n設定できる値と意味は以下の通り。\n  数値(単位px) ・・ 数値に応じたフォントサイズになる   パーセンテージ(単位%) ・・ 親要素のフォントサイズに対するパーセンテージ分のフォントサイズになる   xx-small ・・ 指定したキーワードで大きさが決まる。xx-smallが最も小さく、xx-largeが最も大きくなる   x-small   small   medium   large   x-large   xx-large   使用例\n\u0026lt;p style=\u0026quot;font-size:xx-small;\u0026quot;\u0026gt;xx-small\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026quot;font-size:medium;\u0026quot;\u0026gt;medium\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026quot;font-size:xx-large;\u0026quot;\u0026gt;xx-large\u0026lt;/p\u0026gt;  表示例\n xx-small\nmedium\nxx-large\n\nfont-weightプロパティ font-weightプロパティは、フォントの太さを設定するプロパティである。\n設定できる値と意味は以下の通り。\n  bold ・・ 太字にする   100 ・・ 指定したキーワードで大きさが決まる。100が最も小さく、900が最も大きくなる.400の時が基準で、「bold」の時は700の時の太さになる。(しかし、フォントによっては９段階の太さを設定していないものもあるので、値を変えても変化がない場合もある)   200   300   400   500   600   700   800   900   bolder ・・ 現在の太さよりも一段階太くする   lighter ・・ 現在の太さよりも一段階細くする   normal ・・ 標準の太さ(400)にする   使用例\n\u0026lt;p style=\u0026quot;font-weight:100;\u0026quot;\u0026gt;font-weight:100\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026quot;font-weight:300;\u0026quot;\u0026gt;font-weight:300\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026quot;font-weight:500;\u0026quot;\u0026gt;font-weight:500\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026quot;font-weight:700;\u0026quot;\u0026gt;font-weight:700\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026quot;font-weight:900;\u0026quot;\u0026gt;font-weight:900\u0026lt;/p\u0026gt;  表示例\n font-weight:100\nfont-weight:300\nfont-weight:500\nfont-weight:700\nfont-weight:900\n\nfont-styleプロパティ font-styleプロパティは、イタリックまたは斜体の書体を選択するためのプロパティである。\n設定できる値と意味は以下の通り。\n oblique ・・ 斜体で表示する。   italic ・・ イタリック体で表示する。フォントにイタリック体での表示形式がない場合は、「oblique」の時と同じになる   normal ・・ 標準のフォントで表示   使用例\n\u0026lt;p style=\u0026quot;font-style:oblique;\u0026quot;\u0026gt;oblique\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026quot;font-style:italic ;\u0026quot;\u0026gt;italic\u0026lt;/p\u0026gt;  表示例\n oblique\nitalic\n\nfont-variantプロパティ font-variantプロパティは、フォントをスモールキャップ（小文字を小さい大文字で表す形式）で表したい時に利用するプロパティである。\n設定できる値と意味は以下の通り。\n normal ・・ 標準のフォントで表示   small-caps ・・ スモールキャップで表示。ただしスモールキャップが設定されていないフォントでは、単純に大文字を縮小したものを小文字として表示する。   使用例\n\u0026lt;p style=\u0026quot;font-variant:normal ;\u0026quot;\u0026gt;ABCDEFGhijklmn\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026quot;font-variant:small-caps;\u0026quot;\u0026gt;ABCDEFGhijklmn\u0026lt;/p\u0026gt;  表示例\n ABCDEFGhijklmn\nABCDEFGhijklmn\n\nfontプロパティ fontプロパティは、これまでに出たfont-xx関連のプロパティの値をまとめて指定できるプロパティである。\n値はスペース区切りで複数入力する方式だが、左から以下の順番で指定するという決まりがあるので注意。\n font-weight,font-style,font-variantの値（省略可） font-sizeの値（省略不可） line-heightの値をfont-sizeの後にスラッシュを書いて指定（省略可） font-familyの値（省略不可）  使用例\n\u0026lt;p style=\u0026quot;font: oblique xx-large cursive;\u0026quot;\u0026gt;ABCDEFGhijklmn\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026quot;font: 900 small-caps medium serif;\u0026quot;\u0026gt;ABCDEFGhijklmn\u0026lt;/p\u0026gt;  表示例\n ABCDEFGhijklmn\nABCDEFGhijklmn\n\n"},{"idx":20,"href":"/docs/front-end/css_box/","title":"CSSでのボックス","content":" CSSのボックス CSSで扱うボックスについて。\n前述した通り、HTMLでは要素内容の表示にはボックスと呼ばれる単位で表示される。\nボックスの詳細は以下の図の通り。\nCSSでは、ボックスの各部分の長さなどを設定することができる。\nここでは、ボックスに関連するCSSのプロパティについてを記載する。\nマージン関連のプロパティ CSSでは、ボックスのマージンの長さを設定することができる。\nそのためのプロパティは以下の通り。\n margin-top ・・ マージンの上部分   margin-bottom ・・ マージンの下部分   margin-left ・・ マージンの左部分   margin-right ・・ マージンの右部分   margin ・・ マージンの各部分(指定できる値は1~4個)   中でも、marginプロパティは設定した値の数で、以下の通りに意味合いが変わってくる。\n 値の数 適用箇所 例   1 上下左右全て margin 10px;   2 上下 左右 margin 10px 10px;   3 上 左右 下 margin 10px 10px 10px;   4 上 右 下 左 margin 10px 10px 10px 10px;   margin関連のプロパティに設定する値は以下の通り。\n 数値(単位px) ・・ pxの値が長さになる   数値(単位%) ・・ 要素内容を表示する領域の幅に対する比率の長さになる   auto ・・ ボックスの状況から自動設定する   使用例\n\u0026lt;p style=\u0026quot;background-color: #66ccff; margin: 10px;\u0026quot;\u0026gt;マージン上下左右10px\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026quot;background-color: #66ccff; margin: 10px 20px;\u0026quot;\u0026gt;マージン上下10px、左右20px\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026quot;background-color: #66ccff; margin: 10px 20px 30px;\u0026quot;\u0026gt;マージン上10px、左右20px、下30px\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026quot;background-color: #66ccff; margin: 10px 20px 30px 40px;\u0026quot;\u0026gt;マージン上10px、右20px、下30px、左40px\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026quot;background-color: #66ccff; margin: auto;\u0026quot;\u0026gt;マージンauto\u0026lt;/p\u0026gt;  表示例\n マージン上下左右10px\nマージン上下10px、左右20px\nマージン上10px、左右20px、下30px\nマージン上10px、右20px、下30px、左40px\nマージンauto\n\nパディング関連のプロパティ 同様に、CSSではボックスのパディングの長さを設定することができる。\nそのためのプロパティは以下の通り。\n padding-top ・・ パディングの上部分   padding-bottom ・・ パディングの下部分   padding-left ・・ パディングの左部分   padding-right ・・ パディングの右部分   padding ・・ パディングの各部分(指定できる値は1~4個)   同様に、paddingプロパティは設定した値の数で、以下の通りに意味合いが変わってくる。\n 値の数 適用箇所 例   1 上下左右全て padding 10px;   2 上下 左右 padding 10px 10px;   3 上 左右 下 padding 10px 10px 10px;   4 上 右 下 左 padding 10px 10px 10px 10px;   padding関連のプロパティに設定する値は以下の通り。\n 数値(単位px) ・・ pxの値が長さになる   数値(単位%) ・・ 要素内容を表示する領域の幅に対する比率の長さになる   使用例\n\u0026lt;p style=\u0026quot;background-color: #66ff99; padding: 10px;\u0026quot;\u0026gt;パディング上下左右10px\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026quot;background-color: #66ff99; padding: 10px 20px;\u0026quot;\u0026gt;パディング上下10px、左右20px\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026quot;background-color: #66ff99; padding: 10px 20px 30px;\u0026quot;\u0026gt;パディング上10px、左右20px、下30px\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026quot;background-color: #66ff99; padding: 10px 20px 30px 40px;\u0026quot;\u0026gt;パディング上10px、右20px、下30px、左40px\u0026lt;/p\u0026gt;  表示例\n パディング上下左右10px\nパディング上下10px、左右20px\nパディング上10px、左右20px、下30px\nパディング上10px、右20px、下30px、左40px\n\nボーダー関連のプロパティ 同じように、CSSではボックスのボーダーの種類を設定することができる。\nそのためのプロパティは以下の通り。\n  プロパティ名 設定対象 設定する値   border-top-style 上のボーダーの線種 solid:実線\ndouble:二重線\ndotted:点線\ndashed:破線\ngroove:溝線\ninset:内側が低くなるような線\noutset:内側が高くなるような線\nnone,hidden:表示しない\n他    border-bottom-style 下のボーダーの線種   border-left-style 左のボーダーの線種   border-right-style 右のボーダーの線種   border-style 上下左右のボーダーの線種(値1~4個)   border-top-width 上のボーダーの太さ 数値(単位px):数値に応じた太さ\nthin:細い\nmedium:中くらい\nthick:太い\n他    border-bottom-width 下のボーダーの太さ   border-left-width 左のボーダーの太さ   border-right-width 右のボーダーの太さ   border-width 上下左右のボーダーの太さ(値1~4個)   border-top-color 上のボーダーの色 色を示す値    border-bottom-color 下のボーダーの色   border-left-color 左のボーダーの色   border-right-color 右のボーダーの色   border-color 上下左右のボーダーの色(値1~4個)   border-top 上のボーダーの線種・太さ・色 線種・太さ・色を示す値を空白区切りで指定    border-bottom 下のボーダーの線種・太さ・色   border-left 左のボーダーの線種・太さ・色   border-right 右のボーダーの線種・太さ・色   border 上下左右のボーダーの線種・太さ・色(全てに同じ値を適用)   使用例\n\u0026lt;table style=\u0026#34;border-style:double dotted dashed groove\u0026#34;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;border-style\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;br\u0026gt; \u0026lt;table style=\u0026#34;border-style:double; border-width:thin medium thick\u0026#34;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;border-width\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; 表示例\n  border-style    border-width    ## ボックス関連のプロパティ ボックス全体に関するプロパティを示す。  値の数 適用箇所   box-sizing 適用箇所を示す。例として\ncontent-box:要素内容を表示する領域のみ\nborder-box:ボーダー領域まで含める   width ボックスの幅   height ボックスの高さ   min-width ボックスの最小の幅   min-height ボックスの最小の高さ   max-width ボックスの最大の幅   max-height ボックスの最大の高さ   使用例\n\u0026lt;p style=\u0026#34;background-color: #66ff99;\u0026#34;\u0026gt;p sample1\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026#34;background-color: #66ff99; width:200px\u0026#34;\u0026gt;p sample2\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026#34;background-color: #66ff99; width:200px; height:200px\u0026#34;\u0026gt;p sample3\u0026lt;/p\u0026gt; 表示例\n p sample1\np sample2\np sample3\n\nborder-radiusプロパティ border-radiusプロパティは、ボックスの角を丸くするプロパティである。\n  プロパティ名 設定対象   border-top-left-radius 左上の角丸   border-top-right-radius 右上の角丸   border-bottom-right-radius 右下の角丸   border-bottom-left-radius 左下の角丸   border-radius 上下左右の角丸(値1~4個)   値には、丸くする部分を円の1/4とした時の円弧とした時の、円の半径を単位付きの数値(px,%など)で指定する。\n使用例\n\u0026lt;p style=\u0026#34;background-color: #66ff99; height:100px; border-radius: 10px\u0026#34;\u0026gt;p 全10px\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026#34;background-color: #66ff99; height:100px; border-radius: 10px 30px\u0026#34;\u0026gt;p 左上右下10px,右上左下30px\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026#34;background-color: #66ff99; height:100px; border-radius: 10px 30px 50px\u0026#34;\u0026gt;p 左上10px,右上左下30px,右下50px\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026#34;background-color: #66ff99; height:100px; border-radius: 10px 30px 50px 70px\u0026#34;\u0026gt;p 左上10px,右上30px,右下50px,左下70px\u0026lt;/p\u0026gt; 表示例\n p 全10px\np 左上右下10px,右上左下30px\np 左上10px,右上左下30px,右下50px\np 左上10px,右上30px,右下50px,左下70px\n\nbox-shadowプロパティ  値 意味   数値(単位px) 2~4個まで指定でき、意味は１個目から右にずらす範囲、下にずらす範囲、ぼかす範囲、四方に拡張させる範囲を表す。   色を示す値 影の色を示す。   inset この値を入れると、影が内側に表示される。   none 影を表示しない。   使用例\n\u0026lt;p style=\u0026#34;background-color: #66ff99; height:50px; box-shadow:10px\u0026#34;\u0026gt;p 右10px\u0026lt;/p\u0026gt; \u0026lt;br\u0026gt; \u0026lt;p style=\u0026#34;background-color: #66ff99; height:50px; box-shadow:10px 10px\u0026#34;\u0026gt;p 右下10px\u0026lt;/p\u0026gt; \u0026lt;br\u0026gt; \u0026lt;p style=\u0026#34;background-color: #66ff99; height:50px; box-shadow:10px 10px 10px\u0026#34;\u0026gt;p 右下10px, ぼかし10px\u0026lt;/p\u0026gt; \u0026lt;br\u0026gt; \u0026lt;p style=\u0026#34;background-color: #66ff99; height:50px; box-shadow:10px 10px 10px 10px\u0026#34;\u0026gt;p 右下10px, ぼかし10px, 四方10px\u0026lt;/p\u0026gt; \u0026lt;br\u0026gt; \u0026lt;p style=\u0026#34;background-color: #66ff99; height:50px; box-shadow:10px 10px 10px 10px #663399\u0026#34;\u0026gt;p 右下10px, ぼかし10px, 四方10px\u0026lt;/p\u0026gt; \u0026lt;br\u0026gt; \u0026lt;p style=\u0026#34;background-color: #66ff99; height:50px; box-shadow:10px 10px 10px 10px inset\u0026#34;\u0026gt;p 右下10px, ぼかし10px, 四方10px\u0026lt;/p\u0026gt; 表示例\n p 右10px\np 右下10px\np 右下10px, ぼかし10px\np 右下10px, ぼかし10px, 四方10px\np 右下10px, ぼかし10px, 四方10px\np 右下10px, ぼかし10px, 四方10px\n\nfloatプロパティ floatプロパティは、ボックスを左または右に寄せて配置し、後続の要素をその反対側に記載させるようにするプロパティである。\n指定する値と意味は以下の通り。\n 値 意味   left ボックスを左側に寄せ、後続の要素を右側に配置させる   right ボックスを右側に寄せ、後続の要素を左側に配置させる   none ボックスを寄せない   使用例\n\u0026lt;img src=\u0026quot;/css_sample_pages/img_small.jpg\u0026quot; style=\u0026quot;float:left\u0026quot;\u0026gt; \u0026lt;p style=\u0026quot;background-color: #66ff99;\u0026quot;\u0026gt;p要素ボックス左\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026quot;background-color: #66ff99;\u0026quot;\u0026gt;←左に画像\u0026lt;/p\u0026gt; \u0026lt;br\u0026gt; \u0026lt;br\u0026gt; \u0026lt;br\u0026gt; \u0026lt;img src=\u0026quot;/css_sample_pages/img_small.jpg\u0026quot; style=\u0026quot;float:right\u0026quot;\u0026gt; \u0026lt;p style=\u0026quot;background-color: #66ff99;\u0026quot;\u0026gt;p要素ボックス右\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026quot;background-color: #66ff99;\u0026quot;\u0026gt;右に画像→\u0026lt;/p\u0026gt; \u0026lt;br\u0026gt; \u0026lt;br\u0026gt; \u0026lt;br\u0026gt;  表示例\n p要素ボックス左\n←左に画像\np要素ボックス右\n右に画像→\n\nclearプロパティ clearプロパティは、floatプロパティで寄せられたボックスの反対側に、後続の要素がくる状態を解除するプロパティである。\n指定する値と意味は以下の通り。\n 値 意味   left 直前にfloat:leftがあった時、後続の要素が右に来るという状態を解除する   right 直前にfloat:rightがあった時、後続の要素が左に来るという状態を解除する   both 直前にfloat:leftまたはright があった時、後続の要素が左右どちらかに来るという状態を解除する   none float関連の解除をしない   使用例\n\u0026lt;img src=\u0026quot;/css_sample_pages/img_small.jpg\u0026quot; style=\u0026quot;float:left\u0026quot;\u0026gt; \u0026lt;p style=\u0026quot;background-color: #66ff99\u0026quot;\u0026gt;p要素ボックス右\u0026lt;br\u0026gt;←左に画像\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026quot;clear:none\u0026quot;\u0026gt;clearを指定しないと後続の要素も回り込みます\u0026lt;/p\u0026gt; \u0026lt;br\u0026gt; \u0026lt;br\u0026gt; \u0026lt;img src=\u0026quot;/css_sample_pages/img_small.jpg\u0026quot; style=\u0026quot;float:left\u0026quot;\u0026gt; \u0026lt;p style=\u0026quot;background-color: #66ff99\u0026quot;\u0026gt;p要素ボックス右\u0026lt;br\u0026gt;←左に画像\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026quot;clear:left\u0026quot;\u0026gt;clearを指定すると後続の要素は回り込みません\u0026lt;/p\u0026gt;  表示例\n p要素ボックス右\n←左に画像\nclearを指定しないと後続の要素も回り込みます\np要素ボックス右\n←左に画像\nclearを指定すると後続の要素は回り込みません\n\ndisplayプロパティ displayプロパティは、要素の表示形式を設定するプロパティである。\nインライン要素をブロックレベル要素に、あるいはその逆などの表示をさせることができる。\n  プロパティ名 設定対象   inline インライン要素と同じ表示にする   block ブロックレベル要素と同じ表示にする   list-item リストと同じ表示にする   table テーブル(table要素)と同じ表示にする   inline-table インラインテーブルと同じ表示にする   table-row-group tbody要素と同じ表示にする   table-header-group thead要素と同じ表示にする   table-footer-group tfoot要素と同じ表示にする   table-row tr要素と同じ表示にする   table-column-group colgroup要素と同じ表示にする   table-column col要素と同じ表示にする   table-cell td要素と同じ表示にする   table-caption caption要素と同じ表示にする   ruby ruby要素と同じ表示にする   ruby-base rb要素と同じ表示にする   ruby-text rt要素と同じ表示にする   none ボックスが無い状態で表示する   使用例\n\u0026lt;p style=\u0026#34;background-color: #66ff99; display:block\u0026#34;\u0026gt;ブロック1\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026#34;background-color: #66ff99; display:block\u0026#34;\u0026gt;ブロック2\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026#34;background-color: #66ff99; display:block\u0026#34;\u0026gt;ブロック3\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026#34;background-color: #66ff99; display:block\u0026#34;\u0026gt;ブロック4\u0026lt;/p\u0026gt; \u0026lt;br\u0026gt; \u0026lt;p style=\u0026#34;background-color: #66ff99; display:inline\u0026#34;\u0026gt;インライン1\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026#34;background-color: #66ff99; display:inline\u0026#34;\u0026gt;インライン2\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026#34;background-color: #66ff99; display:inline\u0026#34;\u0026gt;インライン3\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026#34;background-color: #66ff99; display:inline\u0026#34;\u0026gt;インライン4\u0026lt;/p\u0026gt; 表示例\n ブロック1\nブロック2\nブロック3\nブロック4\nインライン1\nインライン2\nインライン3\nインライン4\n\nvisibilityプロパティ visiblityプロパティは、ボックスが透明になったかのように見えなくさせることのできるプロパティである。\n指定する値と意味は以下の通り。\n 値 意味   visible ボックスを見える状態にする   hidden ボックスを見えなくさせる   collapse テーブル内の要素に指定された場合、その要素は表示されなくなる   使用例\n\u0026lt;p\u0026gt;下に画像３個、２個目をhiddenさせる\u0026lt;/p\u0026gt; \u0026lt;img src=\u0026quot;/css_sample_pages/img_small.jpg\u0026quot; style=\u0026quot;display:inline\u0026quot;\u0026gt; \u0026lt;img src=\u0026quot;/css_sample_pages/img_small.jpg\u0026quot; style=\u0026quot;display:inline; visibility:hidden\u0026quot;\u0026gt; \u0026lt;img src=\u0026quot;/css_sample_pages/img_small.jpg\u0026quot; style=\u0026quot;display:inline\u0026quot;\u0026gt; \u0026lt;br\u0026gt; \u0026lt;br\u0026gt; \u0026lt;p\u0026gt;表\u0026lt;/p\u0026gt; \u0026lt;table style=\u0026quot;border:none;\u0026quot;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:none;\u0026quot;\u0026gt;0,0\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:none; visibility:collapse\u0026quot;\u0026gt;1,0\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:none;\u0026quot;\u0026gt;2,0\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:none; visibility:collapse\u0026quot;\u0026gt;0,1\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:none;\u0026quot;\u0026gt;1,1\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:none; visibility:collapse\u0026quot;\u0026gt;2,1\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:none;\u0026quot;\u0026gt;0,2\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:none; visibility:collapse\u0026quot;\u0026gt;1,2\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:none;\u0026quot;\u0026gt;2,2\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt;  表示例\n 下に画像３個、２個目をhiddenさせる\n表\n 0,0 1,0 2,0   0,1 1,1 2,1   0,2 1,2 2,2   \noverflowプロパティ overflowプロパティは、要素内容がボックスに入りきらなくなった時に、はみ出た部分を表示するかしないかなどの設定をするプロパティである。\n指定する値と意味は以下の通り。\n 値 意味   visible ボックスからはみ出た部分も表示する   hidden ボックスからはみ出た部分は表示しない   scroll ボックスからはみ出た部分は表示しないが、スクロールによって表示できるようにする   auto 状況に応じてスクロール可能にする   使用例\n\u0026lt;p style=\u0026quot;background-color: #66ff99; height:100px; width:100px; overflow:visible\u0026quot;\u0026gt; あいうえおかきくけこさしすせそたちつてとなにぬねのはひふへほまみむめもやゆよらりるれろわをん \u0026lt;/p\u0026gt; \u0026lt;br\u0026gt; \u0026lt;br\u0026gt; \u0026lt;br\u0026gt; \u0026lt;p style=\u0026quot;background-color: #66ff99; height:100px; width:100px; overflow:hidden\u0026quot;\u0026gt; あいうえおかきくけこさしすせそたちつてとなにぬねのはひふへほまみむめもやゆよらりるれろわをん \u0026lt;/p\u0026gt; \u0026lt;br\u0026gt; \u0026lt;br\u0026gt; \u0026lt;br\u0026gt; \u0026lt;p style=\u0026quot;background-color: #66ff99; height:100px; width:100px; overflow:scroll\u0026quot;\u0026gt; あいうえおかきくけこさしすせそたちつてとなにぬねのはひふへほまみむめもやゆよらりるれろわをん \u0026lt;/p\u0026gt;  表示例\n あいうえおかきくけこさしすせそたちつてとなにぬねのはひふへほまみむめもやゆよらりるれろわをん あいうえおかきくけこさしすせそたちつてとなにぬねのはひふへほまみむめもやゆよらりるれろわをん あいうえおかきくけこさしすせそたちつてとなにぬねのはひふへほまみむめもやゆよらりるれろわをん \n"},{"idx":21,"href":"/docs/front-end/css_background/","title":"CSSでの背景","content":" CSSでの背景 CSSでの背景の設定方法についてを述べる。\nbackground-colorプロパティ background-colorプロパティは背景色を設定するプロパティである。\niframeを使い、使用例を示す。\n\u0026lt;iframe width=\u0026quot;200\u0026quot; height=\u0026quot;150\u0026quot; style=\u0026quot;background-color:red\u0026quot;\u0026gt; \u0026lt;/iframe\u0026gt;  表示例\n  \nbackground-imageプロパティ background-imageプロパティは、背景に画像を表示させるプロパティである。\n値には、url(画像のパス)の形で画像を指定し入力する。\nCSSで利用するには、body要素に適用させる。\n使用例として、下記のhtmlをiframeに組み込んで表示させてみる。\n\u0026lt;!DOCTYPE HTML\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;background-imageサンプル\u0026lt;/title\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; body { background-image: url(img_small.jpg); } h1 { color:greenyellow } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;background-imageのサンプル\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; iframe使用例\n\u0026lt;iframe width=\u0026quot;500\u0026quot; height=\u0026quot;400\u0026quot; src=\u0026quot;/css_sample_pages/background-image.html\u0026quot;\u0026gt; \u0026lt;/iframe\u0026gt;  表示例\n  \nbackground-clipプロパティ background-clipプロパティは、背景画像をボックスのどの領域に表示させるかを設定するプロパティである。\n設定できる値は以下の通り。\n border-box ・・ ボーダー以内の領域に表示させる   padding-box ・・ パディング以内の領域に表示させる   content-box ・・ 要素内容を表示させる領域に表示させる   使用例\n\u0026lt;!DOCTYPE HTML\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;background-clipサンプル\u0026lt;/title\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; p { width:300px; height:200px; padding:10px; border:dashed 3px black; color:white; background-image:url(img_small.jpg); background-clip:content-box; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;background-clipのサンプル\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; iframe使用例\n\u0026lt;iframe width=\u0026quot;400\u0026quot; height=\u0026quot;300\u0026quot; src=\u0026quot;/css_sample_pages/background-clip.html\u0026quot;\u0026gt; \u0026lt;/iframe\u0026gt;  表示例\n  \nbackground-repeatプロパティ background-repeatプロパティは、背景画像を繰り返して表示させるか、及びその表示のさせ方を設定するプロパティである。\n設定する値は以下の通り。デフォルトではrepeatである。\n repeat-x ・・ 横方向に画像を連続して表示させる   repeat-y ・・ 縦方向に画像を連続して表示させる   repeat ・・ 画像を全体に連続して表示させる   no-repeat ・・ 画像を１つだけ表示させる   使用例\n\u0026lt;!DOCTYPE HTML\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;background-repeatサンプル\u0026lt;/title\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; body { background-image: url(img_small.jpg); background-repeat: repeat-x; } h1 { color:greenyellow } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;background-repeatのサンプル\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; iframe使用例\n\u0026lt;iframe width=\u0026quot;500\u0026quot; height=\u0026quot;400\u0026quot; src=\u0026quot;/css_sample_pages/background-repeat.html\u0026quot;\u0026gt; \u0026lt;/iframe\u0026gt;  表示例\n  \nbackground-sizeプロパティ background-sizeプロパティは、背景画像を表示するサイズを設定するプロパティである。\n値は以下のキーワードか、幅・高さを示す数値２つを指定する。（数値を１つ指定した場合は幅として認識される。）デフォルトはautoである。\n contain ・・ 画像の縦横比を保った状態で、画像全体が表示される最大サイズにする   cover ・・ 画像の縦横比を保った状態で、画像全体が表示される最小サイズにする   auto ・・ 画像の縦横比を保った状態   (数値)% ・・ 背景の表示領域に対するパーセンテージ分のサイズにする   使用例\n\u0026lt;!DOCTYPE HTML\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;background-sizeサンプル\u0026lt;/title\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; body { background-image: url(img_small.jpg); background-size: cover; } h1 { color:greenyellow } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;background-sizeのサンプル\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; iframe使用例\n\u0026lt;iframe width=\u0026quot;500\u0026quot; height=\u0026quot;400\u0026quot; src=\u0026quot;/css_sample_pages/background-size.html\u0026quot;\u0026gt; \u0026lt;/iframe\u0026gt;  表示例\n  \nbackground-originプロパティ background-originプロパティは、ボックスにおいて画像を表示させる基準となる位置を設定する要素である。\n設定する値は以下の通り。\n border-box ・・ ボーダー領域の左上を基準とする   padding-box ・・ パディング領域の左上を基準とする   content-box ・・ 要素内容を表示させる領域の左上を基準とする   使用例\n\u0026lt;!DOCTYPE HTML\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;background-originサンプル\u0026lt;/title\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; p { width:300px; height:200px; padding:10px; border:dashed 3px black; color:white; background-image:url(img_small.jpg); background-origin:content-box; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;background-originのサンプル\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; iframe使用例\n\u0026lt;iframe width=\u0026quot;400\u0026quot; height=\u0026quot;300\u0026quot; src=\u0026quot;/css_sample_pages/background-origin.html\u0026quot;\u0026gt; \u0026lt;/iframe\u0026gt;  表示例\n  \nbackground-positionプロパティ background-positionプロパティは、背景に画像を表示させる位置を設定するプロパティである。画像が繰り返し表示される場合には、まずその位置に画像が表示され、そこから繰り返し表示される。\n設定する値は縦方向と横方向の２つで、以下の通り。\n top ・・ 一番上(縦方向の0%)   bottom ・・ 一番下(縦方向の100%)   left ・・ 一番左(横方向の0%)   right ・・ 一番右(横方向の100%)   center ・・ 中央(縦・横方向の50%)   (パーセンテージ) ・・ それぞれの方向に対するパーセンテージ。数値の後に%をつける   使用例\n\u0026lt;!DOCTYPE HTML\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;background-positionサンプル\u0026lt;/title\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; body { background-image: url(img_small.jpg); background-repeat: no-repeat; background-position: 100% 100%; } h1 { color:black } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;↑0%↑\u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt;background-positionのサンプル\u0026lt;/h1\u0026gt; \u0026lt;br\u0026gt; \u0026lt;br\u0026gt; \u0026lt;br\u0026gt; \u0026lt;br\u0026gt; \u0026lt;h1\u0026gt;background-positionのサンプル\u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt;↓100%↓\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; iframe使用例\n\u0026lt;iframe width=\u0026quot;500\u0026quot; height=\u0026quot;400\u0026quot; src=\u0026quot;/css_sample_pages/background-position.html\u0026quot;\u0026gt; \u0026lt;/iframe\u0026gt;  表示例\n  \nbackground-attachment プロパティ background-attachmentプロパティは、ページをスクロールしたときに背景画像も一緒にスクロールさせるか否かを設定する。\n設定する値は以下の通り。\n scroll ・・ 背景画像も一緒にスクロールする   fixed ・・ スクロールしても背景画像を動かさない   使用例\n\u0026lt;!DOCTYPE HTML\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;background-attachmentサンプル\u0026lt;/title\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; body { background-image: url(img_small.jpg); background-attachment: fixed; } h1 { color:greenyellow } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;background-attachmentのサンプル\u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt;1\u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt;2\u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt;3\u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt;4\u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt;5\u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt;6\u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt;7\u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt;8\u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt;9\u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt;10\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; iframe使用例\n\u0026lt;iframe width=\u0026quot;500\u0026quot; height=\u0026quot;200\u0026quot; src=\u0026quot;/css_sample_pages/background-attachment.html\u0026quot; scrolling=\u0026quot;yes\u0026quot;\u0026gt; \u0026lt;/iframe\u0026gt;  表示例\n  \nbackgroundプロパティ backgroundプロパティは、これまでに出てきた背景関連のプロパティの値をまとめて指定できるプロパティである。\n一部例外はあるが、値をスペースで区切れば複数指定できる。\n使用例\n\u0026lt;!DOCTYPE HTML\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;backgroundサンプル\u0026lt;/title\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; body { background: gray url(img_small.jpg) no-repeat fixed 100% 100%; } h1 { color:greenyellow } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;↑0%↑\u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt;backgroundのサンプル\u0026lt;/h1\u0026gt; \u0026lt;br\u0026gt; \u0026lt;br\u0026gt; \u0026lt;br\u0026gt; \u0026lt;br\u0026gt; \u0026lt;br\u0026gt; \u0026lt;br\u0026gt; \u0026lt;h1\u0026gt;backgroundのサンプル\u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt;↓100%↓\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; iframe使用例\n\u0026lt;iframe width=\u0026quot;500\u0026quot; height=\u0026quot;400\u0026quot; src=\u0026quot;/css_sample_pages/background.html\u0026quot;\u0026gt; \u0026lt;/iframe\u0026gt;  表示例\n  \n"},{"idx":22,"href":"/docs/front-end/css_color/","title":"CSSでの色","content":" CSSでの色の表現 CSSでの色の表現について述べる。\n16進数の値 方法の一つとして、#(シャープ)と16進数6桁の値で色を表現する方法がある。\n6桁の内、上2桁をR(赤),中2桁をG(緑),下2桁をB(青)として、それぞれ0x00~0xff(255)の値で表現する。\n例えば、RGB値が10進数で0,0,255の場合は、\n#0000ff  と示すことができる。\n色を示すキーワード 16進数による数値でなくとも、基本的な色を使いたい場合はその色を示すキーワードを指定することで、その色を使用できる。\nキーワードの例は以下のとおり。\n  キーワード 色 16進数の値   white  #ffffff   black  #000000   gray  #808080   red  #ff0000   green  #00ff00   blue  #0000ff   yellow  #ffff00   fuchsia  #ff00ff   aqua  #00ffff   rgb(),rgba() による指定 rgb(),rgba()という関数形式の書式を利用すると、RGBの値を10進数のまま指定できる。\nrgb()は、r、g、bの値(範囲は0~255)をそれぞれ引数として入力して利用する。\nrgba()は、rgb（）に加え不透明度を表すalphaの値(範囲は0.0~1.0)も引数として指定できるようにした関数である。\n使用例\n\u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;background-color:rgb(255,0,0)\u0026quot;\u0026gt;　\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;background-color:rgba(255,0,0,0.5)\u0026quot;\u0026gt;　\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt;  表示例\n         \nhsl(),hsla()による指定 rgb()と違い、hue(色相),saturation(彩度),lightness(明度)の組み合わせで色を表現するhsl()でも色を指定できる。\nh(色相)は0~359,s(彩度),l(明度)は0%~100%の範囲で値を指定する。\nこれに加え、不透明度を表すalphaの値(範囲は0.0~1.0)も引数として指定できるようにしたものがhsla()である。\n使用例\n\u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;background-color:hsl(180,50%,50%)\u0026quot;\u0026gt;　\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;background-color:hsla(180,50%,50%,0.5)\u0026quot;\u0026gt;　\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt;  表示例\n         \nCSSでの色の設定 ここで設定した色のHTML文書への適用方法を述べる。\ncolorプロパティ colorプロパティは、要素内容の文字色を設定するプロパティである。全ての要素で利用可能である。\n使用例\n\u0026lt;p style=\u0026quot;color:red\u0026quot; \u0026gt;ここは赤です。\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026quot;color:green\u0026quot;\u0026gt;ここは緑です。\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026quot;color:blue\u0026quot; \u0026gt;ここは青です。\u0026lt;/p\u0026gt;  表示例\n ここは赤です。\nここは緑です。\nここは青です。\n\nopacityプロパティ opacityプロパティは、要素内容の文字の不透明度を設定するプロパティである。\n設定する値は、0.0 (透明) から1.0 (不透明) である。\n使用例\n\u0026lt;p style=\u0026quot;opacity:0.2\u0026quot; \u0026gt;不透明度20%です。\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026quot;opacity:0.4\u0026quot; \u0026gt;不透明度40%です。\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026quot;opacity:0.6\u0026quot; \u0026gt;不透明度60%です。\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026quot;opacity:0.8\u0026quot; \u0026gt;不透明度80%です。\u0026lt;/p\u0026gt;  表示例\n 不透明度20%です。\n不透明度40%です。\n不透明度60%です。\n不透明度80%です。\n\n"},{"idx":23,"href":"/docs/front-end/css_about/","title":"CSSとは","content":" CSSとは CSSの基本事項についてを述べる。\nCSSは、HTMLに組み込む形で使用する言語で、HTMLで作成した文書に対しCSSでどの部分をどのように装飾するかを指定する形で利用する。\n利用方についてを以下で述べる。\nCSSの書式 CSSの記法としては、大きく分けてHTML文書のどこに適用するかを示すセレクタと、具体的にどのような装飾を行うかを示す宣言ブロックからなる。\n宣言ブロックの中には、各宣言をセミコロン(;)区切りで書き、宣言はプロパティ名とプロパティ値をコロン(:)区切りで記入する。\n表記例は以下の通り。\np { color: white; background: red; }  この例のうち、最初の「p」がセレクタになり、その後の中括弧{}部分が宣言ブロックである。\nHTML文書への組み込み方 CSSをHTML文書に組み込む方法はいくつかある。\nlink要素を使う方法 一つ目は、link要素を用いてCSSを組み込む方法である。\nlink要素は前述の通り、HTML文書に関連する外部ファイルやリソースを示すための要素である。\n外部スタイルシート(スタイルシートだけを書き込んだファイル)を組み込む際にも、このlink要素が利用できる。\nlink要素のrel属性ではstylesheet、href属性ではそのスタイルシートのアドレスを指定する。\n例\n・・・ \u0026lt;head\u0026gt; ・・・ \u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;style.css\u0026quot;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; ・・・ \u0026lt;/body\u0026gt; ・・・  style要素を使う方法 style要素は、要素内容にスタイルシート言語を記載する事で、そのスタイルシートの内容をHTML文書に組み込むことのできる要素である。\nstyle要素は、head要素の中に記載する。\n例\n・・・ \u0026lt;head\u0026gt; ・・・ \u0026lt;style\u0026gt; p { color: white; background: red; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; ・・・ \u0026lt;/body\u0026gt; ・・・  style属性を使う方法 HTML文書でCSSを組み込みたい要素の中に、グローバル属性のstyle属性を指定して値に具体的なCSSのコード(宣言のみ)を入れてやると、その要素にCSSが適用される。\n使用例\n\u0026lt;p style=\u0026quot;color: white; background: black\u0026quot;\u0026gt; style属性を使ってp要素にCSSを適用してみました。 \u0026lt;/p\u0026gt;  表示例\n style属性を使ってp要素にCSSを適用してみました。 \nボックス HTMLの各要素はボックスと呼ばれる四角い領域に表示される。ボックスにはさらに、境界線であるボーダー、ボーダーと実際の要素内容を表示する領域との余白であるパディング、ボーダーの外側の余白であるマージンと呼ばれる部位に分けられる。それらを図で示したものを以下に示す。\nCSSでは、これらの部位を自由に設定することが可能である。\n長さ・大きさの単位 CSSでは大きさや長さを指定することがあり、その際にそれぞれ単位を用いて表す。\nCSSで利用する主な単位は、以下の通りである。\n フォントに対する相対的な長さを表す単位   ・ em ・・・　 要素のフォントサイズを1とした単位   ・ rem ・・・　 ルート要素のフォントサイズを1とした単位   ・ ch ・・・　 「0」の幅を1とした単位    絶対的な長さを表す単位   ・ px ・・・　 ピクセル   ・ pt ・・・　 ポイント   ・ in ・・・　 インチ   ・ cm ・・・　 センチメートル   ・ mm ・・・　 ミリメートル   "},{"idx":24,"href":"/docs/front-end/css_priority/","title":"CSS適用の優先順位","content":" CSS適用の優先順位 指定元による優先順位 CSSはWebページの製作者だけが指定できるものではなく、閲覧しているユーザも独自に指定でき、また使用しているブラウザもブラウザが有するCSS(及びそれに近い物)を適用した上で表示している。\nこのうち、どのCSSを優先して適用すべきなのか？\nCSSが複数指定されていた場合は、指定元により適用の優先順位というものが指定されている。\nその優先順位は\n 製作者のCSS  ユーザーのCSS  ブラウザのCSS  のようになっている。\n!important 例えばユーザーが指定したCSSやブラウザ内のCSSの指定した宣言を優先して適用させたい場合はどのようにすれば良いか。\nその際に使用するのが!important文である。\n!important文が最後に付いた宣言は、製作者のCSSよりも優先して適用される。\nしかし、!importantが付けられていても、指定元によって優先順位がある。指定元及び!importantの有無による優先度は以下のとおり。\n 優先度 高 ↑ | ブラウザ !important付き | ユーザー !important付き | 製作者 !important付き | 製作者 | ユーザー | ブラウザ ↓ 優先度 低  詳細度による優先順位 セレクタにはその種類によって、詳細度という３桁の数値が割り振られている。\n!important文が無く、指定元が同じ場合は、この詳細度によって優先度が決まってくる。\n詳細度の数値は以下の法則によって決められる。\n ３桁目：IDセレクタの個数 ２桁目：クラスセレクタの個数 + 属性セレクタの個数 + 擬似クラスの個数 １桁目：タイプセレクタの個数 + 擬似要素の個数  例として、以下のようなセレクタのときの詳細度を記載する。\n span div#top ・・ 102   div#top ・・ 101   #top ・・ 100   span.address ・・ 011   .address ・・ 010   span div ・・ 002   div ・・ 001   * ・・ 000   ちなみに例にもあるが、ユニバーサルセレクタは詳細度なし(0)となる。\n"},{"idx":25,"href":"/docs/programming/control/for/","title":"for文","content":" for文 繰り返し処理を行う制御構文の一つ、for文について各言語での利用法を示す。\nJava  Javaでの記法は以下の通り。\nfor(初期化式;条件式;変化式){ //処理 }  上記におけるフローは以下の通り。\n 初期化式を実行する。 条件式を実行しtrueなら3,falseなら6へ行く。 for文の中身の処理が実行される。 変化式が実行される。 2.に戻る 終了する  for文の中の初期化式、条件式、変化式はコロン(;)で区切る必要がある。区切られてない場合などはコンパイルエラーが発生する。 また、初期化式、変化式は無くても良い。\n実行例を以下に示す。\nclass Main{ public static void main(String args[]){ for(int i=0;i\u0026lt;5;i++){ System.out.println(i); } int j=0; for(;j\u0026lt;5;){ System.out.println(j); j++; } } } 実行結果\n\u0026gt; java Main 0 1 2 3 4 0 1 2 3 4   Python  Pythonにもfor文はあるが、Javaの時とは違い初期値や条件は設定しない。\nPythonでは、リストなどのシーケンス型の値を用いてループ処理を実装する。記法は以下の通り。\nfor 変数 in シーケンス値\n上記のように書くことで、シーケンス値に入っている値が1回のループで頭から順番に1個ずつ取り出され、それを元にfor文の処理が実行される。Javaの拡張for文と似たようなものである。\n\u0026gt;\u0026gt;\u0026gt; #0..5のシーケンス型データ作成 \u0026gt;\u0026gt;\u0026gt; range(5) range(0, 5) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; for i in range(5): ... print(i) ... 0 1 2 3 4 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #リストで0..5のデータ作成 \u0026gt;\u0026gt;\u0026gt; l = list(range(5)) \u0026gt;\u0026gt;\u0026gt; l [0, 1, 2, 3, 4] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; for i in l: ... print(i) ... 0 1 2 3 4 \u0026gt;\u0026gt;\u0026gt;   Javascript  Javascriptでのfor文も、Javaと記法・フロー共に同じである。\n記法\nfor(初期化式;条件式;変化式){ //処理 }    "},{"idx":26,"href":"/docs/front-end/html_structure/","title":"HTMLの全体構造","content":" HTMLの全体構造 HTMLファイルの構造についてを述べる。\nHTMLファイルは主に以下から構成される。\n DOCTYPE宣言（文書型宣言） html要素  head要素 body要素   大まかな記載は以下の通り。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;!-- 文書に関する情報 --\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 表示させるコンテンツの情報 --\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   DOCTYPE宣言 HTML5では実は必要なものではないそうだが、ブラウザの表示モードを「標準モード」にする目的で指定することになっている。\n指定がない場合、通常は以下の通りに記入する。\n\u0026lt;!DOCTYPE HTML\u0026gt;  なお、DOCTYPE宣言は大文字で書いても小文字で書いても問題ない。\nhtml要素 html要素は、HTML文書のルートとなる要素である。\n他の全ての要素は、この要素内に記述しなければならない。\nまた、グローバル属性であるlang属性を指定して、その文書で使用されている言語の種類を示すことが推奨されている。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;ja\u0026gt; ・・・ \u0026lt;/html\u0026gt;   head要素 head要素は、HTML文書のメタデータを入れるための要素である。\n大体は文書のタイトル(title要素)、また文書の文字コード(meta要素)をここで指定する。\ntitle要素 title要素は、HTML文書のタイトル(名前)を示す要素である。この要素は、必ずhead要素の中で指定する。\n・・・ \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;XXXのページ\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; ・・・   meta要素 meta要素は、HTML文書の様々なメタデータを指定できる空要素である。\n属性が色々あり、以下の通りである。\n   属性 指定する値     charset 文書の文字コード   name メタデータの名前   http-equiv プラグマディレクティブ(再読み込みや他文書への遷移など、文書の状態や挙動を指示する命令のこと)   content メタ情報の値    使用例\n・・・ \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;meta name=\u0026quot;author\u0026quot; content=\u0026quot;T.Wakasugi\u0026quot;\u0026gt; \u0026lt;meta name=\u0026quot;keywords\u0026quot; content=\u0026quot;HTML programming meta\u0026quot;\u0026gt; \u0026lt;/head\u0026gt; ・・・   link要素 link要素は、このHTML文書に関連する外部ファイルやリソースを示すための要素である。\nここでいう関連するファイルやリソースというのは、HTML,CSS,RSSファイルなどのことを言う。\nlink要素にはhref属性とrel属性は必ず指定する必要がある。\n   属性 指定する値     href 外部ファイルやリソースのアドレス   rel 当文書から見た外部ファイルやリソースの関係性を示すキーワード   rev 外部ファイルから見た当文書の関係性を示すキーワード   hrefflag 外部ファイルの言語(日本語や英語など)    rel・rev属性に指定できる値としては以下の通り（一部）。\n   指定する値 意味     author 執筆者   help ヘルプ   icon アイコン   license 著作権ライセンス   prev 前の文書   next 次の文書   stylesheet 適用するスタイルシート     base要素 base要素は、そのHTML文書で使われている相対URL(パス)の基準となるURLを書く要素である。\n基準となるURLはhref属性に指定する。\n例\n・・・ \u0026lt;head\u0026gt; \u0026lt;base href=\u0026quot;https://wat36.github.io/pages/\u0026quot;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;docs/front-end/front_index/\u0026quot;\u0026gt;フロントエンドのトップ\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; ・・・  body要素 body要素は、HTML文書のコンテンツを入れるための要素である。通常は、head要素の次に記載する。\n例\n\u0026lt;body\u0026gt; ・・・ \u0026lt;/body\u0026gt;  "},{"idx":27,"href":"/docs/front-end/http/","title":"HTTP・HTTPS","content":" HTTP・HTTPS HTTP、HTTPSプロトコルについてを述べる。\nHTTPプロトコル HTTP(Hyper Text Transfer Protocol)とは、WebサーバとクライアントのWebブラウザ間でHTML文書などのテキストメッセージを受け渡すためのプロトコルである。\nHTTPの通信は、クライアントからサーバへのHTTPリクエストと、サーバからクライアントへのHTTPレスポンスの2つに分けられる。\nHTTPSプロトコル HTTPSプロトコルは、大まかにいうとセキュリティを確保した通信路上でHTTP通信を行うプロトコルである。\nHTTP通信を行う前に、セキュリティの確保として、データを暗号化して送受信するプロトコルであるSSLプロトコル(またはTLSプロトコル)を利用しセッションを確定する。その後に、HTTPセッションの接続を行う。\nHTTPのメッセージ構造 HTTPのメッセージは大きく開始行、ヘッダフィールド、CRLFの改行、メッセージボディの4つに分けられる。\n 開始行 (リクエストライン/ステータスライン) ヘッダフィールド(０行以上、以下から構成)  General-header Request-header Response-header Entity-header  改行(CRLF) メッセージボディ  HTTPの開始行(リクエストメッセージ) HTTPメッセージの一番最初に書く開始行は以下のような構造になる。\nメソッド /任意のパス(+クエリストリング) HTTP/1.1  クエリストリングとはリクエストと同時に送るデータのことで、任意のパスの後に\u0026rdquo;?\u0026ldquo;を書き、その後にデータを記入する。\nまた、メソッドとは以下のいずれかである。\n  メソッド名 説明   GET 指定したURL(URI)で識別されるリソースを取得   POST 指定したURL(URI)で識別されるリソースの子リソースの作成、またはリソースへのデータの追加などを要求   PUT 指定したURL(URI)に対してエンティティ(メッセージボディ)に含まれる情報を保存することを要求   HEAD GETと同じだがヘッダのみを取得   OPTIONS 指定したURL(URI)がサポートしているメソッドを取得   DELETE 指定したURL(URI)で識別されるリソースの削除を要求   TRACE 自分宛にリクエストメッセージを要求するループバック試験に使用   このうちよく使われるのはGETとPOSTである。\nHTTPのレスポンスメッセージ HTTPのレスポンスメッセージの例は以下の通り。上から開始行、ヘッダフィールド、改行、メッセージボディの順。\nHTTP/1.1 200 OK  Date:Wed, 19 Aug 2020 23:48:50 GMT Server:Apache Content-type:text/html  (改行)  \u0026lt;!DOCTYPE html\u0026gt; ・・・ ・・・  ここで、レスポンスメッセージの開始行には、レスポンスの状態を示す3桁の数字「ステータスコード」が含まれている。\nステータスコードは以下のように分類される。\n  ステータスコード 説明   1xx Informational(情報提供のコード)   2xx Success(成功)   3xx Redirection(転送)   4xx Client Error(クライアントエラー)   5xx Server Error(サーバーエラー)   HTTPのヘッダフィールド ヘッダフィールドには、メッセージの外部情報（メタ情報）を扱うためのHTTPヘッダが含まれる。\nHTTPヘッダとして代表的なものを示す。\n  ヘッダ名 説明   Accept 受入可能なメディア型   Authorization HTTPの認証情報   Cache-Control キャッシュの振る舞い   Content-Language エンティティの自然言語   Content-Length メッセージボディの長さ   Content-Type メッセージボディの型   Cookie ブラウザに保存されたクッキーの値   Expires レスポンスの有効期間   If-Modified-Since 指定時刻以降に更新されているかを確認（条件付きGETで使用）   Last-Modified リソースの最終更新時刻   Referer リンクされている元のリソースのURL(URI)   Set-Cookie Webサーバが生成したクッキーの値   User-Agent ユーザーエージェントの名前   HTTPでの認証 HTTPでは、特定のファイルへのアクセスを制限するために認証することが可能である。\nその種類は主に以下の２種類。\nBasic認証 Basic認証は、ユーザー名とパスワードをコロンで接続し、Base64でエンコードして送信することで認証を実施する方式である。\n盗聴や改竄が容易にできてしまう。\nDigest認証 Digest認証は、Basic認証に加えて、盗聴や改竄を防ぐためにユーザー名とパスワードをMDSでハッシュ化して送信し、認証を実施する。\nパスワードが暗号化されているので、盗聴できても解読しにくいという利点がある。\nHTTP cookie (クッキー) HTTPは、システムの現在の状態を保持しない(ステートレスという)プロトコルであ利、クライアントとサーバ間の状態管理は行えないという点がある。\nそこで、Webブラウザにcookie(クッキー)と呼ばれるデータを保持しておくことで、HTTPでの状態管理を実現することができる。\n代表的な使用例としては、Webサイト上でのログイン状態の記録、ECサイト上でのカート情報の管理などがある。\nクッキーは、サーバからクライアントに返るときのHTTPレスポンスのヘッダSet-Cookieにて指定される。\nこれにより、Webサーバ上で指定された情報がWebブラウザに保存される。\nその後のWebページへのアクセス時には、保存していたクッキーをHTTPリクエストと同時にWebサーバに送ることで、状態管理を行う。\nまた、クッキーはJavaScriptを利用して、クライアント側で操作することもできる。\n"},{"idx":28,"href":"/docs/programming/control/ifelse/","title":"if-else文","content":" if-else文 指定した条件に応じて処理を分岐させる時に使うのがif-else文である。\nこれはほぼ全てのプログラミング言語に実装されている。言語ごとの記法を示す。\nJava  Javaでの記法は以下の通り。\nif(条件1){ //条件1がtrueならこの処理実行 }else if(条件2){ //条件1がfalse、条件2がtrueならこの処理実行 }else{ //条件1,2ともfalseならこの処理実行 }  if,else if後の()内にはboolean値またはbooleanを返すような式にする。\nelse ifは限りなく設けることができる。\n実行例\nclass Main{ public static void main(String args[]){ String s = args[0]; if(s.equals(\u0026#34;0\u0026#34;)){ System.out.println(\u0026#34;ゼロ\u0026#34;); }else if(s.equals(\u0026#34;1\u0026#34;)){ System.out.println(\u0026#34;ひとつ\u0026#34;); }else{ System.out.println(\u0026#34;それ以外\u0026#34;); } } } 実行結果\n$ java Main 0 ゼロ $ java Main 1 ひとつ $ java Main 2 それ以外   Python  Pythonでの記法は以下の通り。\nif 条件1: #条件1がTrueならこの処理実行 elif 条件2: #条件1がFalse、条件2がTrueならこの処理実行 else: #条件1,2ともfalseならこの処理実行  条件にはbool値またはそれを返す式にする。\nまた、if,elif,elseの後にはコロン\u0026rdquo;:\u0026ldquo;をつける。\nelifは限りなく設定できる。\n実行例\n\u0026gt;\u0026gt;\u0026gt; x = 0 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; if x \u0026lt; 0: ... print(\u0026#34;マイナス\u0026#34;) ... elif x == 0: ... print(\u0026#34;ゼロ\u0026#34;) ... else: ... print(\u0026#34;プラス\u0026#34;) ... ゼロ \u0026gt;\u0026gt;\u0026gt;   Javascript  Javascriptでの記法は以下のとおり。\nif (条件式1) { //条件式1がtrueならこの処理実行 }else if(条件式2){ //条件式2がtrueならこの処理実行 }else{ //条件式1,2がfalseならこの処理実行 }  なお、Javascriptでは、条件式のところに数値または文字列及びその値が入った変数を設定することもできる。\n数値を設定した場合は、値が0の場合falseとみなし、それ以外の値は全てtrueとみなされる。\n文字列の場合は、空文字(\u0026ldquo;)の場合falseとみなされ、それ以外の値の場合は全てtrueとみなされる。\n  "},{"idx":29,"href":"/docs/programming/machine_learning/k-means/","title":"K-Means法","content":" K-Means法 クラスタリングの手法の一つ、K-means法についてを述べる。\n先ほども示した以下のデータを例にとって、大まかな手順を、以下に記載しながら進める。\n1. クラスタの数を定める K-means法では、まずデータを分けるクラスタの数を定める。\n例として、ここでは分けるクラスタを３つと設定しよう。\n2. 各クラスタの中心位置を定める 次に、それぞれのクラスタの中心位置を示す座標(ベクトル)を定める。\n中心位置を示すベクトルをμとし、1.で定めた数だけ用意する。\nk番目のクラスタの中心ベクトルは以下のように表す。\n  $$ \\tag{1} {\\bf \\mu}_{k} = \\left[ \\begin{array}{cc} \\mu_{k0} \u0026 \\mu_{k1} \\end{array} \\right] $$ ここでは入力データの次元が２次元なので、μkも２次元ベクトルとなる。\nまた、クラスタは３つと定めたので、k=0,1,2となる。\n例として、μを以下のように定めてみよう。\nμ0 = [38,6],μ1 = [40,6],μ2 = [42,6]\n3. 入力データが属するクラスタ(ベクトル)の用意 次に、各入力データが属するクラスタを示すベクトルRを用意する。\n$$ \\tag{2} {\\bf R} = \\left[ \\begin{array}{c} {\\bf r}_{0} \\\\ {\\bf r}_{1} \\\\ \\vdots \\\\ {\\bf r}_{N-1} \\\\ \\end{array} \\right] $$ また、\n$$ \\tag{3} {\\bf r}_{k} = \\left[ \\begin{array}{cc} r_{k0} \u0026 r_{k1} \u0026 r_{k2} \\end{array} \\right] $$ とする。rkの要素数はクラスタの数に一致する。今回はクラスタは３つなので、rkはrk2まで用意する。\nまた、rkiは、k番目の入力データがクラスタiに属する場合に1,そうでない場合0をとる変数とする。\n$$ \\tag{4} r_{nk} = \\begin{cases} 1 \u0026 (入力データkがクラスタiに属する場合) \\\\ 0 \u0026 (入力データkがクラスタiに属さない場合) \\end{cases} $$ これらにより、Rは以下のように表される。\n$$ \\tag{5} {\\bf R} = \\left[ \\begin{array}{ccc} r_{00} \u0026 r_{01} \u0026 r_{02} \\\\ r_{10} \u0026 r_{11} \u0026 r_{12} \\\\ \\vdots \u0026 \\vdots \u0026 \\vdots \\\\ r_{n-1,0} \u0026 r_{n-1,1} \u0026 r_{n-1,2} \\\\ \\end{array} \\right] $$ 最初は、全ての入力データがクラスタ0に属する(rk0=1)として初期化する。\n以上により、クラスタの中心位置を示すベクトルμ、入力データが属するクラスタの行列Rの準備が完了した。\nここから、行列Rを計算していくことにより各入力データが属するクラスタを決定していく。\n4. 入力データが属するクラスタを導出する 各入力データが属するクラスタはどのように計算し決定すれば良いのか？\n方法としては、\n各入力データを、最も中心位置が近いクラスターに属させる\nとする。\nそこで、各入力データに対し、各クラスターの中心との距離を計算し、一番距離が近いクラスターに属させる、という事を全データに対して行う。\nこれにより、行列Rの値を定めていく。\n5. クラスタの中心位置を調整する 次に、クラスタの中心位置μを、先ほど決定した入力データの値に基づき、更新していく。\n方法としては、\nクラスタの中心位置を、そのクラスタに属している入力データの平均値にする\nとする。\ni番目の入力データをxi = [xi,0,xi,1]とおくと、計算式としては以下の通りになる。\n$$ \\tag{6} \\begin{aligned} \\mu_{k,0} = \\frac{1}{N_{k}} \\sum_{x_{i} \\in クラスタk}^{} x_{i0} \\\\ \\mu_{k,1} = \\frac{1}{N_{k}} \\sum_{x_{i} \\in クラスタk}^{} x_{i1} \\\\ \\end{aligned} $$ ここで、Nkはクラスタkに属する入力データの個数とする。\n6. 手順4・5を繰り返し行う 手順4,5を繰り返し行い、手順4により属するクラスタが変わる入力データが一つも無くなったときに終了する。\n以上の手順により、K-means法によるクラスタリングが行える。\nでは、コードを実装して実際にクラスタリングを行ってみよう。\nクラスタリングを行うコードを以下に示す。(k_means.py)\nimport numpy as np k=-1 x=[] mu=[] R=[] #R計算 def calc_r(X,Mu): #初期化　入力データx、μとR用意 x=np.array(X) mu=np.array(Mu) k=len(mu) R=np.zeros((len(x),k)) for i in range(len(x)): ri=np.zeros(k) ri[0]=1 R[i]=ri flag=True count=1 while(flag): flag=False #Rを計算し更新 for i in range(len(x)): d=[(x[i][0]-mu[j][0])**2 + (x[i][1]-mu[j][1])**2 for j in range(k)] ri=np.zeros(k) ri[d.index(min(d))]=1 if(not np.allclose(R[i],ri)): flag=True R[i]=ri #μを調整 for i in range(k): x_i=x[R[:,i]==1] mu_ix=np.mean(x_i[:,0]) mu_iy=np.mean(x_i[:,1]) mu[i]=np.array([mu_ix,mu_iy]) count+=1 return mu,R これを使いプロットを行うコードを示す。(do_k_means.py)\nfrom k_means import calc_r import matplotlib.pyplot as plt import numpy as np #入力値 x = np.load(\u0026#39;x.npy\u0026#39;) #クラスタの中心位置 mu=np.array([[38,6],[40,6],[42,6]]) #クラスタ計算 mu,r = calc_r(x,mu) #プロット color=[\u0026#39;red\u0026#39;,\u0026#39;blue\u0026#39;,\u0026#39;green\u0026#39;] #各入力データをクラスタリング結果(色分け)とともに表示 for i in range(len(mu)): plt.plot(x[r[:,i]==1,0],x[r[:,i]==1,1],linestyle=\u0026#39;none\u0026#39;,markeredgecolor=\u0026#39;black\u0026#39;,marker=\u0026#39;o\u0026#39;,color=color[i]) #各クラスタの中心位置を表示(★型) for i in range(len(mu)): plt.plot(mu[i,0],mu[i,1],linestyle=\u0026#39;none\u0026#39;,markeredgecolor=\u0026#39;black\u0026#39;,marker=\u0026#39;*\u0026#39;,color=color[i]) plt.xlim([min(x[:,0])-1,max(x[:,0])+1]) plt.ylim([min(x[:,1])-1,max(x[:,1])+1]) plt.xlabel(\u0026#39;temperature[℃]\u0026#39;) plt.ylabel(\u0026#39;pH\u0026#39;) plt.grid(True) plt.show() 実行結果\nこれにより、k-means法によるクラスタリングが行えた。\n"},{"idx":30,"href":"/docs/programming/machine_learning/keras/","title":"Kerasでニューラルネットワーク","content":" Kerasでニューラルネットワーク 前章ではニューラルネットワークを一から実装してきたが、今ではニューラルネットワークに関連するライブラリがあり、それを利用するとニューラルネットワークが短いコードで実行できるようになる。\nライブラリの例としては、Googleが開発したTensorflowやKerasなどが有名である。\nここでは、例としてKerasを使ってニューラルネットワークを実行してみよう。\nと言ってもここに書くと長くなるので、とりあえずコードと説明をまとめたNotebookをこちらに記載しておくのでご参照を。\n(もうちょっと何か書きたい・・)\n"},{"idx":31,"href":"/docs/programming/math/save/","title":"ndarray型のデータをファイルに保存する","content":" ndarray型のデータをファイルに保存する ndarray型変数をファイルに保存する方法についてを示す。\nPython  ndarray型変数をファイルに保存するにはnumpyの関数save(\u0026lsquo;ファイル名.npy\u0026rsquo;,変数名)を利用する。引数には保存するファイル名(拡張子は.npy)と保存する変数名を入力する。\n複数の変数を保存したい時はnumpyの関数savez(\u0026lsquo;ファイル名.npz\u0026rsquo;,変数名1=変数名1,変数名2=変数名2,,,)を使用する。\nまた、保存した.npyファイルを読み出すにはnumpyの関数load(\u0026lsquo;ファイル名.npy\u0026rsquo;)を利用する。\n実行例\n\u0026gt;\u0026gt;\u0026gt; import numpy as np \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; data = np.random.randn(5) \u0026gt;\u0026gt;\u0026gt; data array([ 0.05027787, 0.59668757, 0.93566661, 1.57869082, -0.60440496]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; np.save(\u0026#39;data.npy\u0026#39;,data) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; data1 = np.random.randn(4) \u0026gt;\u0026gt;\u0026gt; data2 = np.random.randn(4) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; data1 array([ 1.2854548 , 0.04609777, 0.4210424 , -1.03562392]) \u0026gt;\u0026gt;\u0026gt; data2 array([ 0.50145572, -0.76596583, -0.66480387, 0.78022058]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; np.savez(\u0026#39;datum.npz\u0026#39;,data1=data1,data2=data2) \u0026gt;\u0026gt;\u0026gt;  ファイル確認\n$ ls -t | head -n1 data.npy $ cat data.npy �NUMPYv{\u0026#39;descr\u0026#39;: \u0026#39;\u0026lt;f8\u0026#39;, \u0026#39;fortran_order\u0026#39;: False, \u0026#39;shape\u0026#39;: (5,), } (Pz��?pD:��?������?�yNQB�?=6IW� npyファイルは作成されているが、catで実行しても中身は見れない。\n次に、保存したnpyファイルを読み出して見る。\n\u0026gt;\u0026gt;\u0026gt; import numpy as np \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; data=[] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; data [] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; data = np.load(\u0026#39;data.npy\u0026#39;) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; data array([ 0.05027787, 0.59668757, 0.93566661, 1.57869082, -0.60440496]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; file=np.load(\u0026#39;datum.npz\u0026#39;) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #fileに格納されているデータの表示 \u0026gt;\u0026gt;\u0026gt; print(file.files) [\u0026#39;data1\u0026#39;, \u0026#39;data2\u0026#39;] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; d1=file[\u0026#39;data1\u0026#39;] \u0026gt;\u0026gt;\u0026gt; d1 array([ 1.2854548 , 0.04609777, 0.4210424 , -1.03562392]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; d2=file[\u0026#39;data2\u0026#39;] \u0026gt;\u0026gt;\u0026gt; d2 array([ 0.50145572, -0.76596583, -0.66480387, 0.78022058]) \u0026gt;\u0026gt;\u0026gt;    "},{"idx":32,"href":"/docs/programming/other/null/","title":"Null","content":" Null プログラミングでよく見るNullについて。\nNullとは何なのか？\nNullとは何もない、何も入ってない、という状態を示す語である。\n変数に何も値が定義されていないとき、変数の値を参照しようとするとNullが返ってくる。\nよく0と勘違いされることが多いが、変数の値を参照して0が返ってきたときは、0という値が変数に入っているという意味であり何も値が定義されていないという意味ではないので注意。\n言語により仕様が違うこともあるので、それぞれの言語でのNullを以下に述べていく。\nJava  Javaでは参照型のデータ型において、何も参照していない状態を表す時にnullを利用する。\n参照型の変数に直接nullを代入することも可能である。変数がnullであるかを確認するには、比較演算子(==)を用いる。\nintやcharなどの基本データ型にはnullは入れられないので注意すること。基本データ型には、宣言時に自動的に(型により決められている)初期値が入る。\nnullの変数に対しメソッド呼び出しを行った場合、NullPointerException例外が発生するので注意。\n例\nimport java.util.*; class Main{ public static void main(String args[]){ String s = null; System.out.println(s); System.out.println(s.length()); } } 実行結果\n$ java Main null Exception in thread \u0026quot;main\u0026quot; java.lang.NullPointerException at Main.main(Main.java:7)   Python  PythonではNoneという語がnullである状態を示す。\n同じく変数に直接Noneを代入することも可能である。\nNoneとなっている変数の関数や属性などを呼び出すとエラーになるので注意。\n\u0026gt;\u0026gt;\u0026gt; v = None \u0026gt;\u0026gt;\u0026gt; v \u0026gt;\u0026gt;\u0026gt; #Noneは表示されない \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a={1:\u0026#39;a\u0026#39;,2:\u0026#39;b\u0026#39;} \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a[1] \u0026#39;a\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a=None \u0026gt;\u0026gt;\u0026gt; a[1] Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; TypeError: \u0026#39;NoneType\u0026#39; object is not subscriptable \u0026gt;\u0026gt;\u0026gt; #Noneの関数・属性を呼び出すとエラー  Swift  Swiftではnilという語が値のない、nullである状態を示す。\nしかし、Swiftでは基本的にnilを変数や定数に代入することはできない。\nだが例外として、Optional型の変数はnilを許容でき、nilを代入できる(他にもnilを許容できる型はいくつかあるが、代表的なものはこのOptional変数。)\nvar a: Optional\u0026lt;Int\u0026gt; var b: Int a = nil // OK b = nil // コンパイルエラーが発生する   "},{"idx":33,"href":"/docs/programming/machine_learning/N-dimension_linear_model/","title":"N次元線形回帰モデル","content":" N次元線形回帰モデル 先程までの章では1次元(直線モデル)、2次元(面モデル)の入力データを扱ってきたが、そこから更に次元を広げたN次元の入力データの場合はどうなるだろうか。 ここではそれについてを述べる。\nN次元での入力データから予測値yを算出する式は以下の式で表される。\n  $$ \\tag{1} y=w_{0} x_{0} + w_{1} x_{1} + w_{2} x_{2} + \\cdots + w_{N-1} x_{N-1} + w_{N} (w_{i} は実数) $$ N次元の時も1次元2次元の時と同様に式(1)の様な形で表される。この式の形で表されるモデルは線形回帰モデルと呼ばれている。\n式(1)において、最後のwNには入力データがない事に注意する。 (切片である)\nここでは簡略化のため、以降wN = 0として考える。すると式(1)は以下の様になる。\n$$ \\tag{2} y=w_{0} x_{0} + w_{1} x_{1} + w_{2} x_{2} + \\cdots + w_{N-1} x_{N-1} $$ この式(2)を行列表記で書き直すと、以下の様になる。\n$$ \\begin{aligned} \\tag{3} y \u0026= w_{0} x_{0} + w_{1} x_{1} + w_{2} x_{2} + \\cdots + w_{N-1} x_{N-1} \\\\ \u0026= \\left[ \\begin{array}{ccc} w_{0} \u0026 \\cdots \u0026 w_{N-1} \\end{array} \\right] \\left[ \\begin{array}{cccc} x_{0} \\\\ \\vdots \\\\ x_{N-1} \\end{array} \\right] \\\\ \u0026= {\\bf w} ^\\mathrm{T} {\\bf x} \\end{aligned} $$ ここで\n$$ {\\bf w} = \\left[ \\begin{array}{cccc} w_{0} \\\\ w_{1} \\\\ \\vdots \\\\ w_{N-1} \\end{array} \\right] , {\\bf x} = \\left[ \\begin{array}{cccc} x_{0} \\\\ x_{1} \\\\ \\vdots \\\\ x_{N-1} \\end{array} \\right] $$ とおく。\n では、ここからN次元線形回帰モデルの解析解を求めてみよう。\nこれまでと同様にして、平均二乗誤差Jは以下の様に表される。\n$$ \\begin{aligned} \\tag{4} J( {\\bf w} ) \u0026= \\frac{1}{N} \\sum_{n=0}^{N-1} ( y(x_{n}) - t_{n} )^2 \\\\ \u0026= \\frac{1}{N} \\sum_{n=0}^{N-1} ( {\\bf w} ^\\mathrm{T} {\\bf x}_{n} - t_{n} )^2 \\end{aligned} $$ ここも同様にして、式(4)をwiで偏微分すると、以下の様になる。\n$$ \\begin{aligned} \\tag{5} \\frac{\\partial J}{\\partial w_{i} } \u0026= \\frac{1}{N} \\sum_{n=0}^{N-1} \\frac{\\partial }{\\partial w_{i} } ( {\\bf w} ^\\mathrm{T} {\\bf x}_{n} - t_{n} )^2 \\\\ \u0026= \\frac{2}{N} \\sum_{n=0}^{N-1} ( {\\bf w} ^\\mathrm{T} {\\bf x}_{n} - t_{n} ) x_{n,i} \\end{aligned} $$ なお、xn,iはn番目の入力データにおけるi番目のパラメータである。\nまた、wTxをwiで偏微分すると、xn,iだけが残る事に注意する。\nJを最小にするwでは、全てのwiについて傾き0、つまり式(5)が０になるので、次の式が全てのiで成り立つ。\n$$ \\begin{aligned} \\tag{6} \\frac{2}{N} \\sum_{n=0}^{N-1} ( {\\bf w} ^\\mathrm{T} {\\bf x}_{n} - t_{n} ) x_{n,i} \u0026= 0 \\\\ \\Leftrightarrow \\sum_{n=0}^{N-1} ( {\\bf w} ^\\mathrm{T} {\\bf x}_{n} - t_{n} ) x_{n,i} \u0026= 0 \\end{aligned} $$ 式(6)は全てのi (0≦i≦N-1) で成り立つ。つまり以下の式が成り立つ。\n$$ \\begin{aligned} \\tag{7} \\sum_{n=0}^{N-1} ( {\\bf w} ^\\mathrm{T} {\\bf x}_{n} - t_{n} ) x_{n,0} \u0026= 0 \\\\ \\sum_{n=0}^{N-1} ( {\\bf w} ^\\mathrm{T} {\\bf x}_{n} - t_{n} ) x_{n,1} \u0026= 0 \\\\ \\vdots \\\\ \\sum_{n=0}^{N-1} ( {\\bf w} ^\\mathrm{T} {\\bf x}_{n} - t_{n} ) x_{n,N-1} \u0026= 0 \\end{aligned} $$ この式をベクトルを使って書き換えると以下の式の様になる。\n$$ \\begin{aligned} \\tag{8} \u0026\\sum_{n=0}^{N-1} ( {\\bf w} ^\\mathrm{T} {\\bf x}_{n} - t_{n} ) [ x_{n,0}, x_{n,1}, \\cdots , x_{n,N-1} ] = \\left[ \\begin{array}{ccc} 0 \u0026 0 \u0026 \\cdots \u0026 0 \\end{array} \\right] \\\\ \\Leftrightarrow \u0026\\sum_{n=0}^{N-1} ( {\\bf w} ^\\mathrm{T} {\\bf x}_{n} - t_{n} ) {\\bf x}_{n} ^\\mathrm{T} = \\left[ \\begin{array}{ccc} 0 \u0026 0 \u0026 \\cdots \u0026 0 \\end{array} \\right] \\\\ \\Leftrightarrow \u0026\\sum_{n=0}^{N-1} ( {\\bf w} ^\\mathrm{T} {\\bf x}_{n} {\\bf x}_{n} ^\\mathrm{T} - t_{n} {\\bf x}_{n} ^\\mathrm{T} ) = \\left[ \\begin{array}{ccc} 0 \u0026 0 \u0026 \\cdots \u0026 0 \\end{array} \\right] \\\\ \\Leftrightarrow \u0026 {\\bf w} ^\\mathrm{T} \\sum_{n=0}^{N-1} {\\bf x}_{n} {\\bf x}_{n} ^\\mathrm{T} - \\sum_{n=0}^{N-1} t_{n} {\\bf x}_{n} ^\\mathrm{T} = \\left[ \\begin{array}{ccc} 0 \u0026 0 \u0026 \\cdots \u0026 0 \\end{array} \\right] \\end{aligned} $$ ここで\n$$ \\begin{aligned} \\tag{9} \\sum_{n=0}^{N-1} {\\bf x}_{n} {\\bf x}_{n} ^\\mathrm{T} \u0026= \\sum_{n=0}^{N-1} \\left[ \\begin{array}{cccc} x_{n,0} \\\\ x_{n,1} \\\\ \\vdots \\\\ x_{n,N-1} \\end{array} \\right] \\left[ \\begin{array}{ccc} x_{n,0} \u0026 x_{n,1} \u0026 \\cdots \u0026 x_{n,N-1} \\end{array} \\right] \\\\ \u0026= \\sum_{n=0}^{N-1} \\left[ \\begin{array}{cccc} x_{n,0}^2 \u0026 x_{n,0} x_{n,1} \u0026 \\cdots \u0026 x_{n,0} x_{n,N-1} \\\\ x_{n,1} x_{n,0} \u0026 x_{n,1}^2 \u0026 \\cdots \u0026 x_{n,1} x_{n,N-1} \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ x_{n,N-1} x_{n,0} \u0026 x_{n,N-1} x_{n,1} \u0026 \\cdots \u0026 x_{n,N-1}^2 \\end{array} \\right] \\\\ \u0026= \\left[ \\begin{array}{llll} \\displaystyle \\sum_{n=0}^{N-1} x_{n,0}^2 \u0026 \\displaystyle \\sum_{n=0}^{N-1} x_{n,0} x_{n,1} \u0026 \\cdots \u0026 \\displaystyle \\sum_{n=0}^{N-1} x_{n,0} x_{n,N-1} \\\\ \\displaystyle \\sum_{n=0}^{N-1} x_{n,1} x_{n,0} \u0026 \\displaystyle \\sum_{n=0}^{N-1} x_{n,1}^2 \u0026 \\cdots \u0026 \\displaystyle \\sum_{n=0}^{N-1} x_{n,1} x_{n,N-1} \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ \\displaystyle \\sum_{n=0}^{N-1} x_{n,N-1} x_{n,0} \u0026 \\displaystyle \\sum_{n=0}^{N-1} x_{n,N-1} x_{n,1} \u0026 \\cdots \u0026 \\displaystyle \\sum_{n=0}^{N-1} x_{n,N-1}^2 \\end{array} \\right] \\\\ \u0026= \\left[ \\begin{array}{llll} x_{0,0} \u0026 x_{1,0} \u0026 \\cdots \u0026 x_{N-1,0} \\\\ x_{0,1} \u0026 x_{1,1} \u0026 \\cdots \u0026 x_{N-1,1} \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ x_{0,N-1} \u0026 x_{1,N-1} \u0026 \\cdots \u0026 x_{N-1,N-1} \\end{array} \\right] \\left[ \\begin{array}{llll} x_{0,0} \u0026 x_{0,1} \u0026 \\cdots \u0026 x_{0,N-1} \\\\ x_{1,0} \u0026 x_{1,1} \u0026 \\cdots \u0026 x_{1,N-1} \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ x_{N-1,0} \u0026 x_{N-1,1} \u0026 \\cdots \u0026 x_{N-1,N-1} \\end{array} \\right] \\\\ \u0026= {\\bf X} ^\\mathrm{T} {\\bf X} \\end{aligned} $$ $$ \\begin{aligned} \\tag{10} \\sum_{n=0}^{N-1} t_{n} {\\bf x}_{n} ^\\mathrm{T} \u0026= \\sum_{n=0}^{N-1} t_{n} \\left[ \\begin{array}{ccc} x_{n,0} \u0026 x_{n,1} \u0026 \\cdots \u0026 x_{n,N-1} \\end{array} \\right] \\\\ \u0026= \\sum_{n=0}^{N-1} \\left[ \\begin{array}{ccc} t_{n} x_{n,0} \u0026 t_{n} x_{n,1} \u0026 \\cdots \u0026 t_{n} x_{n,N-1} \\end{array} \\right] \\\\ \u0026= \\left[ \\begin{array}{llll} \\displaystyle \\sum_{n=0}^{N-1} t_{n} x_{n,0} \u0026 \\displaystyle \\sum_{n=0}^{N-1} t_{n} x_{n,1} \u0026 \\cdots \u0026 \\displaystyle \\sum_{n=0}^{N-1} t_{n} x_{n,N-1} \\end{array} \\right] \\\\ \u0026= \\left[ \\begin{array}{ccc} t_{0} \u0026 t_{1} \u0026 \\cdots \u0026 t_{N-1} \\end{array} \\right] \\left[ \\begin{array}{llll} x_{0,0} \u0026 x_{0,1} \u0026 \\cdots \u0026 x_{0,N-1} \\\\ x_{1,0} \u0026 x_{1,1} \u0026 \\cdots \u0026 x_{1,N-1} \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ x_{N-1,0} \u0026 x_{N-1,1} \u0026 \\cdots \u0026 x_{N-1,N-1} \\end{array} \\right] \\\\ \u0026= {\\bf t} ^\\mathrm{T} {\\bf X} \\end{aligned} $$ とおく、ここで\n$$ \\tag{11} {\\bf t} = \\left[ \\begin{array}{cccc} t_{0} \\\\ t_{1} \\\\ \\vdots \\\\ t_{N-1} \\end{array} \\right] , {\\bf X} = \\left[ \\begin{array}{cccc} x_{0,0} \u0026 x_{0,1} \u0026 \\cdots \u0026 x_{0,N-1} \\\\ x_{1,0} \u0026 x_{1,1} \u0026 \\cdots \u0026 x_{1,N-1} \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ x_{N-1,0} \u0026 x_{N-1,1} \u0026 \\cdots \u0026 x_{N-1,N-1} \\end{array} \\right] $$ である。\nこれより、式(8)は以下式(12)の様に書き換えられる。\n$$ \\begin{aligned} \\tag{12} \u0026 {\\bf w} ^\\mathrm{T} \\sum_{n=0}^{N-1} {\\bf x}_{n} {\\bf x}_{n} ^\\mathrm{T} - \\sum_{n=0}^{N-1} t_{n} {\\bf x}_{n} ^\\mathrm{T} \u0026= \\left[ \\begin{array}{ccc} 0 \u0026 0 \u0026 \\cdots \u0026 0 \\end{array} \\right] \\\\ \\Leftrightarrow \u0026 {\\bf w} ^\\mathrm{T} {\\bf X} ^\\mathrm{T} {\\bf X} - {\\bf t} ^\\mathrm{T} {\\bf X} \u0026= \\left[ \\begin{array}{ccc} 0 \u0026 0 \u0026 \\cdots \u0026 0 \\end{array} \\right] \\end{aligned} $$ 式(12)でtTXを右辺に移項すると\n$$ \\tag{13} {\\bf w} ^\\mathrm{T} {\\bf X} ^\\mathrm{T} {\\bf X} = {\\bf t} ^\\mathrm{T} {\\bf X} $$ ここで両辺を転置すると、(AB)T = BTATより式(13)は\n$$ \\begin{aligned} \\tag{14} ( {\\bf w} ^\\mathrm{T} {\\bf X} ^\\mathrm{T} {\\bf X} )^\\mathrm{T} \u0026= ( {\\bf t} ^\\mathrm{T} {\\bf X} )^\\mathrm{T} \\\\ ( {\\bf X} ^\\mathrm{T} {\\bf X} )^\\mathrm{T} ({\\bf w} ^\\mathrm{T}) ^\\mathrm{T} \u0026= {\\bf X} ^\\mathrm{T} {\\bf t} \\\\ ( {\\bf X} ^\\mathrm{T} {\\bf X} ) {\\bf w} \u0026= {\\bf X} ^\\mathrm{T} {\\bf t} \\end{aligned} $$ となり、この式(14)に左から(XTX)-1をかける事により、wは以下の式(15)の様に表される。\n$$ \\tag{15} {\\bf w} = ( {\\bf X} ^\\mathrm{T} {\\bf X} )^{-1} {\\bf X} ^\\mathrm{T} {\\bf t} $$ よって、長くなったが式(15)によりwの値が導出された。またこれがN次元線形回帰モデルの解となる。\nそして、式(15)の右辺の式 (XTX)-1XT はムーアーペンローズの擬似逆行列という名が付けられている。\n さて、式(2)で計算の簡略化のためwN=0としたと書いたが、wN≠0の場合も勿論ある。その場合wやxの次数が異なるがどうすれば良いのか？\nその場合、wNにもダミー用のパラメータであるxNを追加する。\nここで、常にxN=1 となる様に設定する。\n$$ \\begin{aligned} \\tag{16} y \u0026= w_{0} x_{0} + w_{1} x_{1} + w_{2} x_{2} + \\cdots + w_{N-1} x_{N-1} + w_{N} \\\\ \\Leftrightarrow y \u0026= w_{0} x_{0} + w_{1} x_{1} + w_{2} x_{2} + \\cdots + w_{N-1} x_{N-1} + w_{N} x_{N} ( x_{N} = 1) \\end{aligned} $$ この式(16)に対しムーアーペンローズの擬似逆行列を作成すれば、wが求められる。これによりwN≠0の場合においても解が求められた。\n"},{"idx":34,"href":"/docs/programming/other/other_index/","title":"Other Index","content":" その他 その他、括れてない手法などをまとめる。\n 変数  変数を設定する 変数の型を調べる  定数 関数、メソッドのヘルプを見る(Python) コメントアウト Null 正規表現 ジェネリクス Web通信  Webリクエストを送る・レスポンスを受け取る   "},{"idx":35,"href":"/docs/programming/control/pass/","title":"Pass","content":" pass文 何も処理をしない文、pass文についてを示す。\n構文としては何か記述が必要だが、特に処理をする必要がないという時に使う。\n言語によりあるものとないものがある。\nJava  Javaには存在しない。  Python  Pythonではfor,whileの中の処理文には最低１行何か書いておく必要がある。\n何もする事が無くても何か書いておかなければならないため、このような時にpass文を用いる。\n（Javaなどでは処理分の中に何も書かなくてもコンパイルは通る）\n実行例を示す。\n\u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #whileの無限ループ。Ctrl+Cで止めない限りずっと続く \u0026gt;\u0026gt;\u0026gt; while(True): ... pass ... Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 2, in \u0026lt;module\u0026gt; KeyboardInterrupt \u0026gt;\u0026gt;\u0026gt; #Ctrl+Cを入力した \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #クラスの定義など \u0026gt;\u0026gt;\u0026gt; class Fruits: ... def __init__(): ... pass ... \u0026gt;\u0026gt;\u0026gt;    "},{"idx":36,"href":"/docs/programming/math/rand/","title":"Rand","content":" 要素がランダムの行列 要素がランダムの行列を生成する方法を示す。\nPython  要素がランダムな行列(2次元配列)を生成するにはnumpy.random.rand(size)を利用する。生成する要素は0~1の範囲。\n引数には行、列の２つを入力する。\n要素の数字の範囲を指定したい場合はnumpy.random,randint(low,high,size)を利用する。low~highの範囲内で要素を生成する。（randint関数のsizeはタプル。）\n\u0026gt;\u0026gt;\u0026gt; import numpy as np \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; np.random.rand(2,3) array([[0.02518258, 0.67200546, 0.74582057], [0.6981033 , 0.34828809, 0.96494006]]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; np.random.rand(2,3) array([[0.22508354, 0.59051942, 0.19889851], [0.18481436, 0.62366147, 0.94710535]]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; np.random.rand(2,3) array([[0.22727686, 0.33240298, 0.06083574], [0.48593146, 0.29350652, 0.46091046]]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; np.random.randint(100,200,(3,3)) array([[173, 101, 157], [112, 156, 184], [178, 142, 194]]) \u0026gt;\u0026gt;\u0026gt;    "},{"idx":37,"href":"/docs/programming/list/set/","title":"Set型","content":" Set型 Set型変数とはリストと似たデータ構造で、リストから要素の重複を除いたものを順不同で集めたデータ構造である。しかし、インデックスを指定して要素を取り出すことは一般的にはできない。\nSet型変数についてを述べる。\nJava  JavaでのリストはSetクラスをインポートして利用する。\nしかし、Setクラスはインターフェースであるため、そのまま使用することはできない。\n使用するには、Setの具体的な定義が書いてあるクラスをSetのインスタンスに代入して使う。\nこのクラスは複数あるが、ここでは一般的なHashSetクラスを利用する。\nなお、HashSetも使用するにはインポートする必要がある。\n実行例を以下に示す。\nimport java.util.Set; import java.util.HashSet; class Main{ public static void main(String args[]){ Set\u0026lt;String\u0026gt; s = new HashSet\u0026lt;\u0026gt;(); s.add(\u0026#34;a\u0026#34;); //set.add() でsetに要素を加える  s.add(\u0026#34;b\u0026#34;); s.add(\u0026#34;c\u0026#34;); s.add(\u0026#34;a\u0026#34;); //\u0026#34;a\u0026#34;は既に入っているので、入らない  System.out.println(s); } } 実行結果\n$ java Main [a, b, c]   Python  PythonでSet型変数を作るには中括弧 {} または set 関数を利用する。(set関数を利用する場合は文字列またはリストを入力する)\n実行例を以下に示す。\n\u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a = {\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;} \u0026gt;\u0026gt;\u0026gt; a {\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;} \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; b = set(\u0026#39;abcab\u0026#39;) \u0026gt;\u0026gt;\u0026gt; b {\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;} \u0026gt;\u0026gt;\u0026gt;    "},{"idx":38,"href":"/docs/programming/control/switch/","title":"switch文","content":" switch文 switch文は一つの式の結果から多くの処理に分岐させたいときに用いる。\nここではそのswitch文についてを示す。\nJava  Javaでのswitch文での記法は以下の通り。\nswitch (式) { case 定数１: //式の結果が定数１に一致したときはここの処理が実行 break; case 定数２： //式の結果が定数２に一致したときはここの処理が実行 break; ・・・ ・・・ default: //どのcaseにも一致しなかった場合はこの処理が実行 break; }  case,default後の処理の最後には必ずbreakを書く。書かないとその後ろのcase文の処理も実行してしまう。\nimport java.util.Random; class Main{ public static void main(String args[]){ Random random = new Random(); int val = random.nextInt(3); //0~2でランダムに数値選出  System.out.print(val + \u0026#34;: \u0026#34;); switch(val){ case 2: System.out.println(\u0026#34;大吉\u0026#34;); break; case 1: System.out.println(\u0026#34;中吉\u0026#34;); break; default: System.out.println(\u0026#34;吉\u0026#34;); break; } } } 実行結果\n$ java Main 0: 吉 $ java Main 2: 大吉   Python  Pythonにはswitch文が存在しない。\nそのためif-elseなどで条件分岐を実装する。\n Javascript  Javascriptにはswitch文が存在し、利用法はJavaと同じである。\nswitch (式) { case 定数１: //式の結果が定数１に一致したときはここの処理が実行 break; case 定数２： //式の結果が定数２に一致したときはここの処理が実行 break; ・・・ ・・・ default: //どのcaseにも一致しなかった場合はこの処理が実行 break; }    "},{"idx":39,"href":"/docs/programming/other/type/","title":"Type","content":" 変数の型を調べる 変数の型を調べる方法についてを示す。\nJava  javaにはinstanceofという演算子がある。\n変数 instanceof クラス名\n変数に入っているデータの型が右辺のクラスと一致していればtrue、そうでない場合はfalseが返る。\nこの演算子は参照型のクラスにしか使えず、intやcharのような基本データ型には利用できない。(ラッパークラスには利用可能)\nまた、instanceof演算子は変数のデータの型とクラスに継承または実装の関係がないと使用できないという決まりがある。 例として以下のように書いてもエラーとなる。\nclass Main{ public static void main(String args[]){ String s = \u0026#34;aaa\u0026#34;; System.out.println(\u0026#34;s is String? :\u0026#34; + (s instanceof String)); System.out.println(\u0026#34;s is Integer?:\u0026#34; + (s instanceof Integer)); } } コンパイル結果\n$ javac Main.java Main.java:7: エラー: 不適合な型: StringをIntegerに変換できません: System.out.println(\u0026quot;s is Integer?:\u0026quot; + (s instanceof Integer)); ^ エラー1個  instanceof演算子は主に継承および実装の関係にあるデータ間で利用する。（スーパークラスに入っているデータがどのサブクラスか、インタフェースを実装しているのがどのクラスか、など）\nclass Fruits{} class Apple extends Fruits{} class Banana extends Fruits{} class Cherry extends Fruits{} class Main{ public static void main(String args[]){ Fruits f = new Banana(); System.out.println(\u0026#34;f is Fruits?:\u0026#34; + (f instanceof Fruits)); System.out.println(\u0026#34;f is Apple? :\u0026#34; + (f instanceof Apple)); System.out.println(\u0026#34;f is Banana?:\u0026#34; + (f instanceof Banana)); System.out.println(\u0026#34;f is Cherry?:\u0026#34; + (f instanceof Cherry)); } } 実行結果\n\u0026gt; java Main f is Fruits?:true f is Apple? :false f is Banana?:true f is Cherry?:false   Python  Pythonでは組み込み関数type()を使うことにより、変数にあるデータの型が何であるかが分かる。\n\u0026gt;\u0026gt;\u0026gt; a=1 \u0026gt;\u0026gt;\u0026gt; a 1 \u0026gt;\u0026gt;\u0026gt; type(a) \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; b=\u0026#39;moji\u0026#39; \u0026gt;\u0026gt;\u0026gt; b \u0026#39;moji\u0026#39; \u0026gt;\u0026gt;\u0026gt; type(b) \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; c=[1,2,3] \u0026gt;\u0026gt;\u0026gt; c [1, 2, 3] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; type(c) \u0026lt;class \u0026#39;list\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; d={1:\u0026#39;a\u0026#39;,2:\u0026#39;b\u0026#39;} \u0026gt;\u0026gt;\u0026gt; d {1: \u0026#39;a\u0026#39;, 2: \u0026#39;b\u0026#39;} \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; type(d) \u0026lt;class \u0026#39;dict\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt;    "},{"idx":40,"href":"/docs/programming/procon/union-find/","title":"Union-Find木","content":" Union-Find木 Union-Find木について。\nUnion-Find木は要素のグループ分けを管理するデータ構造である。 1つ以上の要素を含むグループが何個かあった時、次の事が行える。\n 2つのグループをマージする 2つの要素が同じグループに含まれているか判定する  注意としては、グループを分割することはできないという事。\n例としては、以下のような図になる。\nUnion-find木は特に根や次数等は決まっておらず、グループ内の要素がすべて含まれていればどのような木構造でも良い。\n初期化 まずは要素を用意し、それぞれの要素のノードを作る。初期の状態ではこのノードがそれぞれグループを表す。この段階ではまだ要素が1つだけだが、これでも一応木を表す。以下の図にその例を示す。\n2グループのマージ 2つのグループ(木)をマージするには、片方のグループ(木)の根の下にもう片方のグループ(木)の根を結び付ける。以下例。\n2要素が同一グループにいることの判定 ある2つの要素が同じグループにいることを判定するには、それぞれの要素がいるグループ(木)の根の要素が同じであるかで判定できる。以下がその例である。\n"},{"idx":41,"href":"/docs/programming/control/while/","title":"while文","content":" while文 繰り返し処理を行う制御構文の一つ、while文について各言語での利用法を示す。\nJava  Javaでの記法は以下の通り。\nwhile(条件式){ //処理 }  上記におけるフローは以下の通り。\n 条件式を実行しtrueなら3,falseなら4に行く while文の中身の処理が実行される。 1.に戻る 終了する  while文の条件式は必ずtrueかfalseを返すような式にする。\n処理の関係上、条件式がずっとtrueになるような処理にさせると無限ループとなり、実行が終わらなくなるので注意。\n実行例を以下に示す。\nclass Main{ public static void main(String args[]){ int i=0; while(i\u0026lt;5){ System.out.println(i); i++; //iに1を足す これがないと無限ループ  } } } 実行結果\n\u0026gt; java Main 0 1 2 3 4   Python  Pythonでの記法は以下の通り。\nwhile 条件式: #処理 ・・・  条件式がTrueである限り、while文以下の処理を実行し続ける。\n実行例を以下に示す。\n\u0026gt;\u0026gt;\u0026gt; i=0 \u0026gt;\u0026gt;\u0026gt; while i\u0026lt;5: ... print(i) ... i+=1 ... 0 1 2 3 4 \u0026gt;\u0026gt;\u0026gt;   "},{"idx":42,"href":"/docs/programming/graph/lim/","title":"x,y軸の表示範囲を指定する","content":" x,y軸の表示範囲を指定する Python  グラフの軸の表示範囲は入力した座標の最大値、最小値に基づいて決定されるが、\nこちらでx,y軸の表示範囲を指定したい場合、x軸はxlim(min,max)、y軸はylim(min,max)という関数を使って指定する。\n例として、前述のグラフに色をつけるで作成したグラフに表示範囲を指定した例を示す。\n\u0026gt;\u0026gt;\u0026gt; import numpy as np \u0026gt;\u0026gt;\u0026gt; import matplotlib.pyplot as plt \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; def f(x,w): ... return (x-w)*x*(x+w) ... \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; x = np.linspace(-3,3,61) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #y:f(x) = x**3、w=0という凡例をつける \u0026gt;\u0026gt;\u0026gt; y = f(x,0) \u0026gt;\u0026gt;\u0026gt; plt.plot(x,y,color=\u0026#39;black\u0026#39;,label=\u0026#39;$w=0$\u0026#39;) [\u0026lt;matplotlib.lines.Line2D object at 0x118e0b748\u0026gt;] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #y2:f(x) = (x-2)x(x+2)、w=2という凡例をつける \u0026gt;\u0026gt;\u0026gt; y2 = f(x,2) \u0026gt;\u0026gt;\u0026gt; plt.plot(x,y2,color=\u0026#39;red\u0026#39;,label=\u0026#39;$w=2$\u0026#39;) [\u0026lt;matplotlib.lines.Line2D object at 0x118e0bb38\u0026gt;] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #x軸は-3~3の範囲で表示 \u0026gt;\u0026gt;\u0026gt; plt.xlim(-3,3) (-3, 3) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #y軸は-20~20の範囲で表示 \u0026gt;\u0026gt;\u0026gt; plt.ylim(-20,20) (-20, 20) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; plt.show() \u0026gt;\u0026gt;\u0026gt;  実行結果\n-3≦x≦3、-20≦y≦20の範囲でグラフが表示された。\n  "},{"idx":43,"href":"/docs/front-end/css_other/","title":"その他","content":" その他(CSS) CSSについてその他、括れてない手法についてを述べる。\nグラデーション CSSで、画像が指定可能なところにおいては、画像の場所を示すurl()の代わりに、linear-gradient()またはradial-gradient()と言う書式を使い、グラデーションを表示させることができる。\n以下でその方法についてを述べる。\nlinear-gradientプロパティ linear-graientプロパティは、直線状のグラデーションを設定するプロパティである。\n書式は以下の通り。\nlinear-gradient(方向,色1,色2)  ここで、引数の「方向」に設定する値は以下の通り。\n 値 意味   数値(角度) 指定した角度を境としたグラデーション   to [top,bottom,left,right] 指定した方向へのグラデーション   使用例(css)\np { width:300px; height:300px; padding:0px; margin:0px; background-image:linear-gradient(180deg,red,blue); } (html)\n\u0026lt;p\u0026gt;linear-gradientの例\u0026lt;/p\u0026gt; 表示例\n radial-gradientプロパティ radial-gradientプロパティは、放射状のグラデーションを設定するプロパティである。\n書式は以下の通り。\nradial-gradient(at 中心の位置,中心の色,外側の色)  ここで、引数の「中心の位置」に設定する値は以下の通り。\n 値 意味   top ・・ 一番上(縦方向の0%)   bottom ・・ 一番下(縦方向の100%)   left ・・ 一番左(横方向の0%)   right ・・ 一番右(横方向の100%)   center ・・ 中央(縦・横方向の50%)   (パーセンテージ) ・・ それぞれの方向に対するパーセンテージ。数値の後に%をつける   使用例(css)\np { width:300px; height:300px; padding:0px; margin:0px; background-image:radial-gradient(at bottom,blue,red); } (html)\n\u0026lt;p\u0026gt;radial-gradientの例\u0026lt;/p\u0026gt; 表示例\n リスト関連のプロパティ リスト関連について、紹介し切れていないプロパティについてを述べる。\nlist-style-typeプロパティ list-style-typeプロパティは、リストの行頭記号の種類を設定するプロパティである。\n設定する値と意味は以下の通り。\n 値 意味   none 行頭記号を消す   disc 黒丸にする   circle 白抜きの丸にする   square 四角にする   decimal 数字にする   decimal-leading-zero 先頭に0をつけた数字にする(01,02,03..)   lower-roman 小文字のローマ数字にする   upper-roman 大文字のローマ数字にする   lower-latin 小文字のアルファベットにする   upper-latin 大文字のアルファベットにする   lower-alpha 小文字のアルファベットにする   upper-alpha 大文字のアルファベットにする   lower-greek 小文字のギリシャ文字にする   使用例\n\u0026lt;ul style=\u0026#34;list-style-type:circle\u0026#34;\u0026gt; \u0026lt;li\u0026gt;その１\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;その２\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;その３\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;br\u0026gt; \u0026lt;ul style=\u0026#34;list-style-type:lower-greek\u0026#34;\u0026gt; \u0026lt;li\u0026gt;その１\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;その２\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;その３\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 表示例\nその１ その２ その３  その１ その２ その３  list-style-image プロパティ list-style-imageプロパティは、リストの行頭記号に表示する画像を設定するプロパティである。\n設定する値と意味は以下の通り。\n 値 意味   url(...) 画像のURLを指定し、その画像が行頭記号として表示される。   none 画像を行頭記号として表示させない   使用例(css)\nul { list-style-image: url(list-style-image.png); } (html)\n\u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;その１\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;その２\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;その３\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 表示例\n list-style-position プロパティ list-style-positionプロパティは、行頭記号の表示位置を設定するプロパティである。\n設定する値と意味は以下の通り。\n 値 意味   outside テキストを表示させる領域の外側に表示させる   inside テキストを表示させる領域の内側に表示させる   使用例\n\u0026lt;ul style=\u0026#34;list-style-position:inside\u0026#34;\u0026gt; \u0026lt;li\u0026gt;その１\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;その２\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;その３\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;br\u0026gt; \u0026lt;ul style=\u0026#34;list-style-position:outside\u0026#34;\u0026gt; \u0026lt;li\u0026gt;その１\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;その２\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;その３\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 表示例\nその１ その２ その３  その１ その２ その３  list-style プロパティ list-styleプロパティは、前述のlist-style系のプロパティの値を空白区切りでまとめて指定できるプロパティである。\n使用例\n\u0026lt;ul style=\u0026#34;list-style:lower-greek inside\u0026#34;\u0026gt; \u0026lt;li\u0026gt;その１\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;その２\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;その３\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 表示例\nその１ その２ その３  テーブル関連のプロパティ テーブル関連について、紹介し切れていないプロパティについてを述べる。\ncaption-sideプロパティ caption-sideプロパティは、キャプションを表の上か下かどちらかに表示させるかを設定するプロパティである。\n値はtop,bottomのいずれかを指定する。\n使用例\n\u0026lt;table\u0026gt; \u0026lt;caption style=\u0026#34;caption-side:bottom\u0026#34;\u0026gt;キャプションbottom\u0026lt;/caption\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;0,0\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;1,0\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;0,1\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;1,1\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; 表示例\n キャプションbottom  0,0 1,0   0,1 1,1   border-collapseプロパティ border-collapseプロパティは、ボーダーを隣接するセルと重ねて表示するか、離して標示するかを設定するプロパティである。\n値はcollapse(隣接するセルと重ねて表示)、separate(隣接するセルと離して表示)のいずれかである。\n使用例\n\u0026lt;table style=\u0026#34;border-collapse: collapse;\u0026#34;\u0026gt; \u0026lt;caption\u0026gt;collapse\u0026lt;/caption\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026#34;border: solid 1px;\u0026#34;\u0026gt;0,0\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026#34;border: solid 1px;\u0026#34;\u0026gt;1,0\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026#34;border: solid 1px;\u0026#34;\u0026gt;0,1\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026#34;border: solid 1px;\u0026#34;\u0026gt;1,1\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; 表示例\ncollapse  0,0 1,0   0,1 1,1   border-spacingプロパティ border-spacingプロパティは、テーブルにおいて隣接するセルのボーダーとボーダーの間隔を設定するプロパティである。\n先述のborder-collapseプロパティの値がseparateのときに有効となり、値は単位付きの数値を指定する。\n使用例\n\u0026lt;table style=\u0026#34;border-collapse: separate;border-spacing: 2px\u0026#34;\u0026gt; \u0026lt;caption\u0026gt;separate 2px\u0026lt;/caption\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026#34;border: solid 1px;\u0026#34;\u0026gt;0,0\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026#34;border: solid 1px;\u0026#34;\u0026gt;1,0\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026#34;border: solid 1px;\u0026#34;\u0026gt;0,1\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026#34;border: solid 1px;\u0026#34;\u0026gt;1,1\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; 表示例\nseparate 2px  0,0 1,0   0,1 1,1   empty-cellsプロパティ empty-cellsプロパティは、テーブルのセルが空白の時にボーダーを表示するかしないかを設定するプロパティである。\n値はshow(表示する),hide(表示しない)のいずれかを指定する。\n使用例\n\u0026lt;table style=\u0026#34;border-collapse: separate;border-spacing: 2px; empty-cells: show;\u0026#34;\u0026gt; \u0026lt;caption\u0026gt;separate 2px\u0026lt;/caption\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026#34;border: solid 1px;\u0026#34;\u0026gt;0,0\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026#34;border: solid 1px;\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026#34;border: solid 1px;\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026#34;border: solid 1px;\u0026#34;\u0026gt;1,1\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; 表示例\nseparate 2px  0,0     1,1   内容を追加するプロパティ 内容を追加するプロパティについて。\ncontentプロパティ contentプロパティは、CSSでコンテンツ（テキスト・画像など）を追加するためのプロパティである。\ncontentプロパティでは、擬似要素:before、:afterを利用して要素の前後どちらに挿入するかを決定する。\n設定する値と意味は以下の通り。\n 値 意味   テキスト(ダブルクォートまたはシングルクォートで囲う) 入力したテキストがそのまま挿入される   url(...) 指定した画像が挿入される。   attr(...) 指定した属性で指定されている文字列が挿入される。   counter(...) カウンタ変数(後述)の値が挿入される。   open-quote、close-quote quotesプロパティで設定されている値が挿入される。   none コンテンツを追加しない   使用例(css)\np::before { content:\u0026#34;「contentプロパティで挿入された文字です」\u0026#34;; } (html)\n\u0026lt;p\u0026gt;ここはp要素の内容です\u0026lt;/p\u0026gt; 表示例\n quotesプロパティ quotesプロパティは、q要素またはcontentプロパティで引用符を追加(open-quote,close-quote)するときにどの引用符を使うかを指定するプロパティである。\n使用するには、使う引用符を半角スペースで区切ってペアで指定する。\n使用例\nq { quotes:\u0026#34;-\u0026gt;-\u0026gt;\u0026#34; \u0026#34;\u0026lt;-\u0026lt;-\u0026#34;; } (html)\n\u0026lt;q\u0026gt;ここはq要素で囲まれています\u0026lt;/q\u0026gt; 表示例\n counter-resetプロパティ counter-resetプロパティは、値をリセット(0にする)したいカウンタ変数を指定するプロパティである。\n値にはカウンタとして用いる変数を指定する。\n(使用例は次とまとめる)\ncounter-incrementプロパティ counter-incrementプロパティは、カウンタ変数の値を1増やすプロパティである。\n値にはカウンタとして用いる変数を指定する。\n使用例(css)\nbody { counter-reset: chapter; } p::before { counter-increment: chapter; content: counter(chapter); } (html)\n\u0026lt;p\u0026gt;p要素1個目\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;p要素2個目\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;p要素3個目\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;p要素4個目\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;p要素5個目\u0026lt;/p\u0026gt; 表示例\n "},{"idx":44,"href":"/docs/front-end/web_other/","title":"その他のWeb関連技術","content":" その他のWeb関連技術 ここまでで述べられてないWeb関連技術についてを述べる。\nなお、ここでは具体例はあまり載せられていません。悪しからず。\n文書 XHTML XHTMLとは、HTMLをXMLの文法で定義し直して書かれた文書である。\nHTMLとの相違点は以下の通り。\n 文書の先頭にXML宣言文が必要 文字の大文字・小文字が区別される 要素は必ず開始タグと終了タグで囲まれてないといけない  マイクロデータ マイクロデータとは、文書の意味や属性を示すデータを、メタデータとして文書に埋め込ませたものである。\nマイクロデータを利用することで、検索エンジンなどのプログラムにWebページの詳しい情報を伝えることができる。\nマイクロデータで、以下の3つの属性を使用して表現する。\n itemscope ・・・ 意味付けブロックの開始の宣言 itemtype ・・・ データの種別(URL) itemprop ・・・ データのプロパティ名  RDFa (Resource Description Framework in Attributes) RDFaとは、RDFによるメタデータをXHTMLで書かれた構造活文書に埋め込むための仕様である。\nその前にRDFとは何か？についてだが、RDFはメタデータを表記するためのデータ形式の一つである。\n(RDFの記載例は略)\n一見マイクロデータと用途は同じに見えるが、RDFaはRDF(XML由来)を元にしているため、XML文書でも利用できるという特徴がある。\nOGP (Open Graph Protocol) OGPは、Webページの内容を示した情報を、プログラムから読める形でWebページに付加しておくための仕様である。\n活用例としてはSNSがある。OGPに対応したページにある「いいね!」ボタンなどをクリックすると、その情報が自分のSNSのページに記載されたり、または他のリコメンデーションなど、様々な機能に活用される。\nデータ操作 JavaScript JavaScriptというオブジェクト指向プログラミング言語があり、この言語で実装したスクリプトを、HTML文書に組み込んで使用することができる。\nHTMLからJavascriptを利用するには、script要素を利用してHTML文書に直接書く方法（下例）と、\n\u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; //Javascriptのコードを記述する \u0026lt;/script\u0026gt; 同じくscript要素のsrc属性にJavascriptのファイルを指定する方法（下例）がある。\n\u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;test.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; DOM(Document Object Model) DOMとはHTML,XML文書にJavaScript等のプログラムからアクセスするためのAPIである。\nJavaScriptを用いてDOMを利用する事で、文書を取得したり操作することが可能になる。\nAjax(Asynchronous Javascript + XML) Ajaxとは、ブラウザ内で非同期通信や動的ページ置き換え等を行う技術である。\nAjaxはJavascriptのクラスであるXMLHttpRequestを利用して実現する。それを行なって通信結果をJavascriptでCSSで動的にWebページに反映する。非同期通信により、ユーザーがフォームなどに入力をしていてもバックグラウンドでデータを取得することが可能になる。\nAjaxで転送されるデータとしてはJSONがよく用いられる。\n通信 セッション セッションとは、ユーザーがログインからログオフするまでの一連の通信のことである。\nHTTPは状態を持たないステートレスなプロトコルであるため、ユーザーがあるサイトに今ログインしている状態なのかを判別する仕組みがない。そのため、画面操作をしているユーザーのログイン状態を判別する仕組みとしてこのセッションが設けられている。\nセッションは、Cookieなどといった技術を用いて実現する。１度目のアクセスでWebサーバからブラウザにCookieが送信され、ブラウザはURLとそのCookieを紐づけて管理し、次のアクセスではそのCookieを送信する。\nWebサーバはその受け取ったCookieを確認し、前回アクセスのあったユーザーと認識できれば、前回のアクセスの続きとして情報を送信する。\nデータURI データURIとは、画像などのデータをBase64を用いて暗号化し、HTMLやCSSに直接埋め込んだ際のURIの事である。\n暗号化するので本来よりも容量が大きくなることがあるが、HTMLに埋め込まれるため、Webサーバへのリクエスト回数を減らすことが可能になる。\nWebサイトへの攻撃手法 SQLインジェクション SQLインジェクションとは、入力フォームなどにSQL文を構成する値を入力させることで、アプリケーションに本来意図しないようなSQLを実行させ、データベースを不正に操作する攻撃手法のことである。\nアプリケーションが使っているSQL文を推測する必要があるが、攻撃が成功してしまうとデータの改竄や消去、情報漏洩が発生する恐れがある。\n対策としては、以下のような方法がある。\n 入力値で特殊文字を受け付けないなどする (開発言語により有無あるが)Prepared statement(事前にコンパイル可能なSQL文)を利用する  クロスサイトスクリプティング(XSS) クロスサイトスクリプティングとは、ユーザが悪意のあるスクリプトを生成するWebサイトを閲覧したときに、そのサイトからユーザのブラウザにスクリプトが埋め込ませ、及びその状態で攻撃対象サイトに強制的に遷移させることで、ユーザやサーバに被害を与える攻撃手法である。\nスクリプトが埋め込まれた状態で他の攻撃対象サイトに遷移させると、そのサイト上でスクリプトが実行され、個人情報取得やなりすましなどの攻撃をされる恐れが有る。\nブラウザ側でJavascriptを無効にすれば防げるが、Javascriptを利用するサイトが閲覧できなくなるためお勧めではない。\n閲覧者側としてはブラウザのアップデートやセキュリティソフトの導入、サイト管理者側としては入力値のチェックなど、XSSに対応したアプリケーションを構築する必要がある。\nクロスサイトリクエストフォージェリ(CSRF) クロスサイトリクエストフォージェリとは、ユーザがあるWebアプリケーションにログインしている(セッションを確立)時に、外部の攻撃者がそのユーザになりすまして、用意したHTTPリクエストを送信することで、ユーザの意図しない動作を行わせる攻撃手法である。\nユーザがWebアプリケーションにログインしている時に、外部の攻撃者が用意したサイトを閲覧すると、悪意のあるスクリプトを実行させることでセッションのデータ(Cookieなど)を盗み見られてしまう。それを利用してHTTPリクエストを作成し、Webアプリケーションに送ってしまうと、外部の攻撃者がそのユーザの状態でいろいろな操作を行えてしまう。\n対策としてはWebアプリケーション側でHTTPリクエストを詳しく確認させたり、またはその他の照合情報などを利用してユーザのチェックを行うなどがある。\nディレクトリトラバーサル ディレクトリトラバーサルとは、URL等のパラメータで示されているファイルから../といったような親ディレクトリを示す文字列等を追加することで、本来Web利用者がアクセスできないようなファイルにアクセスしようとする攻撃手法である。\n対策としては、ファイルのパーミッション(アクセス権)を適切に設定し、他ユーザがアクセスできないようにする等ある。\nHTTPヘッダインジェクション Webサイトには、ユーザへのHTTPレスポンスを生成する時に、そのHTTPヘッダの値を外部から入力されたパラメータを利用して生成する物が存在する。\nそこに外部の攻撃者が任意の値を設定させることで、ユーザにレスポンスを送り意図しないような動作を行わせる攻撃手法のことを、HTTPヘッダインジェクションという。\n例えば、HTTPレスポンスのLocationヘッダはURLを設定するが、このURLに\u0026rdquo;Set-Cookie:..\u0026ldquo;を付け足して設定すると、ユーザーに不正なCookieまでも送ってしまう。このように、HTTPヘッダを任意に設定することでユーザーに悪影響を及ぼす場合がある。\n対策としては、HTTPヘッダを出力するAPIを使ってHTTPヘッダを作り出すなど行う。\nネットワーク上の脅威対策 統合脅威管理(Unified Threat Management: UTM) 統合脅威管理とは、ネットワークを複数の脅威から統合的に保護すること、及びそれを実現するための製品、システムのことである。\nセキュリティに関するシステムといえばファイアウォール、アンチウイルス、VPN、フィルタリングなど色々あるが、それらを統合して1つのシステムとした物が統合脅威管理として挙げられる。\n侵入検知システム(Intrusion Detection System:IDS) 侵入検知システムとは、ネットワークからの不正アクセスを検知するシステムのことである。\n種類としてはネットワークの通信内容を検査するネットワーク型IDSと、サーバに異常がないかを監視するホスト型IDSがある。\nWebサイト、アプリケーションの構築手法 MVCアーキテクチャ 様々なプログラムに応用できる汎用的な設計パターンのことをデザインパターンという。\nMVCアーキテクチャとは、Webアプリケーションにおけるデザインパターンの1つであり、ソフトウェアを以下の3つに分けて設計する手法を指す。\n モデル(Model) ・・ 業務処理など主要な処理を行う   ビュー(View) ・・ 画面などの表示処理を行う   コントローラ(Controller) ・・ モデルとビューの橋渡しを行う   イメージとしては、ビューがユーザーから入力を受け取り、処理依頼をコントローラに送る。その後、コントローラはモデルに処理を要求し、モデルはその処理を受け取って外部のDB塔を使い処理を完了させる。モデルは処理を完了すると、コントローラに通知する。通知を受け取ったコントローラは、処理結果をビューに送り出力させる、という流れで処理が行われる。\nCMS(Content Management System) CMSとは、Webページをなすテキストや画像ファイルといったコンテンツを一元的に管理し、Webページの作成や更新が可能なソフトウェアの事である。\nHTMLやCSSの知識がなくとも、コンテンツを用意すればCMSがWebページをビルドしてくれる。例としては、ブログサービスのWordPressや本ブログの元ともなっているHugo、またWikiなどがある。\n画像ファイル 画像ファイルの種類 画像ファイルの種類はいくつかある。以下にその一部を記載する。\n BMP ・・ フルカラーに対応したWindowsの標準画像フォーマット。一般的に圧縮されないことが多くファイルサイズが大きくなるため、Webサイトでの使用は不適切。   GIF ・・ 256色まで対応する可逆圧縮の画像フォーマット。画質の劣化がないため、単純なイラストに向いている。アニメーションも作成できる。   PNG ・・ フルカラーに対応した可逆圧縮の画像フォーマット。GIFの代替として登場した。圧縮率はGIFよりは良いがJPEGには劣る。   JPEG ・・ フルカラーに対応した非可逆圧縮の画像フォーマット。ファイルサイズはより小さくできるが、非可逆圧縮のため画質はもとより低下する。多少の画質劣化が問題にならない写真に向いている。   SVG ・・ XMLで記述するベクターデータのフォーマット。拡大縮小しても画像が劣化しない。Javascriptによる制御も行える。   インターレース インターレースとは画像の表示形式の一つで、画像データの受信中に粗い解像度の画像を表示し、データを受信するに従って徐々に高解像度の画像を表示するという手法である。\nインターレースはGIF,PNGで使える。JPEGではインターレースに似た「プログレッシブJPEG」を設定することができる。\nWebサイトの集客と収益 Webサイトの集客・収益に用いられる手法についてを述べる。\nSEO(Search Engine Optimization) SEOとは、検索エンジン最適化(Search Engine Optimization)の事であり、検索エンジンで検索した時に自分のWebサイトがなるべく上位に来るように工夫する事をいう。\n簡単な方法としては適切なページタイトルを設定したり、マイクロデータやRDFaを設定するなどといった物がある。SEOを専門に行う業者も存在する。\n検索ロボット 検索ロボットとは、検索エンジンのデータベースを作成するために、全世界のWebページをダウンロードするプログラムである。\n検索ロボットにとって分かりやすい記述をすると、SEOが行えやすい。逆に検索エンジンにヒットさせたくないときは、Basic認証や、robots.txtファイル(サイトをクロールされないように制御するファイル)を設定する。\nWeb広告 Web広告として、代表的なものは以下の通り。\n ペイパークリック広告(PPC) ・・ 広告をクリックした回数に応じて課金される。   アドワーズ広告 ・・ 検索エンジンの検索結果に連動して表示されるPPC広告。   アフィリエイト広告 ・・ 成果報酬型のインターネット広告で、広告のクリック数、またその広告をもとに売上に繋がったなどの結果に応じて広告料が支払われる。   コンバージョンレート コンバージョンレートとは、Webサイトへのアクセス数やユーザー数のうち、収益に結びついた割合のことである。\nここでいう収益とは、商品購入や会員登録などのことを指す。（定義はWebサイトによって異なる）\nROI ROIは投資利益率(Return On Inversion)の事で、投資した資本に対して得られる利益の割合のことである。\n"},{"idx":45,"href":"/docs/front-end/html_other/","title":"その他の要素","content":" その他の要素 その他の要素についてを述べる。\nfigure要素 figure要素は、それが文書から参照される、自己完結型のコンテンツ(フローコンテンツ)であることを示す要素である。\nこの要素の中には、図やソースコードなどを入れる。\n使用例\n\u0026lt;figure id=\u0026quot;fig\u0026quot;\u0026gt; \u0026lt;img src=\u0026quot;/img/front-end/img.jpg\u0026quot; width=\u0026quot;100\u0026quot; height=\u0026quot;100\u0026quot; alt=\u0026quot;宗谷岬、青空\u0026quot;\u0026gt; \u0026lt;/figure\u0026gt;  表示例\n  \nfigcaption要素 figcaption要素は、figure要素で示したコンテンツにキャプションを示すための要素である。\n使用例\n\u0026lt;figure id=\u0026quot;fig\u0026quot;\u0026gt; \u0026lt;figcaption\u0026gt;宗谷岬の交差点\u0026lt;/figcaption\u0026gt; \u0026lt;img src=\u0026quot;/img/front-end/img.jpg\u0026quot; width=\u0026quot;100\u0026quot; height=\u0026quot;100\u0026quot; alt=\u0026quot;宗谷岬、青空\u0026quot;\u0026gt; \u0026lt;/figure\u0026gt;  表示例\n 宗谷岬の交差点  \ndetails要素 details要素は、ディスクロージャーウィジェット(折りたたみ)を示すための要素である。\nopen属性を指定すると、最初から開かれた状態で表示される。\n使用例\n\u0026lt;details\u0026gt; \u0026lt;p\u0026gt;その１\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;その２\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;その３\u0026lt;/p\u0026gt; \u0026lt;/details\u0026gt;  表示例\n  その１\nその２\nその３\n \nsummary要素 summary要素は、ディスクロージャーウィジェットにおける見出しを示すための要素である。summary要素で示された内容は、ディスクロージャーウィジェットが開いても開いてなくても表示される。\n使用例\n\u0026lt;details\u0026gt; \u0026lt;summary\u0026gt;リスト\u0026lt;/summary\u0026gt; \u0026lt;p\u0026gt;その１\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;その２\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;その３\u0026lt;/p\u0026gt; \u0026lt;/details\u0026gt;  表示例\n  リスト その１\nその２\nその３\n \niframe要素 iframe要素は、文書の中で別の文書を表示する領域(ブラウジングコンテキスト)を示す要素である。\n使用する主な属性は以下の通り。\n・ src ・・・　 表示させる文書のアドレス  ・ srcdoc ・・・　 表示させるHTMLデータ   ・ name ・・・　 表示させる領域の名前   ・ width ・・・　 横   ・ height ・・・　 縦   使用例を以下に示す。\n\u0026lt;iframe width=\u0026quot;200\u0026quot; height=\u0026quot;150\u0026quot;\u0026gt; \u0026lt;/iframe\u0026gt;  表示例\n  \nhr要素 hr要素は区切りのための水平線を引く要素である。段落・話題・場面が変わるところなどで利用する。\n使用例\n\u0026lt;hr\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;hr\u0026gt;  表示例\n   script要素 script要素は、文書内に実行できるコードを組み込むための要素である。\nコードは要素内容として直接書くか、src属性にコードのアドレスを指定して読み込ませる。\nnoscript要素 noscript要素は、script要素で組み込んだコード(スクリプト)が無効であった場合に利用される要素である。\nよって、コード(スクリプト)が有効なときには、この要素は実行されない。\ntemplate要素 template要素は、その部分がコードによって挿入される部分であることを示す。\ncanvas要素 canvas要素は、コードによって図を描画したいときに利用する要素である。\nこれとは別に描画を行うコード(JavaScriptなど)を用意し、それにより描画されたビットマップイメージが入る。\ncanvas要素が実行できない環境では、要素内容に指定した内容が表示される。\n(以上、使用例はjsやれるようになったらやります・・・)\n"},{"idx":46,"href":"/docs/front-end/css_animation/","title":"アニメーション","content":" CSSのアニメーション CSSで行えるアニメーションについてを述べる。\n回転・拡大縮小・移動 ボックスを回転・拡大縮小・移動などさせるプロパティについてを述べる。\ntransformプロパティ transformプロパティは、ボックスを回転・拡大縮小・移動・変形を行うプロパティである。\n 値 意味   none 変形しない   rotate(角度) 指定した数値分、時計回りに回転させる   scale(数値,数値) 指定した数値分、横方向、縦方向の順に拡大縮小する   scaleX(数値) 指定した数値分、横方向に拡大縮小する   scaleY(数値) 指定した数値分、縱方向に拡大縮小する   translate(単位付きの数値,単位付きの数値) 指定した数値分、右方向、下方向の順に移動する   translateX(単位付きの数値) 指定した数値分、右方向の順に移動する   translateY(単位付きの数値) 指定した数値分、下方向の順に移動する   skew(角度) 指定した数値分、x軸に沿った角度、y軸に沿った角度分、傾斜させる   skewX(角度) 指定した数値分、x軸に沿った分傾斜させる   skewY(角度) 指定した数値分、y軸に沿った分傾斜させる   ここで、角度とは数値に以下の単位をつけたものである。\n 値 意味   deg 度   grad グラード(円周の1/400を1とする単位)   rad ラジアン   turn ターン(円周を1とする単位)   使用例\n\u0026lt;p style=\u0026quot;background-color:red; width:200px; height:200px;\u0026quot;\u0026gt;０度\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026quot;background-color:red; width:200px; height:200px; transform:rotate(30deg)\u0026quot;\u0026gt;３０度\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026quot;background-color:red; width:200px; height:200px; transform:rotate(45deg)\u0026quot;\u0026gt;４５度\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026quot;background-color:red; width:200px; height:200px; transform:rotate(90deg)\u0026quot;\u0026gt;９０度\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026quot;background-color:green; width:200px; height:200px;\u0026quot;\u0026gt;０度\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026quot;background-color:green; width:200px; height:200px; transform:skewX(30deg);\u0026quot;\u0026gt;３０度\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026quot;background-color:green; width:200px; height:200px; transform:skewX(45deg);\u0026quot;\u0026gt;４５度\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026quot;background-color:green; width:200px; height:200px; transform:skewX(60deg);\u0026quot;\u0026gt;６０度\u0026lt;/p\u0026gt;  表示例\n ０度\n３０度\n４５度\n９０度\n０度\n３０度\n４５度\n６０度\n\ntransform-originプロパティ transform-originプロパティは、transformプロパティでボックスを回転・移動・変形させる時に、原点とする位置を設定するプロパティである。\n指定する値と意味は以下の通り。なお、値は1~3つまで指定出来る。1つ目は横方向の左からの位置、2つ目は縦方向の上からの位置、3つ目は3D用のz方向の位置を示す。\n 値 意味   単位付きの数値 ボックスの左上からの距離   パーセンテージ ボックスの大きさに対するパーセンテージ   top 縦方向の0%   bottom 縦方向の100%   center 縦方向の50%/横方向の50%   left 横方向の0%   right 横方向の100%   使用例\n\u0026lt;div style=\u0026quot;border-style: double; height: 100px; width: 100px; padding: 0px; margin:0px\u0026quot;\u0026gt; \u0026lt;p style=\u0026quot;background-color:red; width:95px; height:95px; padding:0px; margin:0px; transform:rotate(45deg);\u0026quot;\u0026gt;center center(デフォルト)を中心に45度回転\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;br\u0026gt; \u0026lt;br\u0026gt; \u0026lt;div style=\u0026quot;border-style: double; height: 100px; width: 100px; padding: 0px; margin:0px\u0026quot;\u0026gt; \u0026lt;p style=\u0026quot;background-color:red; width:95px; height:95px; padding:0px; margin:0px; transform:rotate(45deg); transform-origin:right bottom;\u0026quot;\u0026gt;right bottom(右下)を中心に45度回転\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt;  表示例\n center center(デフォルト)を中心に45度回転\n right bottom(右下)を中心に45度回転\n \nトランジション 例えばセレクタの:hoverを使うとカーソルが上に来た時に、:activeを使うとクリックした時に、そこの表示が別の状態に切り替わる。その切り替わりを滑らかに変化させるのがCSSで言うトランジションである。\nトランジションは、ある状態から別のある状態へと移る二状態の変化を表現できる。このセクションでは、トランジションに関するプロパティについてを述べる。\ntransition-property プロパティ transition-propertyは、トランジションを適用するプロパティ名を指定するプロパティである(ややこしい・・)\n 値 意味   プロパティ名 アクション時にトランジションを適用したいプロパティ名。空白区切りで複数入力可   all トランジション適用可能な全てのプロパティに適用する   none 適用しない   (使用例は次にまとめる)\ntransition-duration プロパティ transition-durationプロパティは、トランジションをどれほどの時間をかけて実行するかを設定するプロパティである。\n値は単位付きの数値で、単位はs（秒）,ms（ミリ秒）のいずれかで指定する。\n使用例(css)\ndiv.duration { border-style: double; height: 100px; width: 100px; padding: 0px; margin:0px } p.sample1 { background-color:red; width:100px; height:100px; padding:0px; margin:0px; transition-property: transform; transition-duration: 5s; } p.sample1:hover{ transform:rotate(360deg); } p.sample2 { background-color:red; width:100px; height:100px; padding:0px; margin:0px; transition-property: background-color; transition-duration: 5s; } p.sample2:active{ background-color:yellow; } 使用例（html、コード載せると何故か変になる・・のでスクショを記載）\n表示例\n  \ntransition-timing-function プロパティ transition-timing-functionプロパティは、トランジションの速度を一定にしたり、変化をつけた速度に設定するプロパティである。\n指定する値と意味は以下の通り。\n 値 意味   ease 加速をつけて、ゆっくり始まり、ゆっくり終わる（デフォルト）   ease-in ゆっくり始まり、一定速度で終わる   ease-out 一定速度で始まり、ゆっくり終わる   ease-in-out ゆっくり始まり、ゆっくり終わる   linear 最初から最後まで一定速度   使用例（css）\ndiv.timing { border-style: double; height: 100px; width: 100px; padding: 0px; margin:0px } p.timing1 { background-color:red; width:100px; height:100px; padding:0px; margin:0px; transition-property: transform; transition-duration: 5s; transition-timing-function: ease; } p.timing2 { background-color:red; width:100px; height:100px; padding:0px; margin:0px; transition-property: background-color; transition-duration: 5s; transition-timing-function: linear; } p[class^=\u0026#34;timing\u0026#34;]:hover{ transform:rotate(360deg); } 使用例（html、スクショを記載）\n表示例\n  \ntransition-delay プロパティ transition-delayプロパティは、トランジションの開始を遅らせるプロパティである。\n値には、時間の単位をつけた数値を指定する。\n使用例（css）\ndiv.delay { border-style: double; height: 100px; width: 100px; padding: 0px; margin:0px } p.delay1 { background-color:red; width:100px; height:100px; padding:0px; margin:0px; transition-property: transform; transition-duration: 5s; } p.delay2 { background-color:red; width:100px; height:100px; padding:0px; margin:0px; transition-property: transform; transition-duration: 5s; transition-delay: 3s; } p[class^=\u0026#34;delay\u0026#34;]:hover{ transform:rotate(360deg); } 使用例（html、スクショを記載）\n表示例\n  \ntransition プロパティ transitionプロパティは、これまでのtransition関連のプロパティの値をまとめて指定出来るプロパティである。\n値は空白で区切って複数指定可能である。\n使用例（css）\np { background-color:red; width:100px; height:100px; padding:0px; margin:0px; transition: transform 5s linear; } p:hover{ transform:rotate(360deg); } （html）\n\u0026lt;p\u0026gt;カーソル乗せると一回転！(linear)\u0026lt;/p\u0026gt; 表示例\n  \nアニメーション CSSで言うアニメーションとは、トランジションを連続して行わせたような動きのことを言う。\nそれを実現するために、CSSではキーフレームという書式を使って表現する。\n@keyframes (キーフレーム) CSSのアニメーションでは、いつのタイミングでどのような動作をさせるかの指定を、キーフレームと呼ばれる書式で記述する。\n書式としては、まず最初に@keyframesと書き、その後にキーフレームの名前を書く。\nその後は中括弧{}で囲み、その中に動作させるタイミングを開始時を0%としたパーセンテージで指定して記載する。\nその後にまた中括弧{}を書いて囲み、その中に動作させる内容を記載させる、と言う書式である。\n@keyframe (キーフレームの名前) { 0% { プロパティ名: 値 ・・・ } 30% { プロパティ名: 値 ・・・ } ・・・ }  animation-name プロパティ animation-nameプロパティは、キーフレーム名を指定して実行させるためのプロパティである。\n（使用例は次節でまとめて記載）\nanimation-duration プロパティ animation-durationプロパティは、アニメーションの再生時間を設定するプロパティである。\n値は単位付きの数値で、単位はs（秒）,ms（ミリ秒）のいずれかで指定する。\n使用例（css）\n@keyframes key1 { 0%{ background-color:red; } 20%{ background-color:yellow; } 40%{ background-color:green; } 60%{ background-color:blue; } 80%{ background-color:purple; } 100%{ background-color:red; } } p { width:100px; height:100px; padding:0px; margin:0px; animation-name: key1; animation-duration: 30s; } 使用例（html）\n\u0026lt;p\u0026gt;色変化！（一回のみ）\u0026lt;/p\u0026gt; 表示例\n  \nanimation-timing-function プロパティ animation-timing-functionプロパティは、トランジションの時と同様に、アニメーションにおける速度を一定にしたり、変化をつけた速度に設定するプロパティである。\n指定する値と意味は以下の通り。\n 値 意味   ease 加速をつけて、ゆっくり始まり、ゆっくり終わる（デフォルト）   ease-in ゆっくり始まり、一定速度で終わる   ease-out 一定速度で始まり、ゆっくり終わる   ease-in-out ゆっくり始まり、ゆっくり終わる   linear 最初から最後まで一定速度   使用例（css）\n@keyframes key1 { 0%{ transform: translate(0px,0px); } 25%{ transform: translate(200px,0px) rotate(90deg); } 50%{ transform: translate(200px,200px) rotate(180deg); } 75%{ transform: translate(0px,200px) rotate(270deg); } 100%{ transform: translate(0px,0px) rotate(360deg); } } p { width:100px; height:100px; padding:0px; margin:0px; background-color:red; animation-name: key1; animation-duration: 30s; animation-timing-function: linear; } 使用例（html）\n\u0026lt;p\u0026gt;一回転！（一回のみ）\u0026lt;/p\u0026gt;  表示例\n  \nanimation-delayプロパティ animation-delayプロパティは、アニメーションの開始を遅らせるプロパティである。\n値は単位付きの数値で、単位はs（秒）,ms（ミリ秒）のいずれかで指定する。\n使用例（css）\n@keyframes key1 { 0%{ transform: translate(0px,0px); } 25%{ transform: translate(200px,0px) rotate(90deg); } 50%{ transform: translate(200px,200px) rotate(180deg); } 75%{ transform: translate(0px,200px) rotate(270deg); } 100%{ transform: translate(0px,0px) rotate(360deg); } } p { width:100px; height:100px; padding:0px; margin:0px; background-color:red; animation-name: key1; animation-duration: 30s; animation-timing-function: linear; animation-delay: 5s; } 使用例（html）\n\u0026lt;p\u0026gt;5秒後に一回転！（一回のみ）\u0026lt;/p\u0026gt;  表示例\n  \nanimation-iteration-countプロパティ animation-iteration-countプロパティは、アニメーションを何回繰り返して再生させるかを設定するプロパティである。\n 値 意味   数値 再生する回数   infinite 無限に繰り返す   使用例（css）\n@keyframes key1 { 0%{ transform: translate(0px,0px); } 25%{ transform: translate(200px,0px) rotate(90deg); } 50%{ transform: translate(200px,200px) rotate(180deg); } 75%{ transform: translate(0px,200px) rotate(270deg); } 100%{ transform: translate(0px,0px) rotate(360deg); } } p { width:100px; height:100px; padding:0px; margin:0px; background-color:red; animation-name: key1; animation-duration: 10s; animation-timing-function: linear; animation-iteration-count: infinite; } 使用例（html）\n\u0026lt;p\u0026gt;無限に一回転！\u0026lt;/p\u0026gt;  表示例\n  \nanimation-direction プロパティ animation-directionプロパティは、再生・逆再生の指定を行えるプロパティである。\n指定する値と意味は以下の通り。\n 値 意味   normal キーフレーム通りに再生   reverse キーフレームの逆順に再生する   alternate 再生と逆再生を繰り返して行う   alternate-reverse 逆再生と再生を繰り返して行う   使用例（css）\n@keyframes key1 { 0%{ transform: translate(0px,0px); } 25%{ transform: translate(200px,0px) rotate(90deg); } 50%{ transform: translate(200px,200px) rotate(180deg); } 75%{ transform: translate(0px,200px) rotate(270deg); } 100%{ transform: translate(0px,0px) rotate(360deg); } } p { width:100px; height:100px; padding:0px; margin:0px; background-color:red; animation-name: key1; animation-duration: 10s; animation-timing-function: linear; animation-iteration-count: infinite; animation-direction: alternate; } 使用例（html）\n\u0026lt;p\u0026gt;alternate:右回転と左回転順々\u0026lt;/p\u0026gt;  表示例\n  \nanimation-play-state プロパティ animation-play-stateプロパティは、アニメーションの再生を一時停止させる際に使用するプロパティである。\n指定する値と意味は以下の通り。\n 値 意味   running アニメーションを再生する   paused アニメーションを一時停止させる   使用例（css）\n@keyframes key1 { 0%{ transform: translate(0px,0px); } 25%{ transform: translate(200px,0px) rotate(90deg); } 50%{ transform: translate(200px,200px) rotate(180deg); } 75%{ transform: translate(0px,200px) rotate(270deg); } 100%{ transform: translate(0px,0px) rotate(360deg); } } p { width:100px; height:100px; padding:0px; margin:0px; background-color:red; animation-name: key1; animation-duration: 10s; animation-timing-function: linear; animation-iteration-count: infinite; animation-direction: alternate; animation-play-state: paused; } 使用例（html）\n\u0026lt;p\u0026gt;alternate:右回転と左回転順々せずにポーズ状態\u0026lt;/p\u0026gt;  表示例\n  \nanimation-fill-modeプロパティ animation-fill-modeプロパティは、animation-delayプロパティによって再生が遅延されている間の表示、及び再生終了時の表示を設定するプロパティである。\n 値 意味   forwards 再生終了後はキーフレームの100%の表示のままにする   backwards 遅延して再生されてない間はキーフレームの0%の表示にする   both 再生終了後はキーフレームの100%、遅延して再生されてない間はキーフレームの0%の表示にする   none キーフレームとは無関係に表示する   使用例（css）\n@keyframes key1 { 0%{ background-color: black; color: white; transform: translate(0px,0px); } 25%{ background-color: red; color: white; transform: translate(200px,0px) rotate(90deg); } 50%{ background-color: yellow; color: white; transform: translate(200px,200px) rotate(180deg); } 75%{ background-color: green; color: white; transform: translate(0px,200px) rotate(270deg); } 100%{ background-color: white; color: black; transform: translate(0px,0px) rotate(360deg); } } p { width:100px; height:100px; padding:0px; margin:0px; animation-name: key1; animation-duration: 10s; animation-timing-function: linear; animation-delay: 10s; animation-fill-mode: both; } 使用例（html）\n\u0026lt;p\u0026gt;10秒後に開始・最後は白ボックスのまま\u0026lt;/p\u0026gt;  表示例\n  \nanimationプロパティ animationプロパティは、これまでのアニメーション関連のプロパティの値をまとめて指定出来るプロパティである。\n時間を表す値については、1つ目がanimation-durationプロパティ、2つ目がanimation-delayプロパティの値を示す。\n使用例（css）\n@keyframes key1 { 0%{ background-color: white; transform: translate(0px,0px); } 25%{ background-color: red; transform: translate(200px,0px) rotate(90deg); } 50%{ background-color: yellow; transform: translate(200px,200px) rotate(180deg); } 75%{ background-color: green; transform: translate(0px,200px) rotate(270deg); } 100%{ background-color: white; transform: translate(0px,0px) rotate(360deg); } } p { width:100px; height:100px; padding:0px; margin:0px; animation: key1 10s linear 10s infinite; } 使用例（html）\n\u0026lt;p\u0026gt;10秒後に開始して無限に一回転\u0026lt;/p\u0026gt;  表示例\n  \n"},{"idx":47,"href":"/docs/programming/class_func/object/","title":"オブジェクト(Javascript)","content":" オブジェクト(Javascript) Javascriptのオブジェクトについて。\nJavascriptでは、オブジェクトと呼ばれる、C言語などの構造体のようなデータ構造が存在する。\nここではそれについて記載する。\nオブジェクトの定義 Javascript  Javascriptでのオブジェクトは、以下のような方法で記載する。\n記法\nvar 変数名 = { (key名1) : (value名1), (key名2) : (value名2), ・・・ }  このように、キーと値のセットを複数連ねたような構造になる。\nちなみに、オブジェクトではこのキーと値のセットのことをプロパティと呼んでいる。\n   プロパティの書き換え オブジェクト中のプロパティの値を書き換える方法についてを述べる。\nJavascript  Javascriptでのオブジェクトのプロパティの書き換えは、以下のような記法で行う。\n(オブジェクトの変数名).(変更したいプロパティのキー) = (書き換えたい値);     プロパティの追加 オブジェクトにプロパティを追加する方法についてを述べる。\nJavascript  Javascriptでのオブジェクトのプロパティの追加は、以下のような記法で行う。\n(オブジェクトの変数名).(追加したいプロパティのキー) = (追加したい値);  要はプロパティの書き換えと同じ。\n   thisキーワード Javascript  thisキーワードは、オブジェクト内でオブジェクトのプロパティを参照するときに用いる。\n但し、オブジェクトを参照するのは、thisがメソッドとして使用された場合に限るので注意。\nvar 変数名 = { (key名1) : (value名1), (key名2) : (value名2), ・・・ (key名) : function(){ //メソッド this.key名1 //これでvalue名1が参照できる } }    "},{"idx":48,"href":"/docs/programming/machine_learning/overfitting/","title":"オーバーフィッティング(過学習)","content":" オーバーフィッティング(過学習) 先述の線形基底関数モデルにおいて、Mの値を大きくすればするほど、誤差が小さくなるような予測式が得られる事が解った。\nしかし、ここで誤差が小さくなるというのは既に入力している入力値・実測値に対してであり、未知の入力値に対しても精度の高い予測値が得られるか？ということを考えると、上図でより高いMで算出した予測式では精度が悪くなるだろうというのは明らかである。\nこのように、既知の入力値に対しては高精度だが、未知の入力値に対しては精度が悪い(汎用能力が低い)状態のことを過学習(オーバーフィッティング)という。\nでは過学習の状態まで至らず、汎用能力も高くなるような最適なMの値を求めるにはどうしたら良いのだろうか？\nその方法について次章から述べていく。\n"},{"idx":49,"href":"/docs/programming/math/gauss/","title":"ガウス関数","content":" ガウス関数 Python  ガウス関数は以下の式で表される関数である。\n a exp  ( -     (x - \u0026mu; )  2     \u0026sigma; 2    )   ここで、式中の変数は以下の意味を持つ。\n μ：中心(平均) σ：標準偏差 a：高さ(係数)  ここで、  a =  1   2 \u0026pi;  σ 2      とした時、xで積分すると1になるため、確率密度関数としても使われる。\n例として、a=1,μ=0,σ=1とした時のガウス関数を示す。\n\u0026gt;\u0026gt;\u0026gt; import numpy as np \u0026gt;\u0026gt;\u0026gt; import matplotlib.pyplot as plt \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #ガウス関数 \u0026gt;\u0026gt;\u0026gt; def gauss(a,mu,sigma): ... return a * np.exp( -(x-mu)**2 / sigma**2 ) ... \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; x=np.linspace(-3,3,100) \u0026gt;\u0026gt;\u0026gt; plt.plot(x,gauss(1,0,1),\u0026#39;black\u0026#39;,linewidth=3) [\u0026lt;matplotlib.lines.Line2D object at 0x11740d908\u0026gt;] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; plt.ylim(-0.5,1.5) (-0.5, 1.5) \u0026gt;\u0026gt;\u0026gt; plt.xlim(-3,3) (-3, 3) \u0026gt;\u0026gt;\u0026gt; plt.grid(True) \u0026gt;\u0026gt;\u0026gt; plt.show() \u0026gt;\u0026gt;\u0026gt;  実行結果\n  "},{"idx":50,"href":"/docs/programming/math/gauss_2D/","title":"ガウス関数(2次元)","content":" ガウス関数(2次元) Python  ガウス関数\n a exp  ( -     (x - \u0026mu; )  2     \u0026sigma; 2    )   において、入力xを2次元ベクトルとした時の場合を考える。(以下)\n x =     x 0       x 1       この時、μも入力x0、x1の中心(平均)である要素μ0、μ1を持つベクトルを作成する。\n \u0026mu; =     \u0026mu; 0       \u0026mu; 1       また、分散(標準偏差)σに関しては、ベクトルの要素間の分散である共分散行列を用いる。\n今回の2変数の場合だと以下のようになる。\n \u0026Sigma; =     \u0026sigma; 00     \u0026sigma; 01       \u0026sigma; 10     \u0026sigma; 11       σijはxの要素xi、xjの分散であり、σij = σji である。\nこれらを利用し、2次元でのガウス関数は以下のようになる。\n y = a exp  { -   1   2     ( x - \u0026mu; )  T   \u0026Sigma; -1   ( x - \u0026mu; )  }   このガウス関数をPythonで実装した例を以下に示す。\ndef gauss(a, x, mu, sigma):    "},{"idx":51,"href":"/docs/cloud/aws/aws_index/","title":"クラウド(AWS)","content":" クラウド(AWS) AWSについてのまとめ。\n ハンズオン  DynamoDBテーブルの作成方法 Lambda関数の作成方法 API GatewayでのAPI作成方法    "},{"idx":52,"href":"/docs/programming/class_func/class/","title":"クラスの定義","content":" クラスの定義 クラスを定義する方法についてを示す。\nJava  Javaでのクラス定義方法は以下の通り。\n[public] class クラス名 [extends 継承元クラス名] [implements 実装先インタフェース名]{ //文 }  あるクラスを継承して作りたい時はクラス名の後にextendsを、インタフェースを実装する時はその後にimplementsを書き加える。\n Python  Pythonでのクラスを定義するときの記法は以下の通り。\nclass クラス名: //文    "},{"idx":53,"href":"/docs/programming/machine_learning/clustering/","title":"クラスタリング","content":" クラスタリング 教師あり学習の分類では、入力データに対し分類後のクラス(カテゴリ)が与えられていたが、ここでは入力データからデータをクラスに分類していくことを考える。この手法をクラスタリングという。\n教師あり学習で利用した２次元入力のデータを見てみよう。図示したものを以下に記載する。なお、今回は教師なし学習のため、目標値は利用しない。\nこのデータから、データの似ている者同士を同じクラスとして分類していくことがクラスタリングである。\nクラスタリングの手法としてはいくつか存在する。まずはK-means法についてを次章で説明する。\n"},{"idx":54,"href":"/docs/programming/class_func/classfunc_index/","title":"クラス・関数(メソッド)","content":" クラス・関数(メソッド) クラス及び関数（メソッド）の定義についてを示す。 これも言語によって違う名前で呼ばれているものもあるので注意。 C言語では構造体、JavaScriptではオブジェクト(プロパティ)と言った名前のデータ構造もクラスに近いため、ここでは一緒の項としてまとめておく（これらを似た構造としてひとまとめにする事に否定的な意見もあるかもしれないが）\n クラス  クラスの定義 フィールド(クラス変数・インスタンス変数) コンストラクタ(__init__) 継承 多重継承  関数  関数(メソッド)の定義 (Python)引数のデフォルト値 可変長引数の関数 匿名（無名）クラス ラムダ式（無名関数）  構造体、オブジェクト  オブジェクト(Javascript)   "},{"idx":55,"href":"/docs/programming/graph/grid/","title":"グラフにグリッド線を表示させる","content":" グラフにグリッド線を表示させる Python  グラフにグリッド線(方眼)を表示するにはpyplotの関数grid()を利用する。引数にはTrueを入れる。\n例として、前述のグラフに色をつけるで作成したグラフにグリッド線を表示させた例を示す。\n\u0026gt;\u0026gt;\u0026gt; import numpy as np \u0026gt;\u0026gt;\u0026gt; import matplotlib.pyplot as plt \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; def f(x,w): ... return (x-w)*x*(x+w) ... \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; x = np.linspace(-3,3,61) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #y:f(x) = x**3、w=0という凡例をつける \u0026gt;\u0026gt;\u0026gt; y = f(x,0) \u0026gt;\u0026gt;\u0026gt; plt.plot(x,y,color=\u0026#39;black\u0026#39;,label=\u0026#39;$w=0$\u0026#39;) [\u0026lt;matplotlib.lines.Line2D object at 0x118e0b748\u0026gt;] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #y2:f(x) = (x-2)x(x+2)、w=2という凡例をつける \u0026gt;\u0026gt;\u0026gt; y2 = f(x,2) \u0026gt;\u0026gt;\u0026gt; plt.plot(x,y2,color=\u0026#39;red\u0026#39;,label=\u0026#39;$w=2$\u0026#39;) [\u0026lt;matplotlib.lines.Line2D object at 0x118e0bb38\u0026gt;] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #凡例表示 \u0026gt;\u0026gt;\u0026gt; plt.legend(loc=\u0026#34;best\u0026#34;) \u0026lt;matplotlib.legend.Legend object at 0x1165a8048\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #タイトル設定 \u0026gt;\u0026gt;\u0026gt; plt.title(\u0026#39;$f_w(x)$\u0026#39;) Text(0.5, 1.0, \u0026#39;$f_w(x)$\u0026#39;) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #x軸にラベル表示 \u0026gt;\u0026gt;\u0026gt; plt.xlabel(\u0026#39;x\u0026#39;) Text(0.5, 0, \u0026#39;x\u0026#39;) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #y軸にラベル表示 \u0026gt;\u0026gt;\u0026gt; plt.ylabel(\u0026#39;y\u0026#39;) Text(0, 0.5, \u0026#39;y\u0026#39;) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #グラフにグリッド線表示 \u0026gt;\u0026gt;\u0026gt; plt.grid(True) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #グラフ表示 \u0026gt;\u0026gt;\u0026gt; plt.show() \u0026gt;\u0026gt;\u0026gt;  実行結果\n  "},{"idx":56,"href":"/docs/programming/graph/color/","title":"グラフに色をつける","content":" グラフに色をつける Python  グラフに色をつけて表示させるには、グラフを表示するときに使ったpyplotの関数plotの引数にcolorというパラメータがあるので、そこに指定したい色を入力する。\n色以外にもplotには多くのパラメータが定義されている。詳しくは以下の公式レファレンスを参照する。\n pyplot.plot  実行例を以下に示す。\n\u0026gt;\u0026gt;\u0026gt; import numpy as np \u0026gt;\u0026gt;\u0026gt; import matplotlib.pyplot as plt \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #関数定義 \u0026gt;\u0026gt;\u0026gt; def f(x,w): ... return (x-w)*x*(x+w) ... \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; x = np.linspace(-3,3,61) \u0026gt;\u0026gt;\u0026gt; x array([-3. , -2.9, -2.8, -2.7, -2.6, -2.5, -2.4, -2.3, -2.2, -2.1, -2. , -1.9, -1.8, -1.7, -1.6, -1.5, -1.4, -1.3, -1.2, -1.1, -1. , -0.9, -0.8, -0.7, -0.6, -0.5, -0.4, -0.3, -0.2, -0.1, 0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1. , 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2. , 2.1, 2.2, 2.3, 2.4, 2.5, 2.6, 2.7, 2.8, 2.9, 3. ]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #y:f(x) = x**3 \u0026gt;\u0026gt;\u0026gt; y = f(x,0) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #y2:f(x) = (x-2)x(x+2) \u0026gt;\u0026gt;\u0026gt; y2 = f(x,2) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #yは黒い線で描画 \u0026gt;\u0026gt;\u0026gt; plt.plot(x,y,color=\u0026#39;black\u0026#39;) [\u0026lt;matplotlib.lines.Line2D object at 0x10d76c320\u0026gt;] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #y2は赤い線で描画 \u0026gt;\u0026gt;\u0026gt; plt.plot(x,y2,color=\u0026#39;red\u0026#39;) [\u0026lt;matplotlib.lines.Line2D object at 0x10ea1f4e0\u0026gt;] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #グラフ表示 \u0026gt;\u0026gt;\u0026gt; plt.show() \u0026gt;\u0026gt;\u0026gt;  実行結果\n因みに、colorに指定できる値はmatplotlib.colors.cnamesで確認することができる。\n\u0026gt;\u0026gt;\u0026gt; import matplotlib \u0026gt;\u0026gt;\u0026gt; matplotlib.colors.cnames {\u0026#39;aliceblue\u0026#39;: \u0026#39;#F0F8FF\u0026#39;, \u0026#39;antiquewhite\u0026#39;: \u0026#39;#FAEBD7\u0026#39;, \u0026#39;aqua\u0026#39;: \u0026#39;#00FFFF\u0026#39;, \u0026#39;aquamarine\u0026#39;: \u0026#39;#7FFFD4\u0026#39;, \u0026#39;azure\u0026#39;: \u0026#39;#F0FFFF\u0026#39;, \u0026#39;beige\u0026#39;: \u0026#39;#F5F5DC\u0026#39;, \u0026#39;bisque\u0026#39;: \u0026#39;#FFE4C4\u0026#39;, \u0026#39;black\u0026#39;: \u0026#39;#000000\u0026#39;, \u0026#39;blanchedalmond\u0026#39;: \u0026#39;#FFEBCD\u0026#39;, \u0026#39;blue\u0026#39;: \u0026#39;#0000FF\u0026#39;, \u0026#39;blueviolet\u0026#39;: \u0026#39;#8A2BE2\u0026#39;, \u0026#39;brown\u0026#39;: \u0026#39;#A52A2A\u0026#39;, \u0026#39;burlywood\u0026#39;: \u0026#39;#DEB887\u0026#39;, \u0026#39;cadetblue\u0026#39;: \u0026#39;#5F9EA0\u0026#39;, \u0026#39;chartreuse\u0026#39;: \u0026#39;#7FFF00\u0026#39;, \u0026#39;chocolate\u0026#39;: \u0026#39;#D2691E\u0026#39;, \u0026#39;coral\u0026#39;: \u0026#39;#FF7F50\u0026#39;, \u0026#39;cornflowerblue\u0026#39;: \u0026#39;#6495ED\u0026#39;, \u0026#39;cornsilk\u0026#39;: \u0026#39;#FFF8DC\u0026#39;, \u0026#39;crimson\u0026#39;: \u0026#39;#DC143C\u0026#39;, \u0026#39;cyan\u0026#39;: \u0026#39;#00FFFF\u0026#39;, \u0026#39;darkblue\u0026#39;: \u0026#39;#00008B\u0026#39;, \u0026#39;darkcyan\u0026#39;: \u0026#39;#008B8B\u0026#39;, \u0026#39;darkgoldenrod\u0026#39;: \u0026#39;#B8860B\u0026#39;, \u0026#39;darkgray\u0026#39;: \u0026#39;#A9A9A9\u0026#39;, \u0026#39;darkgreen\u0026#39;: \u0026#39;#006400\u0026#39;, \u0026#39;darkgrey\u0026#39;: \u0026#39;#A9A9A9\u0026#39;, \u0026#39;darkkhaki\u0026#39;: \u0026#39;#BDB76B\u0026#39;, \u0026#39;darkmagenta\u0026#39;: \u0026#39;#8B008B\u0026#39;, \u0026#39;darkolivegreen\u0026#39;: \u0026#39;#556B2F\u0026#39;, \u0026#39;darkorange\u0026#39;: \u0026#39;#FF8C00\u0026#39;, \u0026#39;darkorchid\u0026#39;: \u0026#39;#9932CC\u0026#39;, \u0026#39;darkred\u0026#39;: \u0026#39;#8B0000\u0026#39;, \u0026#39;darksalmon\u0026#39;: \u0026#39;#E9967A\u0026#39;, \u0026#39;darkseagreen\u0026#39;: \u0026#39;#8FBC8F\u0026#39;, \u0026#39;darkslateblue\u0026#39;: \u0026#39;#483D8B\u0026#39;, \u0026#39;darkslategray\u0026#39;: \u0026#39;#2F4F4F\u0026#39;, \u0026#39;darkslategrey\u0026#39;: \u0026#39;#2F4F4F\u0026#39;, \u0026#39;darkturquoise\u0026#39;: \u0026#39;#00CED1\u0026#39;, \u0026#39;darkviolet\u0026#39;: \u0026#39;#9400D3\u0026#39;, \u0026#39;deeppink\u0026#39;: \u0026#39;#FF1493\u0026#39;, \u0026#39;deepskyblue\u0026#39;: \u0026#39;#00BFFF\u0026#39;, \u0026#39;dimgray\u0026#39;: \u0026#39;#696969\u0026#39;, \u0026#39;dimgrey\u0026#39;: \u0026#39;#696969\u0026#39;, \u0026#39;dodgerblue\u0026#39;: \u0026#39;#1E90FF\u0026#39;, \u0026#39;firebrick\u0026#39;: \u0026#39;#B22222\u0026#39;, \u0026#39;floralwhite\u0026#39;: \u0026#39;#FFFAF0\u0026#39;, \u0026#39;forestgreen\u0026#39;: \u0026#39;#228B22\u0026#39;, \u0026#39;fuchsia\u0026#39;: \u0026#39;#FF00FF\u0026#39;, \u0026#39;gainsboro\u0026#39;: \u0026#39;#DCDCDC\u0026#39;, \u0026#39;ghostwhite\u0026#39;: \u0026#39;#F8F8FF\u0026#39;, \u0026#39;gold\u0026#39;: \u0026#39;#FFD700\u0026#39;, \u0026#39;goldenrod\u0026#39;: \u0026#39;#DAA520\u0026#39;, \u0026#39;gray\u0026#39;: \u0026#39;#808080\u0026#39;, \u0026#39;green\u0026#39;: \u0026#39;#008000\u0026#39;, \u0026#39;greenyellow\u0026#39;: \u0026#39;#ADFF2F\u0026#39;, \u0026#39;grey\u0026#39;: \u0026#39;#808080\u0026#39;, \u0026#39;honeydew\u0026#39;: \u0026#39;#F0FFF0\u0026#39;, \u0026#39;hotpink\u0026#39;: \u0026#39;#FF69B4\u0026#39;, \u0026#39;indianred\u0026#39;: \u0026#39;#CD5C5C\u0026#39;, \u0026#39;indigo\u0026#39;: \u0026#39;#4B0082\u0026#39;, \u0026#39;ivory\u0026#39;: \u0026#39;#FFFFF0\u0026#39;, \u0026#39;khaki\u0026#39;: \u0026#39;#F0E68C\u0026#39;, \u0026#39;lavender\u0026#39;: \u0026#39;#E6E6FA\u0026#39;, \u0026#39;lavenderblush\u0026#39;: \u0026#39;#FFF0F5\u0026#39;, \u0026#39;lawngreen\u0026#39;: \u0026#39;#7CFC00\u0026#39;, \u0026#39;lemonchiffon\u0026#39;: \u0026#39;#FFFACD\u0026#39;, \u0026#39;lightblue\u0026#39;: \u0026#39;#ADD8E6\u0026#39;, \u0026#39;lightcoral\u0026#39;: \u0026#39;#F08080\u0026#39;, \u0026#39;lightcyan\u0026#39;: \u0026#39;#E0FFFF\u0026#39;, \u0026#39;lightgoldenrodyellow\u0026#39;: \u0026#39;#FAFAD2\u0026#39;, \u0026#39;lightgray\u0026#39;: \u0026#39;#D3D3D3\u0026#39;, \u0026#39;lightgreen\u0026#39;: \u0026#39;#90EE90\u0026#39;, \u0026#39;lightgrey\u0026#39;: \u0026#39;#D3D3D3\u0026#39;, \u0026#39;lightpink\u0026#39;: \u0026#39;#FFB6C1\u0026#39;, \u0026#39;lightsalmon\u0026#39;: \u0026#39;#FFA07A\u0026#39;, \u0026#39;lightseagreen\u0026#39;: \u0026#39;#20B2AA\u0026#39;, \u0026#39;lightskyblue\u0026#39;: \u0026#39;#87CEFA\u0026#39;, \u0026#39;lightslategray\u0026#39;: \u0026#39;#778899\u0026#39;, \u0026#39;lightslategrey\u0026#39;: \u0026#39;#778899\u0026#39;, \u0026#39;lightsteelblue\u0026#39;: \u0026#39;#B0C4DE\u0026#39;, \u0026#39;lightyellow\u0026#39;: \u0026#39;#FFFFE0\u0026#39;, \u0026#39;lime\u0026#39;: \u0026#39;#00FF00\u0026#39;, \u0026#39;limegreen\u0026#39;: \u0026#39;#32CD32\u0026#39;, \u0026#39;linen\u0026#39;: \u0026#39;#FAF0E6\u0026#39;, \u0026#39;magenta\u0026#39;: \u0026#39;#FF00FF\u0026#39;, \u0026#39;maroon\u0026#39;: \u0026#39;#800000\u0026#39;, \u0026#39;mediumaquamarine\u0026#39;: \u0026#39;#66CDAA\u0026#39;, \u0026#39;mediumblue\u0026#39;: \u0026#39;#0000CD\u0026#39;, \u0026#39;mediumorchid\u0026#39;: \u0026#39;#BA55D3\u0026#39;, \u0026#39;mediumpurple\u0026#39;: \u0026#39;#9370DB\u0026#39;, \u0026#39;mediumseagreen\u0026#39;: \u0026#39;#3CB371\u0026#39;, \u0026#39;mediumslateblue\u0026#39;: \u0026#39;#7B68EE\u0026#39;, \u0026#39;mediumspringgreen\u0026#39;: \u0026#39;#00FA9A\u0026#39;, \u0026#39;mediumturquoise\u0026#39;: \u0026#39;#48D1CC\u0026#39;, \u0026#39;mediumvioletred\u0026#39;: \u0026#39;#C71585\u0026#39;, \u0026#39;midnightblue\u0026#39;: \u0026#39;#191970\u0026#39;, \u0026#39;mintcream\u0026#39;: \u0026#39;#F5FFFA\u0026#39;, \u0026#39;mistyrose\u0026#39;: \u0026#39;#FFE4E1\u0026#39;, \u0026#39;moccasin\u0026#39;: \u0026#39;#FFE4B5\u0026#39;, \u0026#39;navajowhite\u0026#39;: \u0026#39;#FFDEAD\u0026#39;, \u0026#39;navy\u0026#39;: \u0026#39;#000080\u0026#39;, \u0026#39;oldlace\u0026#39;: \u0026#39;#FDF5E6\u0026#39;, \u0026#39;olive\u0026#39;: \u0026#39;#808000\u0026#39;, \u0026#39;olivedrab\u0026#39;: \u0026#39;#6B8E23\u0026#39;, \u0026#39;orange\u0026#39;: \u0026#39;#FFA500\u0026#39;, \u0026#39;orangered\u0026#39;: \u0026#39;#FF4500\u0026#39;, \u0026#39;orchid\u0026#39;: \u0026#39;#DA70D6\u0026#39;, \u0026#39;palegoldenrod\u0026#39;: \u0026#39;#EEE8AA\u0026#39;, \u0026#39;palegreen\u0026#39;: \u0026#39;#98FB98\u0026#39;, \u0026#39;paleturquoise\u0026#39;: \u0026#39;#AFEEEE\u0026#39;, \u0026#39;palevioletred\u0026#39;: \u0026#39;#DB7093\u0026#39;, \u0026#39;papayawhip\u0026#39;: \u0026#39;#FFEFD5\u0026#39;, \u0026#39;peachpuff\u0026#39;: \u0026#39;#FFDAB9\u0026#39;, \u0026#39;peru\u0026#39;: \u0026#39;#CD853F\u0026#39;, \u0026#39;pink\u0026#39;: \u0026#39;#FFC0CB\u0026#39;, \u0026#39;plum\u0026#39;: \u0026#39;#DDA0DD\u0026#39;, \u0026#39;powderblue\u0026#39;: \u0026#39;#B0E0E6\u0026#39;, \u0026#39;purple\u0026#39;: \u0026#39;#800080\u0026#39;, \u0026#39;rebeccapurple\u0026#39;: \u0026#39;#663399\u0026#39;, \u0026#39;red\u0026#39;: \u0026#39;#FF0000\u0026#39;, \u0026#39;rosybrown\u0026#39;: \u0026#39;#BC8F8F\u0026#39;, \u0026#39;royalblue\u0026#39;: \u0026#39;#4169E1\u0026#39;, \u0026#39;saddlebrown\u0026#39;: \u0026#39;#8B4513\u0026#39;, \u0026#39;salmon\u0026#39;: \u0026#39;#FA8072\u0026#39;, \u0026#39;sandybrown\u0026#39;: \u0026#39;#F4A460\u0026#39;, \u0026#39;seagreen\u0026#39;: \u0026#39;#2E8B57\u0026#39;, \u0026#39;seashell\u0026#39;: \u0026#39;#FFF5EE\u0026#39;, \u0026#39;sienna\u0026#39;: \u0026#39;#A0522D\u0026#39;, \u0026#39;silver\u0026#39;: \u0026#39;#C0C0C0\u0026#39;, \u0026#39;skyblue\u0026#39;: \u0026#39;#87CEEB\u0026#39;, \u0026#39;slateblue\u0026#39;: \u0026#39;#6A5ACD\u0026#39;, \u0026#39;slategray\u0026#39;: \u0026#39;#708090\u0026#39;, \u0026#39;slategrey\u0026#39;: \u0026#39;#708090\u0026#39;, \u0026#39;snow\u0026#39;: \u0026#39;#FFFAFA\u0026#39;, \u0026#39;springgreen\u0026#39;: \u0026#39;#00FF7F\u0026#39;, \u0026#39;steelblue\u0026#39;: \u0026#39;#4682B4\u0026#39;, \u0026#39;tan\u0026#39;: \u0026#39;#D2B48C\u0026#39;, \u0026#39;teal\u0026#39;: \u0026#39;#008080\u0026#39;, \u0026#39;thistle\u0026#39;: \u0026#39;#D8BFD8\u0026#39;, \u0026#39;tomato\u0026#39;: \u0026#39;#FF6347\u0026#39;, \u0026#39;turquoise\u0026#39;: \u0026#39;#40E0D0\u0026#39;, \u0026#39;violet\u0026#39;: \u0026#39;#EE82EE\u0026#39;, \u0026#39;wheat\u0026#39;: \u0026#39;#F5DEB3\u0026#39;, \u0026#39;white\u0026#39;: \u0026#39;#FFFFFF\u0026#39;, \u0026#39;whitesmoke\u0026#39;: \u0026#39;#F5F5F5\u0026#39;, \u0026#39;yellow\u0026#39;: \u0026#39;#FFFF00\u0026#39;, \u0026#39;yellowgreen\u0026#39;: \u0026#39;#9ACD32\u0026#39;} \u0026gt;\u0026gt;\u0026gt;  また基本色として定義されているのが以下の値。一文字でも、正式名でも良い。\n\u0026lsquo;b\u0026rsquo;:blue\n\u0026lsquo;g\u0026rsquo;:green\n\u0026lsquo;r\u0026rsquo;:red\n\u0026lsquo;c\u0026rsquo;:cyan\n\u0026rsquo;m\u0026rsquo;:magenta\n\u0026lsquo;y\u0026rsquo;:yellow\n\u0026lsquo;k\u0026rsquo;:black\n\u0026lsquo;w\u0026rsquo;:white\nこれ以外にカラーコード、CSSの色名もcolorに指定できる。\n  "},{"idx":57,"href":"/docs/programming/graph/title/","title":"グラフのタイトルを設定する","content":" グラフのタイトルを設定する Python  グラフのタイトルを設定、表示するにはpyplotの関数title()を利用する。\n例として、前述のグラフに色をつけるで作成したグラフにタイトルを設定した例を示す。\n\u0026gt;\u0026gt;\u0026gt; import numpy as np \u0026gt;\u0026gt;\u0026gt; import matplotlib.pyplot as plt \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; def f(x,w): ... return (x-w)*x*(x+w) ... \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; x = np.linspace(-3,3,61) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #y:f(x) = x**3、w=0という凡例をつける \u0026gt;\u0026gt;\u0026gt; y = f(x,0) \u0026gt;\u0026gt;\u0026gt; plt.plot(x,y,color=\u0026#39;black\u0026#39;,label=\u0026#39;$w=0$\u0026#39;) [\u0026lt;matplotlib.lines.Line2D object at 0x118e0b748\u0026gt;] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #y2:f(x) = (x-2)x(x+2)、w=2という凡例をつける \u0026gt;\u0026gt;\u0026gt; y2 = f(x,2) \u0026gt;\u0026gt;\u0026gt; plt.plot(x,y2,color=\u0026#39;red\u0026#39;,label=\u0026#39;$w=2$\u0026#39;) [\u0026lt;matplotlib.lines.Line2D object at 0x118e0bb38\u0026gt;] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #凡例表示 \u0026gt;\u0026gt;\u0026gt; plt.legend(loc=\u0026#34;best\u0026#34;) \u0026lt;matplotlib.legend.Legend object at 0x1165a8048\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #タイトル設定 \u0026gt;\u0026gt;\u0026gt; plt.title(\u0026#39;$f_w(x)$\u0026#39;) Text(0.5, 1.0, \u0026#39;$f_w(x)$\u0026#39;) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #グラフ表示 \u0026gt;\u0026gt;\u0026gt; plt.show() \u0026gt;\u0026gt;\u0026gt;  実行結果\n  "},{"idx":58,"href":"/docs/programming/graph/legend/","title":"グラフの凡例を表示する","content":" グラフの凡例を表示する Python  グラフに凡例を表示させるには、まずグラフを表示するときに使ったpyplotの関数plotの引数にlabelというパラメータがあるので、そこに指定する。\n凡例をグラフのどこに表示するかは自動で決まるが、こちらで指定したい場合はplotの関数legendを利用する。\n例として、前述のグラフに色をつけるで作成したグラフに凡例を表示する例を示す。\n\u0026gt;\u0026gt;\u0026gt; import numpy as np \u0026gt;\u0026gt;\u0026gt; import matplotlib.pyplot as plt \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; def f(x,w): ... return (x-w)*x*(x+w) ... \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; x = np.linspace(-3,3,61) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #y:f(x) = x**3、w=0という凡例をつける \u0026gt;\u0026gt;\u0026gt; y = f(x,0) \u0026gt;\u0026gt;\u0026gt; plt.plot(x,y,color=\u0026#39;black\u0026#39;,label=\u0026#39;$w=0$\u0026#39;) [\u0026lt;matplotlib.lines.Line2D object at 0x118e0b748\u0026gt;] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #y2:f(x) = (x-2)x(x+2)、w=2という凡例をつける \u0026gt;\u0026gt;\u0026gt; y2 = f(x,2) \u0026gt;\u0026gt;\u0026gt; plt.plot(x,y2,color=\u0026#39;red\u0026#39;,label=\u0026#39;$w=2$\u0026#39;) [\u0026lt;matplotlib.lines.Line2D object at 0x118e0bb38\u0026gt;] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #グラフに凡例を表示 \u0026gt;\u0026gt;\u0026gt; plt.legend(loc=\u0026#34;upper left\u0026#34;) \u0026lt;matplotlib.legend.Legend object at 0x113bbbf60\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; plt.show() \u0026gt;\u0026gt;\u0026gt;  実行結果\nグラフに凡例を表示する際は、legend関数の引数locに表示させたい位置を入力する。\n入力できる値は以下の通り。\n \u0026lsquo;best\u0026rsquo;\n \u0026lsquo;upper right\u0026rsquo;\n \u0026lsquo;upper left\u0026rsquo;\n \u0026lsquo;lower left\u0026rsquo;\n \u0026lsquo;lower right\u0026rsquo;\n \u0026lsquo;right\u0026rsquo;\n \u0026lsquo;center left\u0026rsquo;\n \u0026lsquo;center right\u0026rsquo;\n \u0026lsquo;lower center\u0026rsquo;\n \u0026lsquo;upper center\u0026rsquo;\n \u0026lsquo;center\u0026rsquo;\n  \u0026lsquo;best\u0026rsquo;にすると凡例を最適な位置に配置してくれる。\n  "},{"idx":59,"href":"/docs/programming/procon/graph/","title":"グラフの表現方法","content":" グラフの表現方法 グラフはコード上でどのように表現して作ればよいのか？\nここではいくつか方法を示す。\n隣接行列 まずは隣接行列という方法について。\nグラフの頂点の数をVとしたときに初期値が全て0、大きさ|V|*|V|の２次元リスト(行列)Gを用意し、頂点iと頂点jが結ばれているときにG[i][j]、G[j][i]を1にする、という形でグラフを表現する方法である。なお、有向グラフの場合は有効な方向のみに1を設定し、重み付きグラフのときは1ではなく具体的な重みの値を入力する、という形で表現できる。\n\n隣接行列はある2頂点が辺で結ばれているかがすぐわかるという利点があるが、|V|*|V|のリストを作るため、頂点の数が多く辺の数が少ないとリストの大きさや使われない領域がかなり大きくなってしまい、無駄にメモリを利用してしまうという欠点がある。\n隣接リスト 次に隣接リストという方法についてを述べる。\n隣接リストはリストのi番目の要素にグラフの頂点iが結んでいる頂点のインデックスのリストを入れたものである。\n隣接行列と比べると、辺で結ばれていない頂点のデータが無いため、メモリ量が節約できる。\n\n他にも方法はある？と思うが、見つかったら随時追記いたします・・。\n"},{"idx":60,"href":"/docs/programming/graph/subplot/","title":"グラフを複数表示させる","content":" グラフを複数表示させる Python  グラフを複数表示するにはpyplotの関数subplotを使う。\nsubplot(nrows, ncols, index)\nsubplotを使うと縦nrows×横ncolsのマスにグラフを複数並べて表示できる。 場所の番号は左上から1,2,3..となっており、グラフをsubplotで表示させたい位置を引数indexに指定する。\n実行例を以下に示す。\n\u0026gt;\u0026gt;\u0026gt; import numpy as np \u0026gt;\u0026gt;\u0026gt; import matplotlib.pyplot as plt \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; def f(x,w): ... return (x-w)*x*(x+w) ... \u0026gt;\u0026gt;\u0026gt; x = np.linspace(-3,3,61) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #subplotで表示する各グラフ間の間隔を指定する \u0026gt;\u0026gt;\u0026gt; #wsapceは横間隔、hspaceは縦間隔 \u0026gt;\u0026gt;\u0026gt; plt.subplots_adjust(wspace=0.5,hspace=1.0) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #w:0~5でグラフ作成して表示 \u0026gt;\u0026gt;\u0026gt; for i in range(6): ... plt.subplot(2,3,i+1) ... plt.title(i+1) ... plt.plot(x,f(x,i)) ... plt.ylim(-20,20) ... plt.grid(True) ... \u0026lt;matplotlib.axes._subplots.AxesSubplot object at 0x11bb4f2e8\u0026gt; Text(0.5, 1.0, \u0026#39;1\u0026#39;) [\u0026lt;matplotlib.lines.Line2D object at 0x11bb57ba8\u0026gt;] (-20, 20) \u0026lt;matplotlib.axes._subplots.AxesSubplot object at 0x11aa58b00\u0026gt; Text(0.5, 1.0, \u0026#39;2\u0026#39;) [\u0026lt;matplotlib.lines.Line2D object at 0x11aa75c50\u0026gt;] (-20, 20) \u0026lt;matplotlib.axes._subplots.AxesSubplot object at 0x11aa58e10\u0026gt; Text(0.5, 1.0, \u0026#39;3\u0026#39;) [\u0026lt;matplotlib.lines.Line2D object at 0x11aaaf5f8\u0026gt;] (-20, 20) \u0026lt;matplotlib.axes._subplots.AxesSubplot object at 0x11aa947b8\u0026gt; Text(0.5, 1.0, \u0026#39;4\u0026#39;) [\u0026lt;matplotlib.lines.Line2D object at 0x11aae6f60\u0026gt;] (-20, 20) \u0026lt;matplotlib.axes._subplots.AxesSubplot object at 0x11aad0160\u0026gt; Text(0.5, 1.0, \u0026#39;5\u0026#39;) [\u0026lt;matplotlib.lines.Line2D object at 0x11ab1f908\u0026gt;] (-20, 20) \u0026lt;matplotlib.axes._subplots.AxesSubplot object at 0x11ab01ac8\u0026gt; Text(0.5, 1.0, \u0026#39;6\u0026#39;) [\u0026lt;matplotlib.lines.Line2D object at 0x11ab592b0\u0026gt;] (-20, 20) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; plt.show() \u0026gt;\u0026gt;\u0026gt;  実行結果\n  "},{"idx":61,"href":"/docs/programming/graph/graph_index/","title":"グラフ・データ処理","content":" グラフ・データ処理 データサイエンスでは必須？ グラフ描画やcsv等のデータ前処理についてをまとめる。 ここも都合上、現在はPythonのみ記載。\nグラフ描画ではmatplotlibのpyplotというライブラリを利用する。\n グラフ  2次元グラフ  (折れ線)グラフを描画する 一変数関数f(x)をグラフに描画する グラフに色をつける グラフの凡例を表示する x,y軸の表示範囲を指定する グラフのタイトルを設定する 軸のラベルを設定する グラフにグリッド線を表示させる グラフを複数表示させる  3次元グラフ  2変数関数を定義する 2変数関数のグラフ(ヒートマップ)を作成する 2変数関数のグラフ(３D面グラフ)を作成する 2変数関数のグラフ(等高線プロット)を作成する    "},{"idx":62,"href":"/docs/front-end/global_attr/","title":"グローバル属性","content":" グローバル属性 グローバル属性とは全ての要素で指定できる属性のことを言う。\n主に以下のものが挙げられる。\nclass属性 class属性は、要素に種類・分類(クラス)名を指定するための属性である。\n複数の別の要素に同じ名前を指定することができ、そのクラス名を指定するとそれがclass属性に指定されている要素全てが該当されることになる。\nスペースで区切れば複数のクラス名を指定することもできる。\nCSSなどを使うときに、指定した要素全てにcssを適用させたい時などによく利用される。\n \u0026lt;p class=\u0026quot;class1\u0026quot;\u0026gt; \u0026lt;p class=\u0026quot;class class2 class3\u0026quot;\u0026gt; \nid属性 id属性は、それを指定した要素に一意の名前をつける属性である。\n一意の名前なので、同じページ内の他の要素のid属性に同じ名前をつけることはできない。class属性とはここが異なる。\nid属性は、ページ内の特定の要素にリンクさせたい場合、また先程のCSS等で特定の要素にのみCSSを適用したい場合に用いられる。\n \u0026lt;p id=\u0026quot;id1\u0026quot;\u0026gt; \u0026lt;p id=\u0026quot;id2\u0026quot;\u0026gt; \nlang属性 lang属性は要素、属性の言語が何であるかを示す属性である。具体的には、RFC5646（BCP47）で定められた言語コードを入力する。\n例えば日本語だと「\u0026rdquo;ja\u0026rdquo;」、英語であれば「\u0026rdquo;en\u0026rdquo;」、アメリカ英語なら「\u0026rdquo;en-US\u0026rdquo;」と指定する。（日本語には、日本での日本語という意味で「\u0026rdquo;ja-JP\u0026rdquo;」という値も用意されている。）\nlang属性はHTML文書全体に適用されるように、htmlタグに描かれることが多い。\n \u0026lt;html lang=\u0026quot;ja\u0026quot;\u0026gt; \ntitle属性 title属性は、その要素の補足的な内容を提供するための属性である。\n一般的には、ブラウザでカーソルを要素の上に乗せた時にツールチップで表示されるものである。\n(入力例)\n \u0026lt;h3 title=\u0026quot;title属性に書かれた内容はここに出る\u0026quot;\u0026gt;テスト\u0026lt;/h3\u0026gt; \n(出力例、\u0026rdquo;テスト\u0026rdquo;の上にカーソルを置いてみると・・)\n テスト  dir属性 dir属性は、要素のテキストを表示する方向を定義する属性である。設定する値は \u0026ldquo;ltr\u0026rdquo;(左から右)、\u0026rdquo;rtl\u0026rdquo;(右から左)、\u0026rdquo;auto\u0026rdquo;(自動)のいずれかである。\n要素をドラッグして範囲選択すると、選択した時の方向が異なる。\n(入力例)\n\u0026lt;h3 dir=\u0026quot;ltr\u0026quot;\u0026gt;日本語\u0026lt;/h3\u0026gt; \u0026lt;h3 dir=\u0026quot;rtl\u0026quot;\u0026gt;アラビア語\u0026lt;/h3\u0026gt;  (出力例)\n 日本語 アラビア語 \ntabindex属性 tabindex属性は、Tabキーを押した時のフォーカスの移動順序を示す属性である。tabindex属性を指定した要素はフォーカスによる移動が可能になる。\n1以上の値を指定した場合はその値の順番通りに移動し、０を指定した場合は要素が出現する順番通りに移動する。\n(入力例)\n３：\u0026lt;input type=\u0026quot;text\u0026quot; tabindex=\u0026quot;3\u0026quot;\u0026gt; \u0026lt;br\u0026gt; １：\u0026lt;input type=\u0026quot;text\u0026quot; tabindex=\u0026quot;1\u0026quot;\u0026gt; \u0026lt;br\u0026gt; ２：\u0026lt;input type=\u0026quot;text\u0026quot; tabindex=\u0026quot;2\u0026quot;\u0026gt; \u0026lt;br\u0026gt; ４：\u0026lt;input type=\u0026quot;text\u0026quot; tabindex=\u0026quot;4\u0026quot;\u0026gt;  (出力例、Tabを押すと数字の順番通りに移動する)\n ３：１：２：４：\ndropzone属性 dropzone属性は、その要素にファイルなどをドロップすることが可能な領域であることを示す。\n指定する値には\u0026rdquo;copy\u0026rdquo;(コピーされる)、\u0026rdquo;move\u0026rdquo;(移動する)、\u0026rdquo;link\u0026rdquo;(リンクが作成される)がある。ドロップされたデータの処理方法に応じ使い分ける。\nカスタムデータ属性 カスタムデータ属性とは、自分独自に設定できるオリジナルの属性である。使用するのに良い属性などがない場合に利用する、\nただし制約があり、属性名は必ず「data-」という文字列から始まるようにしないといけない。\n主にCSSやJavaScriptで値を取得するときなどに使われる。\n\u0026lt;p data-id=\u0026quot;1\u0026quot;\u0026gt;その１\u0026lt;/p\u0026gt; \u0026lt;p data-id=\u0026quot;2\u0026quot;\u0026gt;その２\u0026lt;/p\u0026gt;  その他のグローバル属性 他、紹介し切れてないグローバル属性は以下の通り（この他にもあります）\n contenteditable 要素を編集可能にするかどうか(true/false)   spellcheck スペル・文法チェックをするか(true/false)   hidden 要素を表示しない(属性名だけで指定可)   "},{"idx":63,"href":"/docs/programming/class_func/constructor/","title":"コンストラクタ(  init  )","content":" コンストラクタ(__init__) クラスのコンストラクタについてを書く。\nコンストラクタとはクラスのインスタンスを作成した時に、そのインスタンスで最初に実行される関数である。主に初期化のために使われる。\nこれも言語により呼び名が違うので注意。\nJava  Javaでは、クラス内でそのクラス名と同じ名前のメソッドを定義した時、それがコンストラクタになる。\n引数を変えれば、多重定義（オーバーロード）でいくらでも定義できる。\nただし、コンストラクタを定義したら、インスタンス生成時に設定する引数はそのコンストラクタと同じでなければならない。\n因みにコンストラクタは定義しなくても良い。その場合インスタンス生成時に設定する引数は無しでないといけない。\n使用例を以下に示す。\nclass Car{ String name = null; String number = null; String owner = null; public Car(String carname,String carnumber,String carowner) { this.name = carname; this.number = carnumber; this.owner = carowner; } } class Main{ public static void main(String args[]){ Car car1 = new Car(\u0026#34;lexus\u0026#34;,\u0026#34;100-1010\u0026#34;,\u0026#34;ai-ueo\u0026#34;); Car car2 = new Car(\u0026#34;carrola\u0026#34;,\u0026#34;200-2020\u0026#34;,\u0026#34;kaki-kukeko\u0026#34;); System.out.println(\u0026#34;Car1:\u0026#34;+car1.name+\u0026#34; \u0026#34;+car1.number+\u0026#34; \u0026#34;+car1.owner); System.out.println(\u0026#34;Car2:\u0026#34;+car2.name+\u0026#34; \u0026#34;+car2.number+\u0026#34; \u0026#34;+car2.owner); } } 実行結果\n\u0026gt; java Main Car1:lexus 100-1010 ai-ueo Car2:carrola 200-2020 kaki-kukeko   Python  Pythonでは　__init()__ という関数がクラスのコンストラクタの役目を果たす。\nクラスのインスタンス生成後、真っ先にこの関数__init__が実行される。\n大体はインスタンス変数を設定するために利用されることが多い。そのときは__init__の引数に、変数に設定したい値に加えてselfを追加することを忘れずに行う。\n実行例を以下に示す。\n\u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; class Car: ... def __init__(self,carname,carnumber,carowner): ... self.name=carname ... self.number=carnumber ... self.owner=carowner ... \u0026gt;\u0026gt;\u0026gt; car1 = Car(\u0026#34;lexus\u0026#34;,\u0026#34;100-1010\u0026#34;,\u0026#34;ai-ueo\u0026#34;) \u0026gt;\u0026gt;\u0026gt; car2 = Car(\u0026#34;carrola\u0026#34;,\u0026#34;200-2020\u0026#34;,\u0026#34;kaki-kukeko\u0026#34;) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; [car1.name,car1.number,car1.owner] [\u0026#39;lexus\u0026#39;, \u0026#39;100-1010\u0026#39;, \u0026#39;ai-ueo\u0026#39;] \u0026gt;\u0026gt;\u0026gt; [car2.name,car2.number,car2.owner] [\u0026#39;carrola\u0026#39;, \u0026#39;200-2020\u0026#39;, \u0026#39;kaki-kukeko\u0026#39;] \u0026gt;\u0026gt;\u0026gt;  Javascript  JavascriptでのコンストラクタはJavaやPythonのそれとは対象が微妙に異なる。\nまず、JavascriptにはJavaのクラスのといったデータ構造はないため、これに対するコンストラクタではない。\nしかし、Javascriptでは関数がクラスのようなデータ構造を表せることがあり、コンストラクタとはこれに対してのコンストラクタである。\nこれを利用すると、関数の中身で指定されたプロパティを持ったオブジェクトが生成される。\n例えば以下の関数があったとする。\nvar Person = function(name){ this.name = name }  この関数を、newキーワードを用いて別の変数に格納すると、変数にはオブジェクト型のデータが格納される。\nvar john = Person(\u0026#39;john\u0026#39;) console.log(john.name)  実行結果\njohn  何が起きているのだろうか？実は、newキーワードを使うと、指定された関数は以下の処理が追加されたような挙動を示す。\nvar Person = function(name){ //var this={}  this.name = name //return this }  newを追加することによって、関数をオブジェクトとして表すことが可能になる。\njavascriptでは、このnewで指定された関数のことをコンストラクタと呼んでいる。また、コンストラクタにより生成されたオブジェクトをインスタンスと呼ぶ。\n  "},{"idx":64,"href":"/docs/programming/math/sigmoid/","title":"シグモイド関数","content":" シグモイド関数 機械学習でよく用いられるシグモイド関数についてを述べる。\nシグモイド関数とは以下の式で定義される関数である。\nPython  シグモイド関数をプロットして表示する。\n\u0026gt;\u0026gt;\u0026gt; import numpy as np \u0026gt;\u0026gt;\u0026gt; import matplotlib.pyplot as plt \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; x = np.linspace(-10,10,100) \u0026gt;\u0026gt;\u0026gt; y = 1/(1 + np.exp(-x)) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; plt.plot(x,y,\u0026#39;black\u0026#39;,linewidth=3) [\u0026lt;matplotlib.lines.Line2D object at 0x1109dde10\u0026gt;] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; plt.ylim(-1,2) (-1, 2) \u0026gt;\u0026gt;\u0026gt; plt.xlim(-10,10) (-10, 10) \u0026gt;\u0026gt;\u0026gt; plt.grid(True) \u0026gt;\u0026gt;\u0026gt; plt.show() \u0026gt;\u0026gt;\u0026gt;  実行結果\n  "},{"idx":65,"href":"/docs/programming/math/softmax_sigmoid/","title":"シグモイド関数とソフトマックス関数","content":" シグモイド関数とソフトマックス関数 シグモイド関数とソフトマックス関数は類似しているところがある。\n2変数(x0、x1)の時のソフトマックス関数(の一つ)は以下の通りになる。\n    e    x 0        e    x 0     +  e    x 1        分母分子にe-x0を掛けると\n   1   1 +  e   -(  x 0  -  x 1  )       となり、ここでx = x0 - x1 とおくとシグモイド関数となる。\n   1   1 +  e -x     つまりは2変数のソフトマックス関数の入力x0、x1の差を新たな変数xとして表したのがシグモイド関数である。\nシグモイド関数を他変数に拡張したものがソフトマックス関数となる。\n"},{"idx":66,"href":"/docs/ctf/caesar_cipher/","title":"シーザー暗号","content":" シーザー暗号 暗号の一つであるシーザー暗号についてを述べる。\nシーザー暗号は元の文(平文)の各文字を、辞書順にx字ずらしてできる暗号のことである。xは任意の数字が入る。\n注意すべきなのは文中の各文字は全てx字ずらす必要があるということである。文字ごとにずらす字数を変えない様にする。\n特に、x=13 (13字ずらす) の時のシーザー暗号を ROT13 という。\n例として、x=3の時、以下のように変換される。\nこの時、例えば\u0026rdquo;aabcb\u0026rdquo;は\u0026rdquo;ddefe\u0026ldquo;、\u0026rdquo;vwxyz\u0026rdquo;は\u0026rdquo;yzabc\u0026ldquo;のように変換される。\n"},{"idx":67,"href":"/docs/programming/other/generics/","title":"ジェネリクス","content":" ジェネリクス ジェネリクスについて。\nジェネリクスとは、特定の型に制限されない、抽象的かつ汎用的なコードを記述するための機能である。\n変数の型を明記することが必要な言語では、変数を宣言するときにその変数の型名も書く必要があり、またその変数にはその型の値しかいれることができない。\nしかし、ジェネリクスを利用すると、引数の型は抽象的なものになり、様々な型の引数を渡すことが可能になる。\n言語による仕様を示す。\nJava  Javaではダイヤモンド演算子を使ってジェネリクスを宣言する。\nクラスを定義する時、及びジェネリクスを利用する変数を定義する時、型名の後ろに\u0026lt;クラス名\u0026gt;というように宣言する。\nこれにより、そのクラス、インスタンスを利用する時の引数にはその型の引数のみ利用できるようになる。\nインスタンス宣言時に利用できる型を定義できるので、結果としてそのクラスとしてはどの型のデータも利用することが可能になる。\n実際の利用例としては、Collectionsクラスを元としているListクラスやMapクラスがある。\nList\u0026lt;T\u0026gt; l = new ArrayList\u0026lt;T\u0026gt;(); Map\u0026lt;K,V\u0026gt; m = new HashMap\u0026lt;K,V\u0026gt;(); 実際に利用する時はこのT,K,VをIntegerやStringなどの具体的な型にする。\nまた、自分でクラスを定義するときもジェネリクスが利用できる。\n実装例を以下に示す。\nclass Gen\u0026lt;T\u0026gt; { //T型のフィールド変数t  T t; //T型の値を引数とする  public Gen(T t){ this.t = t; } }  Swift  Swiftでは関数の定義時ジェネリクスを利用する。\n定義方法は\u0026lt;\u0026gt;で囲い、その中に記述する。\n例を以下に記載する。\nfunc min\u0026lt;T : Comparable\u0026gt;(_ x: T, _ y: T) -\u0026gt; T この例では、minという関数には引数が２つ、かつその両方は同じ型で返り値も同じ型、また利用する型はComparableプロトコルに準拠している物でなければならないという指定である。\n(・・後ほど追記します)\n  "},{"idx":68,"href":"/docs/programming/math/scalar/","title":"スカラー*行列","content":" スカラー*行列 スカラーと行列を書ける方法についてを示す。\nPython  スカラーと行列をかけたいときは、普通にスカラーとnumpy.ndarray型の変数を掛け算すれば良い。\n計算後、ndarray型変数の全ての要素が掛けられた値になる。\n\u0026gt;\u0026gt;\u0026gt; import numpy as np \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; x = np.array([[1,2,3],[4,5,6]]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(x) [[1 2 3] [4 5 6]] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(10*x) [[10 20 30] [40 50 60]] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(2*x) [[ 2 4 6] [ 8 10 12]] \u0026gt;\u0026gt;\u0026gt;    "},{"idx":69,"href":"/docs/front-end/smartphone_optimization/","title":"スマートフォン最適化","content":" スマートフォン最適化 スマートフォン最適化についてを述べる。\nCSSスプライト CSSスプライトとは、複数の画像をつなげて1つのファイルにまとめ、それをCSSで表示範囲を指定する事で画像を利用する方法である。\n複数の画像を個々に利用していると、その画像の数だけ読み込みの通信をすることになり、通信速度が遅くなる場合がある。\nその対策として、今回のような複数の画像を1つにまとめると言う方法がある。これにより通信回数が削減され、通信速度の向上が見込まれる。\nこの手法は、通信が遅く不安定であるモバイル環境において有効である。\n実装方法としては、CSSのbackground-imageプロパティで背景画像を連結して繰り返し表示させ、width,heightで表示範囲、background-positionで表示位置を調整する。\n使用例(css)\n\u0026lt;!DOCTYPE HTML\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;CSSスプライト_サンプル\u0026lt;/title\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; .splite { background-image: url(img_small.jpg); width: 50px; height: 50px; background-position: 100% 100%; } .splite1 { background-position: 0 0px; } .splite2 { background-position: 0 -50px; } .splite3 { background-position: 0 -100px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p class=\u0026#34;splite splite1\u0026#34;\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;splite splite2\u0026#34;\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;splite splite3\u0026#34;\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 使用例(iframe)\n\u0026lt;iframe width=\u0026quot;500\u0026quot; height=\u0026quot;400\u0026quot; src=\u0026quot;/css_sample_pages/css_splite.html\u0026quot;\u0026gt; \u0026lt;/iframe\u0026gt;  表示例\n  \n高画像度画面向けの対応 デバイスによって、ディスプレイのピクセルの長さがCSSで扱うピクセルの長さと異なる場合がある。\nこれは、解像度の違いより画素の大きさが異なることなどにより発生する。\nこれにより、拡大、縮小等によって画像がぼやけて表示されるというような問題が発生する場合がある。\nこの問題を回避するには、メディアクエリを利用する事で、デバイスの特性により適用するCSSを使い分けていく。\nホーム画面ショートカットアイコン AndroidやiOSといったスマートフォン向けのOSでは、Webサイトへアクセスするためのショートカットをアプリケーションのようにホーム画面へ配置することができます。\nこの際のアイコンは、HTMLのlink要素でrel属性にapple-touch-iconと指定することで、設定することが可能になります。\n\u0026lt;link rel=\u0026quot;apple-touch-icon\u0026quot; href=\u0026quot;xxx.png\u0026quot;\u0026gt;  また、href属性に画像を設定することで、アイコン画像としても使用できます。 アイコン画像はOSによっては自動的にハイライトや影がつくことがありますが、これを避けたい場合にはrel属性にapple-touch-icon-precomposedを指定します。\nスタンドアロンモード iOSのみの設定だが、Webサイトをアドレスバーやツールバーを消した形であるフルスクリーンで表示させるスタンドアローンモードを設定することができる。\n使用方法は、meta要素でname=\u0026ldquo;apple-mobile-web-capable\u0026rdquo; content=\u0026ldquo;yes\u0026rdquo;と指定すれば良い。\na要素での電話発信 通話機能を持つデバイスには、a要素を利用する事で簡単に電話を発信する設定をすることができる。\n方法は、a要素のhref属性の値をtel:(電話番号)とすれば良い。\n使用例(html)、表示例は省略\n\u0026lt;a href=\u0026#34;tel:xxxxxxxxxxx\u0026#34;\u0026gt;管理者へTEL\u0026lt;/a\u0026gt; script要素のasync属性/defer属性 script要素でJavascript等の外部ソースを読み込む時、HTMLのパース(読み込み)を中断して外部ソースの読み込みを開始し、それが終わり次第HTMLの読み込みを再度開始する。\nしかし、それによりHTML読み込みの待ち時間が発生してしまい、通信環境が遅くなりがちなモバイル環境においては悪影響になる場合がある。\nこのような場合に対処するための属性が、script要素に設定するasync/defer属性である。\nasync属性 async属性は、HTMLパース処理を中止することなく非同期に外部ソースの読み込みを行う。外部ソースの読み込みが終了後に、HTMLパース処理の終了を待つことなくその外部ソースの処理が実行される。\n使用例(html)、表示例は省略\n\u0026lt;script src=\u0026#34;example.js\u0026#34; async\u0026gt;\u0026lt;/script\u0026gt; defer属性 defer属性は、async属性と同様にHTMLパース処理を中止することなく非同期に外部ソースを読み込むが、その外部ソースの処理実行はHTMLパース処理が終了後に行われる。\n使用例(html)、表示例は省略\n\u0026lt;script src=\u0026#34;example.js\u0026#34; defer\u0026gt;\u0026lt;/script\u0026gt;"},{"idx":70,"href":"/docs/front-end/section/","title":"セクション","content":" セクション セクションとは章や節といった様なもの、HTMLでは見出しとそれに対応する文書の部分(セクショニングコンテンツ)といった様なものである。\nHTMLには種類は様々だが、セクションを構成するための要素がいくつか存在する。\n見出し h1~h6要素 h1,h2,h3,h4,h5,h6は、見出しを構成する要素である。\nh1が一番上の階層で、その次に大きいのがh2、その次がh3、、というように続く。\n記法例\n\u0026lt;h1\u0026gt;見出し１\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;見出し２\u0026lt;/h2\u0026gt; \u0026lt;h3\u0026gt;見出し３\u0026lt;/h3\u0026gt;  アウトライン HTML文書から見出しの要素だけを抜き出し、文書内のセクションが一目でわかる様にしたものをアウトラインという。\n例えばこのHUGOで書いているブログでは、ページ右の部分に見出しの部分だけが表示される様になっている。これもアウトラインだと思ってくれれば良い。\n(ちなみに当ブログでは全ての記事にアウトラインが表示される様には設定していない。必要に応じてアウトラインを表示する必要があると判断した場合、表示させる様にしている)\nセクションを表す要素 以下にセクションを表す際に利用する要素を記載する。\narticle要素 article要素は独立したセクションを表す要素である。\nそのため、他のセクションの一部となっている要素は含むことはできない。\n適用例としては、雑誌や新聞の記事、ブログのコメントなどがある。\n記法例\n\u0026lt;h1\u0026gt;MYブログ\u0026lt;/h1\u0026gt; \u0026lt;article\u0026gt; \u0026lt;h2\u0026gt;3/9 その１\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;(3/9の内容・・)\u0026lt;/p\u0026gt; \u0026lt;/article\u0026gt; \u0026lt;article\u0026gt; \u0026lt;h2\u0026gt;3/10 その１\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;(3/10の内容・・)\u0026lt;/p\u0026gt; \u0026lt;/article\u0026gt;  aside要素 aside要素は補足や脚注のような、そのセクションの内容からは別扱いのしたほうが良さそうなセクションを表す場合に利用する。\n記法例\n\u0026lt;aside\u0026gt; \u0026lt;h3\u0026gt;補足\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;aside要素で\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;補足を表す\u0026lt;/p\u0026gt; \u0026lt;/aside\u0026gt;  nav要素 nav要素は、そのページがサイト内でどこに位置するかなどといった、ナビゲーションを示すセクションを表す場合に利用する。\n記法例\n\u0026lt;nav\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;Top\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;プログラミング\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;フロントエンド\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/nav\u0026gt;  section要素 section要素はこれまでに述べた３つの要素のような特別な意味は持たない、一般的なセクションを表す際に用いる要素である。\n記法例\n\u0026lt;section\u0026gt; \u0026lt;h2\u0026gt;セクション\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;111\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;222\u0026lt;/p\u0026gt; \u0026lt;/section\u0026gt;  セクショニング・ルート セクショニング・ルートとは、セクションのルートとして扱われる要素のことである。\nセクショニング・ルートの下に属するセクションはそのセクショニング・ルート独自のアウトラインを持つことができる。\nまた、そのセクションやアウトラインはそのセクショニング・ルートの外のセクションには影響を及ぼさない。\nセクショニング・ルートになる要素としては、以下の要素が挙げられている。\n body要素 blockquote要素 fieldset要素 figure要素 td要素 details要素  その他、セクションに関する要素 header要素 header要素は、セクションまたはセクショニング・ルートのヘッダーであることを示す要素である。\nbody要素のヘッダーとなる場合、ページ全体のヘッダーになる。\n一般的にヘッダーには見出し、ナビゲーションなどを含む。（必須ではない）\n\u0026lt;body\u0026gt; \u0026lt;header\u0026gt; \u0026lt;h1\u0026gt;ヘッダー\u0026lt;/h1\u0026gt; \u0026lt;nav\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;ホーム\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;お知らせ\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/nav\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;/body\u0026gt;  footer要素 footer要素はheader要素と逆で、セクションまたはセクショニング・ルートのフッターであることを示す要素である。\nheader要素の時と同様に、body要素のフッターとなる場合はページ全体のフッターになる。\n一般的にフッターには問い合わせ先や著作権情報についてを記載する。（必須ではない）\n・・・ \u0026lt;footer\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;著作権情報\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;お問い合わせ\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/footer\u0026gt; \u0026lt;/body\u0026gt;  main要素 main要素はその範囲がページにおけるメインコンテンツであることを示す要素である。\nmain要素の内容には、そのページで固有の内容を記述する様にする。他のページでも共通して利用される様な要素(ナビゲーションや著作権情報など)はここには含めない様にする。\n\u0026lt;body\u0026gt; \u0026lt;main\u0026gt; \u0026lt;article\u0026gt; \u0026lt;h2\u0026gt;記事\u0026lt;/h2\u0026gt; ・・・ ・・・ \u0026lt;/article\u0026gt; \u0026lt;/main\u0026gt; \u0026lt;/body\u0026gt;  address要素 address要素は、問い合わせ先を示す要素である。\n対象となるのはその要素から最も近いbodyまたはaddress要素であり、その要素の内容に対する問い合わせ先を示す。\n\u0026lt;body\u0026gt; ・・・ \u0026lt;address\u0026gt; お問い合わせ：aaa@example.com \u0026lt;/address\u0026gt; \u0026lt;/body\u0026gt;  その他の要素 div要素 div要素はこれまでに述べた要素とは違い、決められた役割や意味を持たない要素である。\n使うのに適切な要素が無い場合に利用する要素で、class属性などを利用する事で用途を示す。\n\u0026lt;body\u0026gt; \u0026lt;div class=\u0026quot;question\u0026quot;\u0026gt;問題\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;answer\u0026quot;\u0026gt;答え\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt;  span要素 span要素もdiv要素と同じく、決められた役割や意味を持たない要素である。\ndiv要素と違う点は、div要素はブロックレベルの要素、span要素はインライン要素という点。(詳しい意味はCSSの所で)\n\u0026lt;body\u0026gt; \u0026lt;span class=\u0026quot;question\u0026quot;\u0026gt;問題\u0026lt;/div\u0026gt; \u0026lt;span class=\u0026quot;answer\u0026quot;\u0026gt;答え\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt;  "},{"idx":71,"href":"/docs/programming/procon/segment_tree/","title":"セグメント木","content":" セグメント木 セグメント木は区間と二分木を組み合わせたようなデータ構造である。例えば長さ8のリストをセグメント木で表すと以下のようになる。\nここで、セグメント木の節点にどのようなデータを持たせるかによって、様々な機能を持つ木を作ることができる。\nここでは、RMQ(Range Minimum Query)を実現するセグメント木を例として見ていく。\nRMQとは、リスト(及び数列)上で、指定した区間内の最小値を求めるという問題である。\nまず、例として以下のような数列があったとする。\na=[5,2,3,7,4,1,9,10]  この数列において、i,j(0≦i≦j\u0026lt;|a|)を入力したときに、a[i]からa[j]の区間内での最小値を求めることを考えてみよう。\nセグメント木を使った最小値の求め方 この数列をセグメント木で、節点にその節点が示す区間の最小値を入力すると以下のようになる。\nここで、区間を示す値i,jを入力したとき、どのようにして最小値を求めれば良いか。\n方法は、セグメント木中で区間[i,j]を示すような値を取り出し、その最小値を求めれば良いのである。\n例えば、i=1,j=4の時は、以下のセグメント木の黄色い節点が[1,4]を示すことになり、この値の最小値「2」が区間[i,j]の最小値となる。\ni,jが与えられた時に、セグメント木を使って区間[i,j]の最小値を取り出す方法は、セグメント木の根から以下の手順を再帰的に求める。\n [i,j]とその節点が示す区間が全く交差していなければ、最小値を計算するのに影響しない値を返す。(intの最大値など) [i,j]にその節点が示す区間が含まれるならば、その節点の持つ値を返す。 上の2つのいずれでもない場合は、2つの子ノードについてこの手順を行い、その2つの最小値を返す。  セグメント木の値の更新 aの要素を更新する時、セグメント木中の節点の値も更新しなければならない。その場合の計算方法はどうすれば良いか？\nこれは、セグメント木の葉の要素(a[i])から更新し、その後親要素へ順に最小値を計算、更新させていく。\n例として、a[0]を0と置き換えた時の一連の流れを以下の図に示す。\nコードでの実装例 これまでの一連の機能について、セグメント木を(Python)コードで実装した例を以下に示す。\n#最小値計算に影響を与えないほどの大きい値 MAX=10**9 class SegmentTree: def __init__(self,n): self.segtree=[MAX for _ in range(2**n - 1)] #k番目の値をaに変更 def update(self,k,a): k+=(2**n)-1 self.segtree[k]=a #登りながら更新 while k\u0026gt;0: k=(k-1)//2 self.segtree[k]=min(self.segtree[2*k+1],self.segtree[2*k+2]) #[a,b)の最小値を求める #kは節点の番号、l,rはその節点が対応している区間[l,r)のこと。 #一番最初(根)の時はquery(a,b,0,0,n)とする。 def query(a,b,k,l,r): #[a,b)と[l,r)が交差しなければ、MAXを返す if(r\u0026lt;=a or b\u0026lt;=l): return MAX #[a,b)が[l,r)を完全に含んでいれば、節点の値を返す if(a\u0026lt;=l and r\u0026lt;=b): return self.segtree[k] else: #そうでない時は、2つの子の最小値を返す vl=self.query(a,b,2*k+1,l,(l+r)//2) vr=self.query(a,b,2*k+2,(l+r)//2,r) return min(vl,vr)"},{"idx":72,"href":"/docs/front-end/css_selector/","title":"セレクタ","content":" セレクタ CSSのセレクタについてを述べる。\nセレクタにはいくつか種類があり、セレクタの基本的な最小単位のことをシンプルセレクタという。\n種類にもよるが、シンプルセレクタを組み合わせたものもセレクタとしてCSSで利用できる。（できないパターンもある）\n以下、シンプルセレクタの種類についてを示す。\nタイプセレクタ 要素名をそのままセレクタ名としたものをタイプセレクタという。タイプセレクタを利用すると、指定した要素名の要素全てにCSSの内容が適用される。\np要素\ndiv要素 ``` 以下のように表示される。  p要素\ndiv要素  -- 使用例\ndiv { color: green} ユニバーサルセレクタ セレクタの要素名を\u0026rdquo;*\u0026ldquo;にすると、全ての要素に適用される。このようなセレクタをユニバーサルセレクタという。\n使用例\n* { color: red} クラスセレクタ 先述のタイプセレクタ 、ユニバーサルセレクタにおいて、ピリオド(.)の後にHTMLのclass属性の値を指定すると、そのclass属性の値を持つ要素が適用対象となる。このようなセレクタをクラスセレクタという。\n使用例\nspan.address { color: blue} IDセレクタ タイプセレクタ 、ユニバーサルセレクタにおいて、シャープ(#)の後にHTMLのid属性の値を指定すると、そのid属性の値を持つ要素がCSSの適用対象となる。このようなセレクタをIDセレクタという。\n使用例\ndiv#mean { color: gray} 属性セレクタ タイプセレクタ 、ユニバーサルセレクタにおいて、大かっこ([])の中に属性名や値を指定すると、その属性の値を持つ要素がCSSの適用対象となる。このようなセレクタを属性セレクタという。\n属性セレクタの記法は以下のとおり。\n [属性名] ・・ 属性値に関係なく、その属性名が指定されている要素全て   [属性名=\"属性値\"] ・・ その属性名に属性値(完全一致)が指定されている要素   [属性名~=\"属性値\"] ・・ その属性名に属性値(含まれていればOK)が指定されている要素   [属性名^=\"属性値\"] ・・ 属性名の値がその属性値で始まっている要素   [属性名$=\"属性値\"] ・・ 属性名の値がその属性値で終わっている要素   使用例\na[href$=\u0026#34;.pdf\u0026#34;] { color: red} 擬似クラス ある要素が特定の状態にある時のみを適用対象とするセレクタを擬似クラスという。使用するには、セレクタの要素名の後に続けて書く。\n擬似クラスは多種類あるが、以下に一部を示す。\n :link ・・ a要素で、リンク先にまだアクセスしていない場合   :visited ・・ a要素で、リンク先に既にアクセスしている場合   :hover ・・ マウスカーソルが上にある状態   :active ・・ マウスのボタンが押されている状態   :first-child ・・ 子要素の中で一番最初の要素   :last-child ・・ 子要素の中で一番最後の要素   :only-child ・・ 唯一の子要素である場合   :focus ・・ フォーカス(選択)されたとき   :checked ・・ ラジオボタンやチェックボックスなどが選択されたとき   :empty ・・ 要素内容が空の時   :target ・・ URLの最後が「#xxx」となっていた場合の、対象となっている要素   :lang(言語コード) ・・ HTMLのlang属性などで設定されている言語コードの言語が設定されている要素   :not(シンプルセレクタ) ・・ シンプルセレクタの対象外の要素   使用例\na:link { color: blue} 擬似要素 要素内容の一部のみをCSSの適用対象とするセレクタを擬似要素という。\n主な擬似要素は以下の通り。\n ::first-line ・・ 要素内容の１行目   ::first-letter ・・ 要素内容の１文字目   ::before ・・ 要素の始めにcontent宣言の内容を追加   ::after ・・ 要素の終りにcontent宣言の内容を追加   使用例\np::first-letter { color: red} 結合子 シンプルセレクタ同士を結合子と呼ばれるもので結びつけたものもセレクタとして機能する。\n結合子及びその使用法は以下のとおり。\n セレクタ1 セレクタ2 ・・ セレクタ1の内部に含まれているセレクタ2の要素   セレクタ1  セレクタ2 ・・ セレクタ1の子要素となっているセレクタ2の要素   セレクタ1 + セレクタ2 ・・ セレクタ1の直後に現れるセレクタ2の要素   セレクタ1 ~ セレクタ2 ・・ セレクタ1の後に現れる全てのセレクタ2の要素   使用例\nh1+p { color: red}"},{"idx":73,"href":"/docs/programming/math/softmax/","title":"ソフトマックス関数","content":" ソフトマックス関数 Python  複数の数x1,x2,\u0026hellip;xiがあり、それらの数の大小関係を保ったままそれぞれを確率を表す数y1,y2,\u0026hellip;,yiに変換したいとする。\n確率を表す変数は0~1の範囲内かつ、全ての変数の合計が１になってないといけない。\nこのような変数を求めたいときに使うのがソフトマックス関数である。求め方は以下の通り。\n1: 各 xi のexpの和を求める。\nu = exp(x1) + exp(x2) + \u0026hellip; + exp(xi)\n2: 各 xi を1.の値で割った値を yi とおく。\ny0 = exp( x0 ) / u,\ny1 = exp( x1 ) / u,\n\u0026hellip;\ny_i = exp( x_i ) / u\n実装例を以下に示す。\n\u0026gt;\u0026gt;\u0026gt; import numpy as np \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #ソフトマックス関数 \u0026gt;\u0026gt;\u0026gt; def softmax(*x): ... u=0 ... for i in range(len(x)): ... u += np.exp(x[i]) ... y=[] ... for i in range(len(x)): ... y.append(np.exp(x[i])/u) ... return y ... \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #x0=2,x1=1,x2=-2としてソフトマックス関数適用 \u0026gt;\u0026gt;\u0026gt; y = softmax(2,1,-1) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #計算後のyの値 \u0026gt;\u0026gt;\u0026gt; print(y) [0.7053845126982412, 0.2594964603424191, 0.03511902695933972] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #yの合計値は１になる \u0026gt;\u0026gt;\u0026gt; sum(y) 1.0 \u0026gt;\u0026gt;\u0026gt;    "},{"idx":74,"href":"/docs/programming/procon/dijkstra/","title":"ダイクストラ法","content":" ダイクストラ法 グラフ探索の手法の一つ、ダイクストラ法についてを述べる。\nダイクストラ法は重み付きのグラフにおいて、ある頂点から他の全ての頂点までの最小コストを計算する一つの手法である。\n既に最小コストが確定している頂点から一つ一つ最小コストを決定していくので、動的計画法に少し似ているところがある。\nアルゴリズム 入出力は以下の通り。\n 入力  グラフ G = (V,E) W(a,b):頂点aから頂点b(a,b∈V)を結ぶ辺の重み(コスト)。辺が存在しないときはW(a,b)=∞ 頂点s (s∈V)  出力  頂点sから頂点vまでの最小コストd(v) (v∈V) 頂点sから頂点vまでの最小コスト経路において、頂点vの一つ前の頂点p(v) (v∈V)   擬似的なアルゴリズムは以下の通り。\n X=V とする 最小コストd(v)(v∈V)を用意し、全てのvにおいてd(v)=∞ と初期化、p(v) (v∈V) を用意し、全てのvにおいてp(v)=v と初期化する d(s)=0とする X=X-{s} とする Xの全ての点v (v∈X) に対して以下の式の通りにコストを計算する。\nd(v) = min(d(v),d(s)+W(s,v))\n 5.の式において、第２項の方が小さいならば、p(v)=sとする。\n X={} (|X|=0) ならば、d(v),p(v)を出力して終了する\n d(s) = min{d(v)|v∈X} となるsを求め、4.に戻る\n  計算量はn=|V|とした時、5.~8.の処理が1+2+・・・+n回行われるため、O(|V|2)となる。\n例として以下のグラフで、頂点Aから他の全ての点までの最短経路を求めてみる。\nまずは始点となるAのコストを0、その他の頂点のコストを∞とする。また、Aをコスト確定済みとしてXに加える。\n(図中、頂点内の左にその頂点のコスト、右にその頂点までの最小コスト経路における直前の頂点を記載する。またコスト確定した頂点(Xから除いた頂点)を黄色く、コストが確定していない頂点を白く表示する。)\n次に、Aから各頂点のコスト及び直前の頂点を計算する。この時、Aに隣接する頂点はコストが下図のように定まる。\n次に、コストが確定していない頂点(上図で白の頂点)からコストが最も小さい頂点を選び、その頂点をコスト確定とする。\nこの場合は頂点Bが該当する。\nここから頂点Bに隣接しコスト確定していない頂点に対してコストを計算する、という一連の動作を全ての頂点のコストが確定するまで行っていくと、最終的には以下の図のようになり、始点Aから全ての頂点までの最小コスト及び経路が求められる。\nコードによる実装例は以下の通り。(Python)\nINF=float(\u0026#34;inf\u0026#34;) #始点,頂点の数,辺(頂点ごとの隣接行列) def dijkstra(start,v,e): pre=[i for i in range(v)] x=set([i for i in range(v)]) dist=[INF for _ in range(v)] dist[start]=0 s=start while(len(x)\u0026gt;0): x.remove(s) min_x=-1 min_dx=float(\u0026#34;inf\u0026#34;) for xi in x: if(dist[xi]\u0026gt;dist[s]+e[s][xi]): dist[xi]=dist[s]+e[s][xi] pre[xi]=s if(min_dx\u0026gt;dist[xi]): min_dx=dist[xi] min_x=xi s=min_x return dist,pre #例題のデータ edge=[[INF,2 ,5 ,6 ,INF], [2 ,INF,1 ,INF,9 ], [5 ,1 ,INF,INF,10 ], [6 ,INF,INF,INF,4 ], [INF,9 ,10 ,4 ,INF]] print(dijkstra(0, 5, edge)) 実行結果\n([0, 2, 3, 6, 10], [0, 0, 1, 0, 3])  "},{"idx":75,"href":"/docs/front-end/text/","title":"テキスト","content":" テキスト HTML文書にテキストを記載、装飾、補足するための要素についてをここでは述べる。\n(一部表示例も記載するが、ブラウザ等により表示が異なる場合もあるので注意。)\np要素 p要素は、一つの段落を表す要素である。\n\u0026lt;p\u0026gt;段落１\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;段落２\u0026lt;/p\u0026gt;  a要素 a要素は別URLへのリンクを示す時に使う要素であり、通常はhref属性を指定して利用する。\nhref属性で遷移先のURLを指定する。\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;/\u0026quot;\u0026gt;ホーム\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;  em要素 em要素は強調(emphasize)する部分を示すための要素である。入れ子にすることもでき、それにより強調の度合いを強くすることもできる。\n\u0026lt;p\u0026gt;ここが\u0026lt;em\u0026gt;\u0026lt;em\u0026gt;超\u0026lt;/em\u0026gt;タイヘン\u0026lt;/em\u0026gt;な箇所だ\u0026lt;/p\u0026gt;  表示例  ここが超タイヘンな箇所だ\n\nstrong要素 strong要素は重要性、重大性、緊急性が高いテキストを示す時に利用する。\nこの要素も入れ子にして利用することができ、重要性の度合いを強くすることもできる。\nstrong要素で囲まれた部分は通常太字になって表示される。しかし、ただ太字にするためにこの要素を使うのはやめた方が良い。\n\u0026lt;p\u0026gt;左方向は通行可能\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;右方向は\u0026lt;strong\u0026gt;立入禁止\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;  表示例\n 左方向は通行可能\n右方向は立入禁止\n\nblockquote要素 blockquote要素は、その部分が引用してきた要素であることを示す要素である。\n引用を示す要素は他にもあるが、blockquote要素はブロックレベル要素(段落や表などをひとかたまりとする要素)であり、例えば複数行に対して適用したい場合などに利用する。\n引用元を示したいときはcite属性(及びcite要素)を利用して示す。\n\u0026lt;blockquote\u0026gt; \u0026lt;p\u0026gt;引用文１\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;引用文２\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;引用文３\u0026lt;/p\u0026gt; \u0026lt;/blockquote\u0026gt;  表示例\n  引用文１\n引用文２\n引用文３\n \nq要素 q要素もblockquote要素と同じく、引用してきたことを示す要素である。\nq要素はインラインレベル要素として引用文を示す時に使用する。\nblockquote要素と同じく、引用元を示したいときはcite属性(及びcite要素)を利用して示す。\n\u0026lt;p\u0026gt; 好きな言葉は\u0026lt;q\u0026gt;「まずはやってから考えよう」\u0026lt;/q\u0026gt;ですね。 \u0026lt;/p\u0026gt;  表示例\n  好きな言葉は「まずはやってから考えよう」ですね。 \ncite要素 cite要素は、引用元や参照先を示すための要素である。\n\u0026lt;p\u0026gt; \u0026lt;cite\u0026gt;太宰治『ダス・ゲマイネ』\u0026lt;/cite\u0026gt;の冒頭は\u0026lt;q\u0026gt;「恋をしたのだ。そんなことは、全く初めてであった。」\u0026lt;/q\u0026gt;だ。 \u0026lt;/p\u0026gt;  表示例\n  太宰治『ダス・ゲマイネ』の冒頭は「恋をしたのだ。そんなことは、全く初めてであった。」だ。 \nmark要素 mark要素はある部分を目立たせたいときに使用する要素である。マーカーで線を引くようなもの。\n\u0026lt;p\u0026gt; 645年、中大兄皇子が\u0026lt;mark\u0026gt;大化の改新\u0026lt;/mark\u0026gt;を行った。 \u0026lt;/p\u0026gt;  表示例\n  645年、中大兄皇子が大化の改新を行った。 \nsmall要素 small要素は注釈・注記のような、欄外に示すような細かい情報を示すときに使用する要素である。\n例としては著作権(Copyright)や免責事項など。\n\u0026lt;p\u0026gt; 以上である。 \u0026lt;small\u0026gt;©️ 2020 Tatsuroh Wakasugi.\u0026lt;/small\u0026gt; \u0026lt;/p\u0026gt;  表示例\n  以上である。 ©️ 2020 Tatsuroh Wakasugi. \ndata要素 data要素は、要素内のテキスト等に対して、「機械可読データ」を追加したい時に利用する要素である。\n要は、プログラムにテキストを読み込ませるとき、実際に表示されるテキストの内容ではなく、別の内容として読み込ませたいときに使用する。\ndata要素を使うときはvalue属性を必須とする。value属性の値に、機械に使わせる値を入力する。\nただし、日時など時刻に関するデータを扱うときは、data要素ではなく次のtime要素を使った方が良い。\n\u0026lt;p\u0026gt; 私の所持金は\u0026lt;data value=\u0026quot;30000\u0026quot;\u0026gt;三万円\u0026lt;/data\u0026gt;です。 \u0026lt;/p\u0026gt;  この場合ブラウザには\u0026rdquo;三万円\u0026rdquo;と表示されるが、プログラムがこのページを読み込むときこの箇所は\u0026rdquo;30000\u0026rdquo;となる。\ntime要素 time要素は、日時など時刻に関するdata要素である。時刻に関する機械可読データを適用させたい時に使用する。\n値に関する属性はvalue属性ではなく、time要素の場合datetime属性である。こちらを利用する。\n\u0026lt;p\u0026gt; 締め切りは\u0026lt;time datetime=\u0026quot;2020-05-01T17:30Z\u0026quot;\u0026gt;明日の午後5時30分\u0026lt;/time\u0026gt;です。 \u0026lt;/p\u0026gt;  abbr要素 abbr要素は、それが略語であることを示す要素である。略してない、正式名も示したいときはtitle属性を使用する。\n\u0026lt;p\u0026gt; \u0026lt;abbr title=\u0026quot;転職活動\u0026quot;\u0026gt;転活\u0026lt;/abbr\u0026gt;をいつから始めようか・・ \u0026lt;/p\u0026gt;  表示例\n  転活をいつから始めようか・・ \ndfn要素 dfn要素は、それが定義の対象となっていることを示す要素である。他の文中に何かの定義についての説明がされている時、どれをその定義の説明の対象としているかを示すために用いる。\n\u0026lt;p\u0026gt; 今日は\u0026lt;dfn\u0026gt;昭和の日\u0026lt;/dfn\u0026gt;で、昭和天皇の誕生日である4月29日にあてられている日本の国民の祝日である。 \u0026lt;/p\u0026gt;  表示例\n  今日は昭和の日で、昭和天皇の誕生日である4月29日にあてられている日本の国民の祝日である。 \nb要素 b要素は特に意味合いを持つことは無いが、表示として目立たせたい時に利用する要素である。\n目立たせたい時の意味がしっかりある場合には、b要素ではなくそれに応じた適切な要素を利用すること。例えば強調ならem要素、緊急・重要性が高い内容ならstrong要素、一部分を目立たせたいならmark要素など。\n\u0026lt;p\u0026gt; \u0026lt;b\u0026gt;b要素\u0026lt;/b\u0026gt;は表示として目立たせたい時に利用する。 \u0026lt;/p\u0026gt;  表示例\n  b要素は表示として目立たせたい時に利用する。 \ni要素 i要素も特に意味合いを持つことは無いが、表示として他と区別させたい時に利用する要素である。\n他と区別させたい時の意味がしっかりある場合には、i要素ではなくそれに応じた適切な要素を利用すること。例えば強調ならem要素、定義に関することならdfn要素など。\n\u0026lt;p\u0026gt; \u0026lt;i\u0026gt;i要素\u0026lt;/i\u0026gt;は表示として他と区別させたい時に利用する。 \u0026lt;/p\u0026gt;  表示例\n  i要素は表示として他と区別させたい時に利用する。 \ns要素 s要素は、既に使われていない、古い情報となった部分を表すための要素である。\n\u0026lt;p\u0026gt; s要素は、\u0026lt;s\u0026gt;既に使われていない情報となった部分\u0026lt;/s\u0026gt;を表すための要素である。 \u0026lt;/p\u0026gt;  表示例\n  s要素は、既に使われていない情報となった部分を表すための要素である。 \nu要素 u要素はスペルミスなどの通知をする際に使用する。デフォルトでは下線が引かれる。\n他の意味を持つ場合には、u要素ではなくそれに応じた適切な要素を利用すること。\n\u0026lt;p\u0026gt; u要素は、\u0026lt;u\u0026gt;spelu misu\u0026lt;/u\u0026gt;を表すための要素である。 \u0026lt;/p\u0026gt;  表示例\n  u要素は、spelu misuを表すための要素である。 \nbdo要素 bdo要素は、要素内の文字表記の方向を上書きする要素である。表記の方向はdir属性を使って指定する。(必ず指定する)\n\u0026lt;p\u0026gt; bdo要素を使って、「\u0026lt;bdo dir=\u0026quot;rtl\u0026quot;\u0026gt;文字列の表記の方向を右から左\u0026lt;/bdo\u0026gt;」へ指定することができる。 \u0026lt;/p\u0026gt;  表示例\n  bdo要素を使って、「文字列の表記の方向を右から左」へ指定することができる。 \nbdi要素 bdi要素は、要素内の文字表記のアルゴリズム(方向)を、ブラウザ全体で利用しているアルゴリズムとは別扱いにさせる要素である。\n入力フォームなどから入力した文字を挿入するときなどに利用する。\n\u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;bdi\u0026gt;リスト\u0026lt;/bdi\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;bdi\u0026gt;قائمة\u0026lt;/bdi\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt;  表示例\n  リスト قائمة  \npre要素 pre要素はその内容の部分が既に整形済み(タブ・スペースなどで整えている)であることを示す要素である。この要素の内容は入力されている通りにそのまま表示される（タブ・スペースなどは弾かれない）\n\u0026lt;p\u0026gt;タブ３つ\u0026quot; \u0026quot;、スペース３つ\u0026quot; \u0026quot;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;pre\u0026gt;タブ３つ\u0026quot; \u0026quot;、スペース３つ\u0026quot; \u0026quot;\u0026lt;/pre\u0026gt;\u0026lt;/p\u0026gt;  表示例\n タブ３つ\u0026rdquo; \u0026ldquo;、スペース３つ\u0026rdquo; \u0026ldquo;\nタブ３つ\u0026rdquo; \u0026ldquo;、スペース３つ\u0026rdquo; \u0026ldquo;\n\ncode要素 code要素は、その部分はソースコードであることを示す要素である。\n\u0026lt;code\u0026gt; print(\u0026quot;Hello! World!\u0026quot;) \u0026lt;/code\u0026gt;  表示例\n  print(\u0026ldquo;Hello! World!\u0026rdquo;)  \nkbd要素 kbd要素は、その部分がユーザーが入力する内容であることを示す要素である。具体的にはキー名を指定する。\n次に\u0026lt;kbd\u0026gt;Shift\u0026lt;/kbd\u0026gt;キーを押してください。  表示例\n 次にShiftキーを押してください。 \nsamp要素 samp要素は、それがプログラムから出力されたもの、またはそのサンプルであることを示す要素である。\n\u0026lt;samp\u0026gt; ダウンロードしています・・ \u0026lt;/samp\u0026gt;  表示例\n  ダウンロードしています・・  \nvar要素 var要素は、それが数式やプログラム内などの変数であることを示す要素である。\n\u0026lt;p\u0026gt; \u0026lt;var\u0026gt;y\u0026lt;/var\u0026gt; = 2\u0026lt;var\u0026gt;x\u0026lt;/var\u0026gt;+1 \u0026lt;/p\u0026gt;  表示例\n  y = 2x+1 \nsup要素 sup要素は、上付き文字であることを示す要素である。\n\u0026lt;p\u0026gt; \u0026lt;var\u0026gt;y\u0026lt;/var\u0026gt; = 2\u0026lt;var\u0026gt;x\u0026lt;/var\u0026gt;\u0026lt;sup\u0026gt;2\u0026lt;/sup\u0026gt;+1 \u0026lt;/p\u0026gt;  表示例\n  y = 2x2+1 \nsub要素 sub要素は、下付き文字であることを示す要素である。\n\u0026lt;p\u0026gt; a\u0026lt;sub\u0026gt;n+1\u0026lt;/sub\u0026gt; = a\u0026lt;sub\u0026gt;n\u0026lt;/sub\u0026gt;+1 \u0026lt;/p\u0026gt;  表示例\n  an+1 = an+1 \nbr要素 br要素は、改行を表す空要素である。１つ書くたびに１回改行されて表示される。\n１１１ ２２２ ３３３ １１１\u0026lt;br\u0026gt; ２２２\u0026lt;br\u0026gt; ３３３\u0026lt;br\u0026gt;  表示例\n １１１ ２２２ ３３３\n１１１\n２２２\n３３３\n\nwbr要素 wbr要素は、英文のテキストをその箇所で折り返して表示させるための空要素である。\n通常、英文やURLなどの半角英字で書かれた文は、途中で改行されないようにブラウザが調整して表示してくれるが、このwbr要素を使うとその箇所で改行されて表示してくれる。\nThis is aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\u0026lt;br\u0026gt; That is aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\u0026lt;wbr\u0026gt;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\u0026lt;br\u0026gt;  表示例\n This is aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\nThat is aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\nins要素 ins要素は、文章に追加された部分であることを示す要素である。\n\u0026lt;p\u0026gt;締め切りは木曜日 午後5:00です。\u0026lt;/p\u0026gt; \u0026lt;ins\u0026gt;\u0026lt;p\u0026gt;(追記) 金曜日 午後5:00まで延長します\u0026lt;/p\u0026gt;\u0026lt;/ins\u0026gt;  表示例\n 締め切りは木曜日 午後5:00です。\n(追記) 金曜日 午後5:00まで延長します\n \ndel要素 del要素は、文章中で削除した部分を示すための要素である。\n\u0026lt;p\u0026gt;HTML5試験に\u0026lt;del\u0026gt;うっかり\u0026lt;/del\u0026gt;合格した。\u0026lt;/p\u0026gt;  表示例\n HTML5試験にうっかり合格した。\n\n"},{"idx":76,"href":"/docs/front-end/table/","title":"テーブル(表)","content":" テーブル(表) テーブル(表)を作る要素についてを述べる。\ntable要素 table要素は１つのテーブル(表)を表す要素である。\ntable要素の中で後述の行や列を表す要素を定義していく。\n一般的には、次の順で定義する。\n caption要素 colgroup要素 thead要素 tbody要素 tr要素 tfoot要素  これら及び、他のtable要素内で利用する要素についてを以下で述べていく。\ntr要素 tr要素(table rowの略)は、テーブルの１行を表すための要素である。\n具体的な使用例については、以下のtd要素で共に示す。\ntd要素 td要素(table data cellの略)は、テーブルの１行内の１列分のデータ(セル)を表すための要素である。\n先のtable要素、tr要素を含め、使用例を以下に示す。\n\u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;0,0\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;0,1\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;1,0\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;1,1\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt;  表示例\n   0,0 0,1   1,0 1,1   \nth要素 th要素(table header cellの略)は、見出し用のデータ(セル)を表すための要素である。\n使用例を以下に示す。\n\u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;0,0\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;0,1\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;1,0\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;1,1\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt;  表示例\n   0,0 0,1   1,0 1,1   \nthead要素 thead要素(table headerの略)は、見出しとなるデータ(セル)をグループ化する要素である。\nthead要素の中には、見出しとするtr要素を入れる。\n使用例を以下に示す。\n\u0026lt;table\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;0,0\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;0,1\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;0,2\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;1,0\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;1,1\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;1,2\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;2,0\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;2,1\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;2,2\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt;  表示例\n    0,0 0,1 0,2    1,0 1,1 1,2   2,0 2,1 2,2   \ntbody要素 tbody要素(table bodyの略)は、表の本体の部分をグループ化して表す要素である。\n使用例を以下に示す。\n\u0026lt;table\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;0,0\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;0,1\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;0,2\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;1,0\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;1,1\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;1,2\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;2,0\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;2,1\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;2,2\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt;  表示例\n    0,0 0,1 0,2     1,0 1,1 1,2    2,0 2,1 2,2   \ntfoot要素 tfoot要素(table footerの略)は、表のフッター部分を表す要素である。\n使用例\n\u0026lt;table\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;0,0\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;0,1\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;0,2\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;1,0\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;1,1\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;1,2\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;tfoot\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;2,0\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;2,1\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;2,2\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tfoot\u0026gt; \u0026lt;/table\u0026gt;  表示例\n    0,0 0,1 0,2     1,0 1,1 1,2     2,0 2,1 2,2    \ncaption要素 caption要素は、表のキャプション(タイトル)を示すための要素である。\n使用例\n\u0026lt;table\u0026gt; \u0026lt;caption\u0026gt;行列のインデックス\u0026lt;/caption\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;0,0\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;0,1\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;0,2\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;1,0\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;1,1\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;1,2\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;tfoot\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;2,0\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;2,1\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;2,2\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tfoot\u0026gt; \u0026lt;/table\u0026gt;  表示例\n  行列のインデックス   0,0 0,1 0,2     1,0 1,1 1,2     2,0 2,1 2,2    \ncolgroup要素 colgroup要素は、表の列をグループ化する要素である。\nspan属性でグループ化する列数を指定し、そこにwidthなどの属性を適用してやると、その列のセル全体に適用される。\n使用例\n\u0026lt;table\u0026gt; \u0026lt;caption\u0026gt;行列のインデックス\u0026lt;/caption\u0026gt; \u0026lt;colgroup span=\u0026quot;2\u0026quot; width=\u0026quot;100\u0026quot;\u0026gt; \u0026lt;colgroup span=\u0026quot;1\u0026quot; width=\u0026quot;200\u0026quot;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;0,0\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;0,1\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;0,2\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;1,0\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;1,1\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;1,2\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;tfoot\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;2,0\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;2,1\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;2,2\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tfoot\u0026gt; \u0026lt;/table\u0026gt;  表示例\n  行列のインデックス   0,0 0,1 0,2     1,0 1,1 1,2     2,0 2,1 2,2    \ncol要素 col要素は、span属性のないcolgroup要素によって表された１列以上の縦列を表す要素である。\n使用するにはcolgroup要素の中で利用する。\n使用例\n\u0026lt;table\u0026gt; \u0026lt;caption\u0026gt;行列のインデックス\u0026lt;/caption\u0026gt; \u0026lt;colgroup\u0026gt; \u0026lt;col span=\u0026quot;1\u0026quot; width=\u0026quot;50\u0026quot;\u0026gt; \u0026lt;col span=\u0026quot;1\u0026quot; width=\u0026quot;100\u0026quot;\u0026gt; \u0026lt;/colgroup\u0026gt; \u0026lt;colgroup span=\u0026quot;1\u0026quot; width=\u0026quot;200\u0026quot;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;0,0\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;0,1\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;0,2\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;1,0\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;1,1\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;1,2\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;tfoot\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;2,0\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;2,1\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;2,2\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tfoot\u0026gt; \u0026lt;/table\u0026gt;  表示例\n  行列のインデックス     0,0 0,1 0,2     1,0 1,1 1,2     2,0 2,1 2,2    \n"},{"idx":77,"href":"/docs/programming/machine_learning/neural_network/","title":"ニューラルネットワーク","content":" ニューラルネットワーク ニューラルネットワークとは、人間の神経細胞を模した数理モデルであるニューロンモデルを利用した機械学習のアルゴリズムである。\nニューロンモデルを幾層にも組み合わせて計算を行なっていく方法で、より多くのニューロンモデルを使用した物はディープラーニングとも呼ばれる。\n神経細胞 人間の脳にある神経細胞は核と軸索と呼ばれる部位からなり、軸索の先をシナプスと呼ばれるインターフェースで別の神経細胞に繋げる形で幾つにも繋がっている。\n神経細胞は、他の細胞から電気的なパルスを受け取り、また対応するシナプスの状態によりその電気パルスをどれほど受け取るか(シナプス伝達強度)が違ってくるため、神経細胞内の電位(膜電位)が大きく変化したりする。\nそして、膜電位がある一定の値(閾値)を超えると、その神経細胞は次の神経細胞へ、電気的なパルスを発信する。それが連続された構造になっている。(下図)\nニューロンモデル ニューロンモデルは、この神経細胞の動きを模した数理モデルで、下図のように表される。\n入力値は、正も負も値を取る実数(図中のx0〜xn-1)とし、それぞれにシナプス伝達強度とした重み(図中のw0〜wn-1)をかける。そしてその和を取ったものを入力総和(図中のa)として計算する。\n  $$ \\tag{1} a = w_{0} x_{0} + w_{1} x_{1} + \\cdots + w_{n-1} x_{n-1} $$ なお、図にもあるように、n-1番目の重みは切片としてそのまま用いるので、xn-1=1とする。\n$$ \\tag{2} a = w_{0} x_{0} + w_{1} x_{1} + \\cdots + w_{n-1} $$ 式(1)は以下のように書き換えられる。\n$$ \\tag{3} a = \\sum_{i=0}^{n-1} w_{i} x_{i} $$ そして、この入力総和aを、シグモイド関数を使って出力値yに置き換え、出力する。\n$$ \\tag{4} y = \\frac{1}{1 + \\exp(-a) } $$ この一連の流れは、教師あり学習で出てきたロジスティック回帰に似ており、重みや入力総和によって決定境界が引かれ、それを境に出力が0か1に別れる、とみることもできる。\n例えば、N(入力値の個数)=2、重みをw0=-2,w1=1,w2=2とした場合の出力値yのグラフは以下のようになる。\n（コード類はこちらのJupyter Notebookにまとめたのでご参考に）\nこの図より、直線-2x0+x1+2=0 (w0x0+w1x1+w2x2=0)を境に出力値は0か1に大きく分かれる事となる。\nニューラルネットワークモデル 先述のニューロンモデルをいくつも組み合わせた、ニューロンモデルの集合体のモデルのことをニューラルネットワークモデルという。\nニューラルネットワークモデルにはいくつか種類があるが、ここでは一方向にのみ流れるフィードフォワードニューラルネットを考える。\nここでは、入力層と出力層の間に中間層が1つの2層フィードフォワードニューラルネットワークモデルとする。下に図を示す。\n重み行列が2つあるので（中間層を第１層、出力層を第２層と呼ぶことからもある）、これから２層フィードフォワードニューラルネットワークモデルと呼ぶ。（入力層も合わせて３層と呼ぶこともある）\n中間層には、前述のニューロンモデルと同じように、ダミー入力として常に１の値をとるパラメータを加える。\n重み行列zにおいて、aiからbjへの重みをzjiとおくと、以下の式が成り立つ。\n$$ \\tag{5} b_{j} = \\sum_{i=0}^{n-1} z_{ji} a_{i} $$ 中間層では、この式(5)により算出した結果を、シグモイド関数に通すことで出力値を得る。出力値をc、シグモイド関数をh()とおくと、以下の式が成り立つ。\n$$ \\tag{6} c_{j} = h( b_{j} ) $$ ここで、シグモイド関数は入力総和から何らかの出力を決定づける関数ということで、活性化関数とも呼ばれている。\n次に出力層において、中間層の出力と重み行列から式(5)の計算を行なった最終的な出力値biに対して、最後にソフトマックス関数を適用することにより２層フィードフォワードニューラルネットワークモデルの出力値yiを得る。\n$$ \\tag{7} y_{i} = \\frac{ \\exp(a_{i}) }{ \\sum_{j=0}^{K-1} \\exp(a_{j}) } $$ ここまでの一連の処理をコードにまとめてみよう。\nと言いたいが、ここに記載するとかなり長くなるので、こちらのJupyter Notebookにコードを記載する。\nでは、この２層フィードフォワードニューラルネットワークモデルを利用した学習法を考えてみよう。\nその方法の一つを、次章で紹介する。\n"},{"idx":78,"href":"/docs/programming/file_io/file_index/","title":"ファイル","content":" ファイル ファイルを扱う手法についてをまとめる。\n ファイル入出力  ファイル読み込み ファイル書き込み  外部ライブラリの使用  外部ファイルのインポート   "},{"idx":79,"href":"/docs/programming/file_io/filewrite/","title":"ファイル書き込み","content":" ファイル書き込み ファイルを書き込む方法についてを示す。\nJava  読み込み時と同様に、ここではテキストファイルなど一般的なファイルに対する読み込み方法についてを示す。\nJavaでファイルを書き込むには以下の2つの方法がある。\n java.io.FileOutputStreamクラスを利用する java.io.FileWriterクラスを利用する  それぞれについて示す。\nFileOutputStream FileOutputStreamクラスはファイルからbyte単位で書き込みを行うストリームである。\nFileInputStreamと同様に、このクラスは宣言時(コンストラクタ)にString型でファイルのパスまたはFile型のオブジェクトを入力する。Fileクラスは宣言時(コンストラクタ)にファイルのパス(相対パス)を文字列型で入力してできるオブジェクトである。これにより、このファイルへの出力ストリームが得られる。\nFileOutputStream(String name) throws FileNotFoundException\nFileOutputStream(File file) throws FileNotFoundException\n作成した入力ストリームからバイトデータを書き込むメソッドとして、write()というメソッドがある。\nvoid write(int b) throws IOException\nvoid write(byte[] b) throws IOException\nこのメソッドは引数で指定されたバイトデータをファイル出力ストリームに書き出すメソッドである。\nFileOutputStreamクラスではこのメソッドを利用してファイルを書き込む。\nまた、書き込みが終わったら入力時と同様にして、出力ストリームを閉じるclose()メソッドを忘れずに行う。\nFileOutputStreamのjava実装例を示す。\nimport java.io.FileOutputStream; import java.io.File; import java.io.IOException; class Main{ public static void main(String args[]){ FileOutputStream fos = null; try{ fos = new FileOutputStream(new File(\u0026#34;testwrite.txt\u0026#34;)); fos.write(\u0026#34;testwrite\u0026#34;.getBytes()); fos.write(99); }catch (IOException e){ System.err.println(\u0026#34;IO Error\u0026#34;); }finally{ try{ fos.close(); }catch(IOException e){ } } } } 実行例は以下の通り。\n$ ls *.txt $ $ javac Main.java $ java Main $ ls *.txt testwrite.txt $ cat testwrite.txt testwritec$  FileWriterクラス FileWriterクラスはファイルからchar単位で書き込みを行う出力ストリームである。\nこのクラスもFileOutputStreamクラスと同様に、宣言時(コンストラクタ)にFile型のオブジェクトを入力する。これにより、このファイルからの入力ストリームが得られる。\nFileWriter(File file) throws FileNotFoundException\nFileWriter(String name) throws FileNotFoundException\n作成した出力ストリームでバイトデータを書き込むメソッドとして、こちらもwrite()というメソッドがある。\nvoid write(String str) throws IOException\nこのメソッドは引数に入力した文字列をバッファに書き込むメソッドである。\nこの時点ではバッファへの書き込みなので、ファイルへの書き込みは行われていない。\nファイルに書き込むにはここから、flush()というメソッドを利用して書き込む。\nvoid flush() throws IOException\nFileWriterクラスではこれらのメソッドを利用して書き込みを行う。\nまた、読み込みが終わったらこちらも入力ストリームを閉じるclose()メソッドを忘れずに行う。\nFileWriterのjava実装例を示す。\nimport java.io.FileWriter; import java.io.File; import java.io.IOException; class Main{ public static void main(String args[]){ FileWriter fw = null; try{ fw = new FileWriter(new File(\u0026#34;testwrite.txt\u0026#34;)); fw.write(\u0026#34;テスト\u0026#34;); fw.write(\u0026#34;2行目\u0026#34;); fw.flush(); }catch (IOException e){ System.err.println(\u0026#34;IO Error\u0026#34;); }finally{ try{ fw.close(); }catch(IOException e){ } } } } 実行例は以下の通り。\n$ ls $ javac Main.java $ $ ls *.txt testwrite.txt $ cat testwrite.txt testwritec$ $ javac Main.java $ java Main $ cat testwrite.txt テスト2行目 $   Python  Pythonでは関数openでファイルを開いた後、ファイルオブジェクトの関数write()を利用してファイルを書き込む。\nwrite(文字列)\nファイルへの書き込みを行う際にはopenで開く時にモードを \u0026lsquo;w\u0026rsquo; または \u0026lsquo;a\u0026rsquo; と必ず指定する。それ以外の時はwrite関数実行時にエラーになる。 モードが\u0026rsquo;w\u0026rsquo;のときはファイルに上書きされ、\u0026rsquo;a\u0026rsquo;の時はファイルの末尾に追記される形で書き込まれる。\nこちらも読み込みの時と同様に、作業が終わったら最後にファイルオブジェクトの関数close()を利用してファイルをクローズする。\nまた、書き込みにおいてもwith文が利用できる。with文を抜け出したとき、自動でファイルクローズも行うので便利。\nwith open(\u0026#39;ファイル名\u0026#39;,\u0026#39;モード\u0026#39;) as f: f.write(\u0026#39;ファイルに書き込む文字列\u0026#39;) 実行例を以下に示す。\n$ ls test.txt $ cat test.txt aaa bbb ccc ddd $ python \u0026gt;\u0026gt;\u0026gt; #\u0026#39;w\u0026#39;のときは上書きされて書き込まれる \u0026gt;\u0026gt;\u0026gt; f = open(\u0026#39;test.txt\u0026#39;,\u0026#39;w\u0026#39;) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; f.write(\u0026#39;overwrote!!\u0026#39;) 12 \u0026gt;\u0026gt;\u0026gt; f.close() \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; quit() $ cat test.txt overwrote!! $ python \u0026gt;\u0026gt;\u0026gt; # \u0026#39;a\u0026#39;の時はファイルの末尾から追記される形で書き込まれる \u0026gt;\u0026gt;\u0026gt; f = open(\u0026#39;test.txt\u0026#39;,\u0026#39;a\u0026#39;) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; f.write(\u0026#39;aaa\u0026#39;) 3 \u0026gt;\u0026gt;\u0026gt; f.write(\u0026#39;bbb\u0026#39;) 3 \u0026gt;\u0026gt;\u0026gt; f.write(\u0026#39;ccc\u0026#39;) 3 \u0026gt;\u0026gt;\u0026gt; f.close() \u0026gt;\u0026gt;\u0026gt; quit() $ cat test.txt overwrote!!aaabbbccc $ python \u0026gt;\u0026gt;\u0026gt; # with文を使って書き込む \u0026gt;\u0026gt;\u0026gt; with open(\u0026#39;test.txt\u0026#39;,\u0026#39;w\u0026#39;) as f: ... f.write(\u0026#39;use with and overwrite\u0026#39;) ... 22 \u0026gt;\u0026gt;\u0026gt; quit() $ cat test.txt use with and overwrite   "},{"idx":80,"href":"/docs/programming/file_io/fileopen/","title":"ファイル読み込み","content":" ファイル読み込み ファイルを読み込む方法についてを示す。\nJava  Javaではプロパティファイル(.propertiesで終わるファイル)に関しては専用のライブラリがありそれを利用して読み込むが、ここではテキストファイルなど一般的なファイルに対する読み込み方法についてを示す。\nJavaでファイルを読み込むには以下の2つの方法がある。\n java.io.FileInputStreamクラスを利用する java.io.FileReaderクラスを利用する  それぞれについて示す。\nFileInputStreamクラス FileInputStreamクラスはファイルからbyte単位で読み込みを行うストリームである。\nストリームとはデータの送受信を連続的に行うプログラムのことで、データを読み込む時のストリームは入力ストリームという。\nこのクラスは宣言時(コンストラクタ)にString型でファイルのパスまたはFile型のオブジェクトを入力する。Fileクラスは宣言時(コンストラクタ)にファイルのパス(相対パス)を文字列型で入力してできるオブジェクトである。これにより、このファイルからの入力ストリームが得られる。\nFileInputStream(String name) throws FileNotFoundException\nFileInputStream(File file) throws FileNotFoundException\n作成した入力ストリームからバイトデータを読み込むメソッドとして、read()というメソッドがある。\nint read() throws IOException\nこのメソッドは入力ストリームからバイトデータを読み込み、ファイルの終わりに達すると-1を返すメソッドである。 FileInputStreamクラスではこのメソッドを利用してファイルを読み込む。\nまた、読み込みが終わったら入力ストリームを閉じるclose()メソッドを忘れずに行う。\nFileInputStreamのjava実装例を示す。\nimport java.io.FileInputStream; import java.io.File; import java.io.IOException; class Main{ public static void main(String args[]){ FileInputStream fis = null; try{ fis = new FileInputStream(new File(\u0026#34;test.txt\u0026#34;)); int data = 0; while((data = fis.read()) != -1){ //ファイルから読み込んだバイトデータを表示  System.out.println(data); } }catch (IOException e){ System.err.println(\u0026#34;IO Error\u0026#34;); }finally{ try{ fis.close(); }catch(IOException e){ } } } } 実行例は以下の通り。\n$ ls test.txt Main.java $ cat test.txt aaa bbb ccc ddd $ javac Main.java $ java Main 97 97 97 10 98 98 98 10 99 99 99 10 100 100 100 10 101 101 101  FileReaderクラス FileReaderクラスはファイルからchar単位で読み込みを行う入力ストリームである。\nこのクラスもFileInputStreamクラスと同様に、宣言時(コンストラクタ)にString型でファイルパスまたはFile型のオブジェクトを入力する。これにより、このファイルからの入力ストリームが得られる。\nFileReader(File file) throws FileNotFoundException\nFileReader(String name) throws FileNotFoundException\n作成した入力ストリームからバイトデータを読み込むメソッドとして、こちらもread()というメソッドがある。\nint read() throws IOException\nこのメソッドは入力ストリームから１文字を読み込み、ファイルの終わりに達すると-1を返すメソッドである。\n返すデータはint型だが、このデータはUnicode(16bitデータ)に対応しており、char型に変換すれば対応する文字になって表示してくれる。\nFileReaderクラスではこのメソッドを利用してファイルを読み込む。\nまた、読み込みが終わったらこちらも入力ストリームを閉じるclose()メソッドを忘れずに行う。\nFileReaderのjava実装例を示す。\nimport java.io.FileReader; import java.io.File; import java.io.IOException; class Main{ public static void main(String args[]){ FileReader fr = null; try{ fr = new FileReader(new File(\u0026#34;test.txt\u0026#34;)); int data = 0; while((data = fr.read()) != -1){ //読み込んだデータをchar型で表示する  System.out.print((char)data); } }catch (IOException e){ System.err.println(\u0026#34;IO Error\u0026#34;); }finally{ try{ fr.close(); }catch(IOException e){ } } } } 実行例は以下の通り。\n$ ls test.txt Main.java $ cat test.txt aaa bbb ccc ddd $ javac Main.java $ java Main aaa bbb ccc ddd   Python  Pythonでは組み込み関数open()を利用してファイルを開き、読み込む。\nopen(ファイル名,モード)\nモードとは読み込んだファイルに対する権限であり、読み込み専用なら \u0026lsquo;r\u0026rsquo; 、書き出し専用なら \u0026lsquo;w\u0026rsquo;、読み書き両方なら \u0026lsquo;r+\u0026rsquo; というように設定する。\nopen関数で開いたファイルは、ファイルオブジェクトとして返される。\n読み込んだファイルの中身を表示したい場合はファイルオブジェクトの関数read()を利用する。\nread(サイズ)\n引数にはサイズを入力し、実行するとそのサイズ分を読み込んで返してくれる。サイズを省略した場合はファイルの中身を全て読み込んで返す。\nまた、似たような関数としてreadline()という関数もあり、これはファイルオブジェクトから1行読み込んだ内容を返す。\nまた、openで開いたファイルでの作業が終わったら、最後にファイルオブジェクトの関数close()を利用してファイルをクローズする。これによりオープンしたファイルが占めていたシステムリソースを全て開放する。\n一連の操作についてここまで述べたが、実はこれらの動作を行う際はwith文を使うのが非常に便利である。\nその利点は、with文から抜けるときに自動的にファイルクローズを実行してくれるからであり（途中に例外が発生しても行われる）、同様の処理をtry-except文で実装するよりも簡略化できる。\n使用法は以下の通り。\nwith open(\u0026#39;ファイル名\u0026#39;,\u0026#39;モード\u0026#39;) as f: data = f.read() 実行例を以下に示す。\n$ ls test.txt $ cat test.txt aaa bbb ccc ddd $ python \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; f = open(\u0026#39;test.txt\u0026#39;,\u0026#39;r\u0026#39;) \u0026gt;\u0026gt;\u0026gt; f \u0026lt;_io.TextIOWrapper name=\u0026#39;test.txt\u0026#39; mode=\u0026#39;r\u0026#39; encoding=\u0026#39;cp932\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #ファイルから1行読み込んで返す \u0026gt;\u0026gt;\u0026gt; f.readline() \u0026#39;aaa\\n\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #(前回の終了箇所から)4バイト読み込んで返す \u0026gt;\u0026gt;\u0026gt; f.read(4) \u0026#39;bbb\\n\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; f.read(2) \u0026#39;cc\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #(前回の終了箇所から)全て読み込んで返す \u0026gt;\u0026gt;\u0026gt; f.read() \u0026#39;c\\nddd\\n\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #ファイルをクローズする \u0026gt;\u0026gt;\u0026gt; f.close() \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #with文を使ってファイルを読み込む \u0026gt;\u0026gt;\u0026gt; with open(\u0026#39;test.txt\u0026#39;,\u0026#39;r\u0026#39;) as f: ... print(f.read()) ... aaa bbb ccc ddd \u0026gt;\u0026gt;\u0026gt; #fがクローズされているか確認 \u0026gt;\u0026gt;\u0026gt; f.closed True \u0026gt;\u0026gt;\u0026gt;    "},{"idx":81,"href":"/docs/programming/machine_learning/filter/","title":"フィルターと畳み込みニューラルネットワーク","content":" フィルターと畳み込みニューラルネットワーク 先述の手書き文字認識の章で、活性化関数を変えるなどして認識精度の向上を図ったが、もっと精度を上げるための方法はないだろうか？\nここで、先述の方法では、入力画像を１次元のベクトルに変換して学習を行わせており、２次元画像の空間の情報を考慮していないというところに着目する。（要は、画像の縦方向の関連性、画像の直線や曲線と言ったような画像の情報を見ていないということ。）\n画像の空間の情報を取り出す方法として、空間フィルターという画像処理の手法がある。\n空間フィルター 空間フィルターは、２次元の行列で表される。フィルターを画像の一部分に当て嵌め、画像の一部分とフィルターとの要素の積の和を、画像をスライドさせながら画像の全領域で求めていく。\nこのような計算を、畳み込み演算 (Convolution)と呼ぶ。\n例として、以下のような(縦のエッジを強調する)空間フィルターを定義し、適用してみよう。\n\u0026gt;\u0026gt;\u0026gt; #空間フィルター \u0026gt;\u0026gt;\u0026gt; import numpy as np \u0026gt;\u0026gt;\u0026gt; filter = np.array([[0,1,1],[0,1,1],[0,1,1]]) \u0026gt;\u0026gt;\u0026gt; print(filter) [[0 1 1] [0 1 1] [0 1 1]] 畳み込み演算を、以下のように画像の全要素にスライドさせながら計算していき、その和を計算して値を算出していく。\nこの例から、画像の位置(i,j)のピクセル値をx(i,j)、3*3のフィルターをh(i,j)とした場合、畳み込み演算で得られる値をg(i,j)とおくと、以下のような式が成り立つ。\n  $$ \\tag{1} g(i,j) = \\sum_{u=-1}^{1} \\sum_{v=-1}^{1} x(i+u,j+v) h(u+1,v+1) $$ では、先程の画像にこのフィルターを適用して図示してみよう。以下にコードを示す。\n#フィルター適用 def do_filter(x,f): filtered=np.zeros((len(x),len(x[0]))) for i in range(len(x)): if(i==0 or i==len(x)-1): continue else: for j in range(len(x[0]-3)): if(j==0 or j==len(x[0])-1): continue else: gij=0 for u in range(-1,2): for v in range(-1,2): gij+=x[i+u][j+v]*f[u+1][v+1] filtered[i][j]=gij return filtered #図示 x0_filtered=do_filter(x0,filter) plt.figure() plt.imshow(x0_filtered,interpolation=\u0026#39;nearest\u0026#39;,vmin=0,vmax=255,cmap=\u0026#39;binary\u0026#39;) plt.show() 実行結果\nここで、フィルターを適用すると元の画像の一番外側の行列のデータが算出されず失われるという欠点がある。\nそこで、一番外側のデータも算出させるために、元の画像データの外側に一つ分からのデータを追加させておく。こうすることで、元の画像データ全ての要素にフィルターが適用される。この追加する一列分の空のデータのことをパディングという。例を以下に示す。\nまた、画像の全要素に適用するためにフィルターを１要素ずつずらしていたが、これは2でも3でも任意の間隔でずらすことができる。この間隔のことをストライドという。\n畳み込みニューラルネットワーク フィルターを使ったニューラルネットワークを畳み込みニューラルネットワーク、またはコンボリューションニューラルネットワーク (Convolution Neural Network:CNN)と呼ぶ。\nフィルターを利用することで様々な画像処理が行えるが、このCNNでは、フィルター自体を学習させる。\n入力として、元となる入力画像と、フィルターを何種か用意する。\nそして、入力画像を用意したフィルター全てで適用する。その結果、入力は入力画像の要素数×フィルターの枚数となる。\nそれらをニューラルネットワークの入力層に入力し、最終的に10個の出力層に出力させる。\n一連の流れをKerasで実装した例を以下に示す。\n#CNN model2=Sequential() #コンボリューション層定義、3*3のフィルターを8枚使用、パディング使用(same)、input_shape:入力画像のサイズ model2.add(Conv2D(8,(3,3),padding=\u0026#39;same\u0026#39;,input_shape=(28,28,1),activation=\u0026#39;relu\u0026#39;)) #コンボリューション層の出力の次元を(バッチ数、フィルター数*出力画像縦幅*出力画像横幅)にさせる model2.add(Flatten()) #出力層定義、10個で活性化関数はソフトマックス関数 model2.add(Dense(10,activation=\u0026#39;softmax\u0026#39;)) model2.compile(loss=\u0026#39;categorical_crossentropy\u0026#39;,optimizer=Adam(),metrics=[\u0026#39;accuracy\u0026#39;]) history=model2.fit(x_train,y_train,epochs=20,batch_size=1000,verbose=1,validation_data=(x_test,y_test)) score=model2.evaluate(x_test,y_test,verbose=0) print(\u0026#39;交差エントロピー誤差:\u0026#39;,score[0]) print(\u0026#39;正答率:\u0026#39;,score[1]) このモデルで、先述の時と同じようにテストデータを評価すると以下のようになる。\n先述までの結果と比べると、遥かに分類精度が良くなっていることがわかる。\n空間フィルター、畳み込みニューラルネットワークにより空間情報を取り入れることにより、分類精度が向上する。この技術は、手書き数字だけでなく、その他の画像認識にも応用可能である。\nなお、前章と合わせた一連の実装例をこちらのNotebookに記載したので、参考として載せておく。\n"},{"idx":82,"href":"/docs/programming/class_func/field/","title":"フィールド(クラス変数・インスタンス変数)","content":" フィールド(クラス変数・インスタンス変数) フィールド変数とはクラス内に定義する変数のこと。\nその中でも主に、クラス内で定義して全てのインスタンス間で値を共有する変数をクラス変数、\nインスタンス毎に独立して値を保持する変数をインスタンス変数という。\n言語により呼び名が違う？ので注意\nJava  Javaでのフィールド変数定義方法は以下の通り。\nclass クラス名{ //フィールド変数 [static] (フィールド変数１　定義) [static] (フィールド変数２　定義) ・・・ //文 }  クラス変数にしたい時は変数の前にstaticをつける。\nstaticをつけない場合はインスタンス変数となる。\nフィールド変数を参照したい時は、クラス変数はクラス(インスタンス)名.変数名で参照できる。\nインスタンス変数はインスタンス毎で独立のため、インスタンス名.変数名 で参照すること。クラス名を使っても参照はできない(コンパイルエラーとなる)\n実行例は以下の通り。\nclass Car { //フィールド変数  static String name = \u0026#34;lexus\u0026#34;; String number = \u0026#34;\u0026#34;; String owner = \u0026#34;\u0026#34;; } class Main{ public static void main(String args[]){ Car c1 = new Car(); c1.number=\u0026#34;100-1010\u0026#34;; c1.owner=\u0026#34;ai-ueo\u0026#34;; System.out.println(\u0026#34;c1:\u0026#34; + c1.name + \u0026#34; \u0026#34; + c1.number + \u0026#34; \u0026#34; + c1.owner); Car c2 = new Car(); c2.number=\u0026#34;200-2020\u0026#34;; c2.owner=\u0026#34;kaki-kukeko\u0026#34;; System.out.println(\u0026#34;c2:\u0026#34; + c2.name + \u0026#34; \u0026#34; + c2.number + \u0026#34; \u0026#34; + c2.owner); System.out.println(\u0026#34;carname :\u0026#34;+Car.name); //Car.name -\u0026gt;クラス変数なのでクラス名.変数名で参照できる  System.out.println(\u0026#34;carnum :\u0026#34;+Car.number); //Car.number -\u0026gt;インスタンス変数なのでクラス名からは参照できない(エラー)  } } 実行結果（コンパイルエラー発生）\n$ javac Main.java Main.java:22: エラー: staticでない変数 numberをstaticコンテキストから参照することはできません System.out.println(\u0026quot;carnum :\u0026quot;+Car.number); ^ エラー1個  そのためエラー箇所をコメントアウトして再度実行する\n// System.out.println(\u0026#34;carnum :\u0026#34;+Car.number); 実行結果\n$ javac Main.java $ java Main c1:lexus 100-1010 ai-ueo c2:lexus 200-2020 kaki-kukeko carname :lexus   Python  Pythonにもクラス変数とインスタンス変数がある。\nクラス変数はクラス内、各関数外に定義し、クラス、インスタンスオブジェクトから参照することができる。\nインスタンス変数は、後述するがクラスのinit関数で定義する。ここで定義した変数はインスタンスからしか参照できない。\n使用例を以下に示す。\n\u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; class Car: ... name = \u0026#34;lexus\u0026#34; ... def __init__(self,n,o): ... self.number=n ... self.owner=o ... \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; c1=Car(\u0026#34;100-1010\u0026#34;,\u0026#34;ai-ueo\u0026#34;) \u0026gt;\u0026gt;\u0026gt; c2=Car(\u0026#34;200-2020\u0026#34;,\u0026#34;kaki-kukeko\u0026#34;) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(Car.name) lexus \u0026gt;\u0026gt;\u0026gt; print(Car.number) Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; AttributeError: type object \u0026#39;Car\u0026#39; has no attribute \u0026#39;number\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(c1.name) lexus \u0026gt;\u0026gt;\u0026gt; print(c1.number) 100-1010 \u0026gt;\u0026gt;\u0026gt; print(c1.owner) ai-ueo \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(c2.name) lexus \u0026gt;\u0026gt;\u0026gt; print(c2.number) 200-2020 \u0026gt;\u0026gt;\u0026gt; print(c2.owner) kaki-kukeko \u0026gt;\u0026gt;\u0026gt;    "},{"idx":83,"href":"/docs/front-end/form/","title":"フォーム","content":" フォーム フォームを作成するための要素についてを述べる。\nform要素 form要素はフォームを構成する要素である。\n使用する主な属性は以下の通り。\n ・ action ・・・　 フォームの送信先のURL   ・ autocomplete ・・・　 フォーム内のオートコンプリート機能のデフォルト値   ・ method ・・・　 フォームのデータを送信する際のHTTPメソッドを指定   ・ name ・・・　 フォームの名前   ・ novalidate ・・・　 入力(選択)内容のチェックを問わない   ・ target ・・・　 フォームの送信結果を表示させるウィンドウやタブなどの名前   実際の使用例は以下の要素のところで述べる。\ninput要素 input要素はform要素内で使われる要素で、フォームの入力を示すための要素である。\nフォームの入力にはいくつか種類があり、input要素でtype属性の値を利用することで使い分ける。\ntype属性に指定できる値と意味は以下の通り。\n ・ text ・・・　 テキスト入力フィールド(デフォルト)   ・ password ・・・　 パスワード入力用のテキスト入力フィールド   ・ search ・・・　 検索用入力フィールド   ・ email ・・・　 メールアドレス用入力フィールド   ・ url ・・・　 URL入力フィールド   ・ tel ・・・　 電話番号入力フィールド   ・ number ・・・　 数値入力フィールド   ・ range ・・・　 スライダー   ・ checkbox ・・・　 チェックボックス   ・ radio ・・・　 ラジオボタン   ・ submit ・・・　 送信ボタン   ・ reset ・・・　 リセットボタン   ・ button ・・・　 汎用ボタン   ・ image ・・・　 画像の送信ボタン   ・ file ・・・　 送信するファイルを選択する   ・ color ・・・　 色の入力   ・ date ・・・　 日付の入力   ・ month ・・・　 年と月の入力   ・ week ・・・　 年と週の入力   ・ time ・・・　 時刻の入力   ・ datetime-local ・・・　 日付と時刻の入力   ・ hidden ・・・　 表示させずに送信するテキスト   また、type属性の他に指定できる属性はと意味は以下の通り。\n ・ accept ・・・　 type=\"file\"の時に入力できるファイルの種類   ・ autocomplete ・・・　 オートコンプリート機能のオンオフ   ・ autofocus ・・・　 ページを読み込んだらこの要素にフォーカスする   ・ checked ・・・　 チェックボックス・ラジオボタンが選択済みになっていることを示す   ・ formaction ・・・　 フォームの送信先のURL   ・ formmethod ・・・　 フォームを送信する際に使うHTTPメソッド   ・ formnovalidate ・・・　 入力内容のチェックを行わない   ・ width ・・・　 幅   ・ height ・・・　 高さ   ・ max ・・・　 最大値(type属性により異なる)   ・ maxlength ・・・　 最大文字数   ・ min ・・・　 最小値(type属性により異なる)   ・ minlength ・・・　 最小文字数   ・ max ・・・　 最大値(type属性により異なる)   ・ multiple ・・・　 複数の入力を許可する   ・ placeholder ・・・　 プレースホルダー   ・ required ・・・　 入力を必須にする   使用例\n\u0026lt;form\u0026gt; \u0026lt;table style=\u0026quot;border:none;\u0026quot;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:none;\u0026quot;\u0026gt;text:\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:none;\u0026quot;\u0026gt;\u0026lt;input type=\u0026quot;text\u0026quot;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:none;\u0026quot;\u0026gt;password\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:none;\u0026quot;\u0026gt;\u0026lt;input type=\u0026quot;password\u0026quot;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:none;\u0026quot;\u0026gt;search\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:none;\u0026quot;\u0026gt;\u0026lt;input type=\u0026quot;search\u0026quot;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:none;\u0026quot;\u0026gt;email\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:none;\u0026quot;\u0026gt;\u0026lt;input type=\u0026quot;email\u0026quot;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:none;\u0026quot;\u0026gt;url\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:none;\u0026quot;\u0026gt;\u0026lt;input type=\u0026quot;url\u0026quot;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:none;\u0026quot;\u0026gt;tel\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:none;\u0026quot;\u0026gt;\u0026lt;input type=\u0026quot;tel\u0026quot;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:none;\u0026quot;\u0026gt;number\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:none;\u0026quot;\u0026gt;\u0026lt;input type=\u0026quot;number\u0026quot;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:none;\u0026quot;\u0026gt;range\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:none;\u0026quot;\u0026gt;\u0026lt;input type=\u0026quot;range\u0026quot;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:none;\u0026quot;\u0026gt;checkbox\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:none;\u0026quot;\u0026gt;\u0026lt;input type=\u0026quot;checkbox\u0026quot;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:none;\u0026quot;\u0026gt;radio\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:none;\u0026quot;\u0026gt;\u0026lt;input type=\u0026quot;radio\u0026quot;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:none;\u0026quot;\u0026gt;reset\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:none;\u0026quot;\u0026gt;\u0026lt;input type=\u0026quot;reset\u0026quot;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:none;\u0026quot;\u0026gt;button\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:none;\u0026quot;\u0026gt;\u0026lt;input type=\u0026quot;button\u0026quot;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:none;\u0026quot;\u0026gt;image\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:none;\u0026quot;\u0026gt;\u0026lt;input type=\u0026quot;image\u0026quot; src=\u0026quot;/img/front-end/img.jpg\u0026quot; width=25% height=25%\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:none;\u0026quot;\u0026gt;color\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:none;\u0026quot;\u0026gt;\u0026lt;input type=\u0026quot;color\u0026quot;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:none;\u0026quot;\u0026gt;date\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:none;\u0026quot;\u0026gt;\u0026lt;input type=\u0026quot;date\u0026quot;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:none;\u0026quot;\u0026gt;month\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:none;\u0026quot;\u0026gt;\u0026lt;input type=\u0026quot;month\u0026quot;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:none;\u0026quot;\u0026gt;week\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:none;\u0026quot;\u0026gt;\u0026lt;input type=\u0026quot;week\u0026quot;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:none;\u0026quot;\u0026gt;time\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:none;\u0026quot;\u0026gt;\u0026lt;input type=\u0026quot;time\u0026quot;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:none;\u0026quot;\u0026gt;datetime-local\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:none;\u0026quot;\u0026gt;\u0026lt;input type=\u0026quot;datetime-local\u0026quot;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:none;\u0026quot;\u0026gt;hidden\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:none;\u0026quot;\u0026gt;\u0026lt;input type=\u0026quot;hidden\u0026quot;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/form\u0026gt;  表示例（ブラウザによっては正しく表示されない場合もあります）\n   text:    password    search    email    url    tel    number    range    checkbox    radio    reset    button    image    color    date    month    week    time    datetime-local    hidden     \ntextarea要素 textarea要素は、複数行のテキスト入力フィールドとなる要素である。\n使用する主な属性は以下の通り。\n ・ cols ・・・　 １行で入力できる文字数   ・ rows ・・・　 入力できる行数   ・ autocomplete ・・・　 オートコンプリート機能のオン   ・ form ・・・　 特定のform要素と結びつける(form要素のid属性の値を指定)   ・ maxlength ・・・　 最大文字数   ・ placeholder ・・・　 プレースホルダー(入力欄に薄く表示する説明のようなもの)   使用例\n入力： \u0026lt;textarea cols=\u0026quot;20\u0026quot; rows=\u0026quot;5\u0026quot; autocomplete=\u0026quot;on\u0026quot; maxlength=\u0026quot;80\u0026quot; placeholder=\u0026quot;20文字/行 5列まで、最大80文字\u0026quot;\u0026gt;\u0026lt;/textarea\u0026gt;  表示例\n 入力：  \nbutton要素 button要素は、ボタンを表示させる要素である。要素内の内容はラベルとして、ボタンに表示される。\n使用する主な属性は以下の通り。\n ・ type ・・・　 ボタンの種類(submit,reset,menu,buttonのいずれか)   ・ menu ・・・　 表示させるメニュー   ・ form ・・・　 特定のform要素と結びつける(form要素のid属性の値を指定)   ・ formaction ・・・　 フォームの送信先のURL   ・ formmethod ・・・　 フォームのデータを送信する際のHTTPメソッド   ・ name ・・・　 フォーム部品の名前   ・ value ・・・　 フォームのデータを送信する際に使用される値   使用例\n\u0026lt;form id=\u0026quot;button\u0026quot;\u0026gt; \u0026lt;textarea cols=\u0026quot;20\u0026quot; rows=\u0026quot;4\u0026quot; placeholder=\u0026quot;何か書いてresetボタンを押すと？\u0026quot; form=\u0026quot;button\u0026quot;\u0026gt;\u0026lt;/textarea\u0026gt; \u0026lt;button type=\u0026quot;button\u0026quot; name=\u0026quot;test\u0026quot; form=\u0026quot;button\u0026quot;\u0026gt; buttonテスト \u0026lt;/button\u0026gt; \u0026lt;button type=\u0026quot;reset\u0026quot; name=\u0026quot;resettest\u0026quot; form=\u0026quot;button\u0026quot;\u0026gt; resetテスト \u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt;  表示例\n \nbuttonテスト \nresetテスト   \nselect要素 select要素は、選択肢の中から選ぶ形式のフォーム部品を示す要素である。\nフォーム部品自体はselect要素で示し、中身の選択肢は後述するoption要素・optgroup要素で示す。\nselect要素で使用する主な属性は以下の通り。\n ・ multiple ・・・　 複数の入力・選択を許可する   ・ size ・・・　 表示させる項目数   ・ autocomplete ・・・　 オートコンプリート機能のオン   ・ form ・・・　 特定のform要素と結びつける(form要素のid属性の値を指定)   ・ name ・・・　 フォーム部品の名前   ・ required ・・・　 入力・選択が必須であることを示す   使用例は下記、option要素の所で示す。\noption要素 option要素は、前述のselect要素またはdatalist要素の選択肢となる要素である。\n要素の内容には、表示させたい内容を入力する。\n使用する主な属性は以下の通り。\n ・ selected ・・・　 デフォルトで選択済みの状態にする   ・ label ・・・　 ブラウザに表示させる選択肢名(要素内容よりも優先する)   ・ value ・・・　 submit等でサーバーに送信する値(要素内容よりも優先する)   前述のselect要素を使って、例を示す。\n\u0026lt;select\u0026gt; \u0026lt;option selected \u0026gt;選択肢その１\u0026lt;/option\u0026gt; \u0026lt;option label=\u0026quot;ラベルに書いた選択肢その２\u0026quot;\u0026gt;選択肢その２\u0026lt;/option\u0026gt; \u0026lt;option\u0026gt;選択肢その３\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt;  表示例\n  選択肢その１ 選択肢その２ 選択肢その３  \noptgroup要素 optgroup要素は、select要素内のoption要素をグループ化して、そこにグループの名前（ラベル）をつける要素である。\nグループに名前をつけるにはlabel属性を利用する。\n使用例\n\u0026lt;select\u0026gt; \u0026lt;optgroup label=\u0026quot;選択肢\u0026quot;\u0026gt; \u0026lt;option selected \u0026gt;選択肢その１\u0026lt;/option\u0026gt; \u0026lt;option label=\u0026quot;ラベルに書いた選択肢その２\u0026quot;\u0026gt;選択肢その２\u0026lt;/option\u0026gt; \u0026lt;option\u0026gt;選択肢その３\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt;  表示例\n  選択肢その１ 選択肢その２ 選択肢その３  \ndatalist要素 datalist要素は、input要素にサジェストを追加するための要素である。\n実際のサジェストの内容は、前述のoption要素・optgroup要素を利用して表現する。\ndatalist要素とinput要素を関連付けるには、datalist要素のid属性の値をinput要素のlist属性に指定する。\n使用例\n\u0026lt;p\u0026gt;行きたい場所は? \u0026lt;input type=\u0026quot;text\u0026quot; list=\u0026quot;place\u0026quot;\u0026gt; \u0026lt;datalist id=\u0026quot;place\u0026quot;\u0026gt; \u0026lt;option\u0026gt;東京\u0026lt;/option\u0026gt; \u0026lt;option\u0026gt;横浜\u0026lt;/option\u0026gt; \u0026lt;option\u0026gt;京都\u0026lt;/option\u0026gt; \u0026lt;/datalist\u0026gt; \u0026lt;/p\u0026gt;  表示例\n 行きたい場所は? 東京 横浜 京都  \nmeter要素 meter要素は、メーター（ゲージ)を示すための要素である。\n具体的には、特定の範囲内で指定した位置を示すときに利用する。\n使用する主な属性は以下の通り。\n ・ value ・・・　 要素の現在値   ・ min ・・・　 メーターの範囲の下限   ・ max ・・・　 メータの範囲の上限   使用例\n\u0026lt;p\u0026gt;使用量状況： \u0026lt;meter min=\u0026quot;0\u0026quot; max=\u0026quot;100\u0026quot; value=\u0026quot;45\u0026quot;\u0026gt; \u0026lt;/meter\u0026gt; \u0026lt;/p\u0026gt;  表示例\n 使用量状況：  \nprogress要素 progress要素は、タスクの進み具合を示すゲージを示すための要素である。\n使用する属性は以下の通り。\n ・ value ・・・　 要素の現在値   ・ max ・・・　 全体量   使用例\nNow loading...: \u0026lt;progress value=\u0026quot;45\u0026quot; max=\u0026quot;100\u0026quot;\u0026gt;\u0026lt;/progress\u0026gt;  表示例\n Now loading\u0026hellip;:  \noutput要素 output要素は、計算式の計算結果、またはユーザーの操作結果を示すための要素である。\n使用する属性は以下の通り。\n ・ for ・・・　 計算の元となったフォームの部品   ・ name ・・・　 フォーム部品の名前   使用例\n\u0026lt;form oninput=\u0026quot;result.value=a.valueAsNumber+b.valueAsNumber\u0026quot;\u0026gt; \u0026lt;input name=\u0026quot;a\u0026quot; value=\u0026quot;20\u0026quot; type=\u0026quot;number\u0026quot;\u0026gt; + \u0026lt;input name=\u0026quot;b\u0026quot; value=\u0026quot;30\u0026quot; type=\u0026quot;number\u0026quot;\u0026gt; = \u0026lt;output for=\u0026quot;a b\u0026quot; name=\u0026quot;result\u0026quot;\u0026gt;\u0026lt;/output\u0026gt;\t\u0026lt;/form\u0026gt;  表示例\n + = \n \nkeygen要素 keygen要素は、公開鍵・秘密鍵のペアを生成するための要素である。\n実行すると、秘密鍵はローカルに保存され、公開鍵はサーバー側に送られる。\n ・ keytype ・・・　 生成する暗号鍵の種類(rsaなど)   ・ challenge ・・・　 生成された公開鍵とともに送られる文字列   ・ name ・・・　 form要素と関連づけるための値   (実行例略)\nlabel要素 label要素は、その要素内容をフォームの部品と紐づけるための要素である。\n紐づけられたラベルは、フォームの部品と一体化してユーザの操作に一緒に反応されるようになる。\n紐づけるための方法は\n label要素の中に、要素内容と一緒に関連づけたいフォームの部品の要素を入れる フォーム部品の要素にid属性を指定し、label要素のfor属性にもそのid属性と同じ値を指定する  である。\n使用例\n\u0026lt;form\u0026gt; \u0026lt;label for=\u0026quot;yes\u0026quot;\u0026gt;\u0026lt;input type=\u0026quot;radio\u0026quot; name=\u0026quot;ans\u0026quot; id=\u0026quot;yes\u0026quot;\u0026gt;はい\u0026lt;/label\u0026gt; \u0026lt;label for=\u0026quot;no\u0026quot;\u0026gt;\u0026lt;input type=\u0026quot;radio\u0026quot; name=\u0026quot;ans\u0026quot; id=\u0026quot;no\u0026quot;\u0026gt;いいえ\u0026lt;/label\u0026gt; \u0026lt;/form\u0026gt;  表示例\n  はい いいえ  \nfieldset要素 fieldset要素は、formに関する要素をグループ化するための要素である。\n使用する属性は以下の通り。\n ・ form ・・・　 関連づけるform要素のid属性の値   ・ name ・・・　 form要素と関連づけるための値   使用例\n\u0026lt;form id=\u0026quot;ticket\u0026quot;\u0026gt; \u0026lt;fieldset form=\u0026quot;ticket\u0026quot;\u0026gt; \u0026lt;p\u0026gt; 乗車駅→降車駅\u0026lt;br\u0026gt; \u0026lt;input type=\u0026quot;text\u0026quot; width=\u0026quot;10\u0026quot;\u0026gt; → \u0026lt;input type=\u0026quot;text\u0026quot; width=\u0026quot;10\u0026quot;\u0026gt; \u0026lt;/p\u0026gt; 大人： \u0026lt;label\u0026gt;\u0026lt;input type=\u0026quot;radio\u0026quot; name=\u0026quot;adult\u0026quot; id=\u0026quot;zero\u0026quot;\u0026gt;０人\u0026lt;/label\u0026gt; \u0026lt;label\u0026gt;\u0026lt;input type=\u0026quot;radio\u0026quot; name=\u0026quot;adult\u0026quot; id=\u0026quot;one\u0026quot;\u0026gt;１人\u0026lt;/label\u0026gt; \u0026lt;label\u0026gt;\u0026lt;input type=\u0026quot;radio\u0026quot; name=\u0026quot;adult\u0026quot; id=\u0026quot;two\u0026quot;\u0026gt;２人\u0026lt;/label\u0026gt; \u0026lt;br\u0026gt; 小人： \u0026lt;label\u0026gt;\u0026lt;input type=\u0026quot;radio\u0026quot; name=\u0026quot;child\u0026quot; id=\u0026quot;zero\u0026quot;\u0026gt;０人\u0026lt;/label\u0026gt; \u0026lt;label\u0026gt;\u0026lt;input type=\u0026quot;radio\u0026quot; name=\u0026quot;child\u0026quot; id=\u0026quot;one\u0026quot;\u0026gt;１人\u0026lt;/label\u0026gt; \u0026lt;label\u0026gt;\u0026lt;input type=\u0026quot;radio\u0026quot; name=\u0026quot;child\u0026quot; id=\u0026quot;two\u0026quot;\u0026gt;２人\u0026lt;/label\u0026gt; \u0026lt;/fieldset\u0026gt; \u0026lt;/form\u0026gt;  表示例\n  乗車駅→降車駅\n→ 大人： ０人 １人 ２人 小人： ０人 １人 ２人   \nlegend要素 legend要素は、fieldset要素でグループ化されたフォーム部品にキャプションをつけて表示させるための要素である。\nlegend要素を使用する場合は、必ずfieldset要素の中で使用し、かつその先頭に指定する必要がある。\n使用例\n\u0026lt;form id=\u0026quot;ticket\u0026quot;\u0026gt; \u0026lt;fieldset form=\u0026quot;ticket\u0026quot;\u0026gt; \u0026lt;legend\u0026gt;乗車券\u0026lt;/legend\u0026gt; \u0026lt;p\u0026gt; 乗車駅→降車駅\u0026lt;br\u0026gt; \u0026lt;input type=\u0026quot;text\u0026quot; width=\u0026quot;10\u0026quot;\u0026gt; → \u0026lt;input type=\u0026quot;text\u0026quot; width=\u0026quot;10\u0026quot;\u0026gt; \u0026lt;/p\u0026gt; 大人： \u0026lt;label\u0026gt;\u0026lt;input type=\u0026quot;radio\u0026quot; name=\u0026quot;adult\u0026quot; id=\u0026quot;zero\u0026quot;\u0026gt;０人\u0026lt;/label\u0026gt; \u0026lt;label\u0026gt;\u0026lt;input type=\u0026quot;radio\u0026quot; name=\u0026quot;adult\u0026quot; id=\u0026quot;one\u0026quot;\u0026gt;１人\u0026lt;/label\u0026gt; \u0026lt;label\u0026gt;\u0026lt;input type=\u0026quot;radio\u0026quot; name=\u0026quot;adult\u0026quot; id=\u0026quot;two\u0026quot;\u0026gt;２人\u0026lt;/label\u0026gt; \u0026lt;br\u0026gt; 小人： \u0026lt;label\u0026gt;\u0026lt;input type=\u0026quot;radio\u0026quot; name=\u0026quot;child\u0026quot; id=\u0026quot;zero\u0026quot;\u0026gt;０人\u0026lt;/label\u0026gt; \u0026lt;label\u0026gt;\u0026lt;input type=\u0026quot;radio\u0026quot; name=\u0026quot;child\u0026quot; id=\u0026quot;one\u0026quot;\u0026gt;１人\u0026lt;/label\u0026gt; \u0026lt;label\u0026gt;\u0026lt;input type=\u0026quot;radio\u0026quot; name=\u0026quot;child\u0026quot; id=\u0026quot;two\u0026quot;\u0026gt;２人\u0026lt;/label\u0026gt; \u0026lt;/fieldset\u0026gt; \u0026lt;/form\u0026gt;  表示例\n 乗車券  乗車駅→降車駅\n→ 大人： ０人 １人 ２人 小人： ０人 １人 ２人   \n"},{"idx":84,"href":"/docs/programming/math/vector-2/","title":"ベクトル","content":" ベクトル ベクトルの定義についてを示す。\nPython  ベクトル(1次元配列)は、numpyライブラリにある関数array(list)を使って定義する。\n同じ次元のベクトル間では演算も行える。\ntype()を使って型を確認すると、numpy.ndarray型となっていることがわかる。\n\u0026gt;\u0026gt;\u0026gt; import numpy as np \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; x=np.array([1,2,3]) \u0026gt;\u0026gt;\u0026gt; x array([1, 2, 3]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(x) [1 2 3] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #同次元のベクトルを足し合わせる \u0026gt;\u0026gt;\u0026gt; y=np.array([4,5,6]) \u0026gt;\u0026gt;\u0026gt; y array([4, 5, 6]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(x + y) [5 7 9] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #型を確認 \u0026gt;\u0026gt;\u0026gt; type(x) \u0026lt;class \u0026#39;numpy.ndarray\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt;    "},{"idx":85,"href":"/docs/programming/math/vector/","title":"ベクトル","content":" ベクトル ベクトルの定義についてを示す。\nPython  ベクトル(1次元配列)は、numpyライブラリにある関数array(list)を使って定義する。\n同じ次元のベクトル間では演算も行える。\ntype()を使って型を確認すると、numpy.ndarray型となっていることがわかる。\n\u0026gt;\u0026gt;\u0026gt; import numpy as np \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; x=np.array([1,2,3]) \u0026gt;\u0026gt;\u0026gt; x array([1, 2, 3]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(x) [1 2 3] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #同次元のベクトルを足し合わせる \u0026gt;\u0026gt;\u0026gt; y=np.array([4,5,6]) \u0026gt;\u0026gt;\u0026gt; y array([4, 5, 6]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(x + y) [5 7 9] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #型を確認 \u0026gt;\u0026gt;\u0026gt; type(x) \u0026lt;class \u0026#39;numpy.ndarray\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt;    "},{"idx":86,"href":"/docs/programming/math/norm-2/","title":"ベクトルの大きさ(ノルム)","content":" ベクトルの大きさ(ノルム) Python  ベクトルの大きさ(ノルム)を算出したいときは、numpy.linalgモジュールにある関数normを使用する。\nnumpy.linalg.norm(ベクトル)\n実行例を以下に示す。\n\u0026gt;\u0026gt;\u0026gt; import numpy as np \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a=np.array([1,2]) \u0026gt;\u0026gt;\u0026gt; a array([1, 2]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; np.linalg.norm(a) 2.23606797749979 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; b=np.array([3,4]) \u0026gt;\u0026gt;\u0026gt; b array([3, 4]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; np.linalg.norm(b) 5.0 \u0026gt;\u0026gt;\u0026gt;    "},{"idx":87,"href":"/docs/programming/math/norm/","title":"ベクトルの大きさ(ノルム)","content":" ベクトルの大きさ(ノルム) Python  ベクトルの大きさ(ノルム)を算出したいときは、numpy.linalgモジュールにある関数normを使用する。\nnumpy.linalg.norm(ベクトル)\n実行例を以下に示す。\n\u0026gt;\u0026gt;\u0026gt; import numpy as np \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a=np.array([1,2]) \u0026gt;\u0026gt;\u0026gt; a array([1, 2]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; np.linalg.norm(a) 2.23606797749979 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; b=np.array([3,4]) \u0026gt;\u0026gt;\u0026gt; b array([3, 4]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; np.linalg.norm(b) 5.0 \u0026gt;\u0026gt;\u0026gt;    "},{"idx":88,"href":"/docs/programming/procon/bellman_ford/","title":"ベルマンフォード法","content":" ベルマンフォード法 ベルマンフォード法とは、最短路問題(ある点から他の全ての頂点との間の最短路を求める問題)を解く手法の一つである。\n始点sから頂点iへの最短距離をd[i]とした時、以下の式が成り立つ。\n  $$ dp[i] = min( d[j] + (頂点jから頂点iへの辺のコスト) | e=(j,i) \\in E ) $$ 初期値をd[s]=0,d[i]=INFとし、この式を繰り返すと最短距離を計算し、更新していく。負の閉路が存在しなければこの更新は永続せずに停止する。停止した時のdが最短距離を示す。\nコードの例は以下の通り。\nINF=float(\u0026#34;inf\u0026#34;) #辺 class edge: def __init__(self,start,end,cost): self.start=start self.end=end self.cost=cost #以下、V,E,s,edgesを入力する V=0 #頂点の数 E=0 #辺の数 s=-1 #始点 edges = [edge(-1,-1,-1) for _ in range(E)] #辺 d = [-1 for _ in range(V)] # 最短距離 def shortest_path(s): for i in range(V): d[i] = INF d[s]=0 while True: update=False for i in range(E): e=edges[i] if(d[e.start] != INF and d[e.end] \u0026gt; d[e.start] + e.cost): d[e.end] = d[e.start] + e.cost update = True if(not update): break shortest_path(s) print(d) 例として、以下のグラフでベルマンフォード法を使ってみよう。\nこの時、コード中のV,E,s,edgesを以下のように定める。\nV=5 #頂点の数 E=7 #辺の数 s=0 #始点 edges = [edge(-1,-1,-1) for _ in range(E)] #辺 edges[0]=edge(0,1,2) edges[1]=edge(0,2,5) edges[2]=edge(0,3,6) edges[3]=edge(1,2,1) edges[4]=edge(1,4,9) edges[5]=edge(2,4,10) edges[6]=edge(3,4,4) 実行すると、結果は以下の通り。\n[0, 2, 3, 6, 10]  計算量については、whileループで少なくとも一つの頂点の最短距離が確定するので、多くてもV回実行される。その中のfor文でE回ループされるので、計算量は0(|V|*|E|)となる。\n"},{"idx":89,"href":"/docs/programming/machine_learning/holdout_validation/","title":"ホールドアウト検証","content":" ホールドアウト検証 先述のオーバーフィッティング(過学習)の章で、Mを大きくすればするほど既存の入力データに対する精度が高くなり、未知の入力に対する予測精度が悪くなるという問題があった。最適なMはどう求めれば良いのだろうか？\nその一つの方法として、ホールドアウト検証という手法を挙げる。\nこれは、今ある入力データをいくつかの集合に分割し、そのうちのいくつかを学習に使って予測式を作り、残りのデータでその予測式を使った結果の平均二乗誤差(または標準偏差SD)を算出することでMの評価基準とする、という方法である。\nここで、予測式を作るための学習に使うデータのことを訓練データ (training data)といい、作成した予測式の評価に用いるデータをテストデータ (test data)と呼ぶ。\nでは試しに、先述の線形基底関数モデルで利用したデータ(=直線モデル(線形回帰)で利用したデータ)を４分割し、初めの4分の３を訓練データとして学習させ、残りの4分の１をテストデータとして利用し、各Mの評価を行ってみよう。\nコードを以下に記載する。(holdout_validation.py)\nimport math import matplotlib.pyplot as plt import numpy as np from linear_basis_function import mse from linear_basis_function import design_matrix from linear_basis_function import linear_basis_func #入力値 x = np.load(\u0026#39;x.npy\u0026#39;) #実測値 t = np.load(\u0026#39;t.npy\u0026#39;) #mを設定 M=[1,5,9,13] #訓練データ,全体の3/4 n=(len(x)//4)*3 x_train=x[:n] t_train=t[:n] #テストデータ x_test=x[n:] t_test=t[n:] #メイン(プロット) plt.figure(figsize=(20,7.5)) plt.subplots_adjust(wspace=0.25,hspace=0.3) for i in range(len(M)): plt.subplot(2,2,i+1) m=M[i] #ガウス関数の中心 はxの最小値〜最大値の間で設定 mu=np.linspace(min(x_train),max(x_train),m) #訓練データでw,y算出 w_train = design_matrix(x_train,t_train,mu,1) y_test = linear_basis_func(w_train,x_test,mu,1) #標準偏差SD算出 sd = math.sqrt(mse(y_test,t_test)) #予測式を細かく表示させるためのデータ作成 x_forplot = np.linspace(min(x_train),max(x_train),1000) y_forplot = linear_basis_func(w_train,x_forplot,mu,1) #プロット plt.scatter(x_train,t_train,c=\u0026#39;white\u0026#39;,label=\u0026#39;train\u0026#39;,edgecolors=\u0026#34;black\u0026#34;) plt.scatter(x_test,t_test,c=\u0026#39;green\u0026#39;,label=\u0026#39;test\u0026#39;) plt.xlim(min(x)-1,max(x)+1) plt.ylim(min(t)-1,max(t)+10) plt.plot(x_forplot,y_forplot,\u0026#39;-\u0026#39;,color=\u0026#39;red\u0026#39;,label=\u0026#39;y_train\u0026#39;) plt.legend(loc=\u0026#39;lower right\u0026#39;) plt.title(\u0026#34;M={0:d}, SD={1:.2f}\u0026#34;.format(m,sd)) plt.grid(True) plt.show() 実行結果\nとなり、Mが高くなるほど訓練データへの誤差は少なくなるが、テストデータへの誤差（標準偏差）は大きくなる。\nこの場合で最適なMを調べるために、各Mにおいて訓練データとテストデータの誤差(標準偏差)を調べてみよう。\n各Mにおいて訓練データとテストデータの誤差(標準偏差)を算出し、グラフを作成するコードを以下に記載する。\nimport math import matplotlib.pyplot as plt import numpy as np from linear_basis_function import mse from linear_basis_function import design_matrix from linear_basis_function import linear_basis_func #入力値 x = np.load(\u0026#39;x.npy\u0026#39;) #実測値 t = np.load(\u0026#39;t.npy\u0026#39;) #訓練データ,全体の3/4 n=(len(x)//4)*3 x_train=x[:n] t_train=t[:n] #テストデータ x_test=x[n:] t_test=t[n:] #M毎の標準偏差SD sd_train=[] sd_test=[] #メイン(プロット) plt.figure(figsize=(10,7.5)) M=[i for i in range(1,14)] for m in M: #ガウス関数の中心 はxの最小値〜最大値の間で設定 mu=np.linspace(min(x_train),max(x_train),m) #訓練データでw,y算出 w_train = design_matrix(x_train,t_train,mu,1) y_test = linear_basis_func(w_train,x_test,mu,1) y_train = linear_basis_func(w_train,x_train,mu,1) #標準偏差SD算出 sd_train.append(math.sqrt(mse(y_train,t_train))) sd_test.append(math.sqrt(mse(y_test,t_test))) #プロット plt.xlim(min(M)-1,max(M)+1) plt.ylim(min(min(sd_train),min(sd_test))-1,max(max(sd_train),max(sd_test))+1) plt.plot(M,sd_train,\u0026#39;-\u0026#39;,color=\u0026#39;blue\u0026#39;,label=\u0026#39;SD_train\u0026#39;) plt.plot(M,sd_test,\u0026#39;-\u0026#39;,color=\u0026#39;red\u0026#39;,label=\u0026#39;SD_test\u0026#39;) plt.legend(loc=\u0026#39;higher left\u0026#39;) plt.grid(True) plt.show() 実行結果\nのようになり、この図よりテストデータに対して誤差が最も低くなるM=7,10あたりが最も適切なMであると推測できる。\nよって、このホールドアウト検証で最適なMが決定できた。\nしかし、今回はテストデータが分散しているため良いが、例えばテストデータがひとかたまりになる場合（テストデータを低い順または高い順から取ってくるなど）すると、また学習結果も悪くなるのは予想できると思う。つまり、実はホールドアウト検証はどれを訓練データ及びテストデータに選ぶかによって結果が変わってくるものなのである。\nそこで、もう一つの検証方法についてを次章で述べる。\n"},{"idx":90,"href":"/docs/front-end/css_multicolumn/","title":"マルチカラム","content":" マルチカラム マルチカラムとは、ボックスの内部を複数の段に分割してできるレイアウトである。\nここでは、マルチカラムについてを述べる。\ncolumn-countプロパティ column-countプロパティは、何段組みするかを設定するプロパティである。\n値は1以上の整数またはautoで指定する。\n使用例\n\u0026lt;p style=\u0026quot;background-color: #66ff99; width:500px; height:300px; overflow:hidden; column-count:3\u0026quot;\u0026gt; 祇園精舍の鐘の声、諸行無常の響きあり。 娑羅双樹の花の色、盛者必衰の理をあらはす。 おごれる人も久しからず、ただ春の夜の夢のごとし。 猛き者もつひには滅びぬ、ひとへに風の前の塵に同じ。 遠く異朝をとぶらへば、秦の趙高、漢の王莽、梁の朱忌、唐の祿山、これらは皆旧主先皇の政にも従はず、樂しみをきはめ、諌めをも思ひ入れず、天下の乱れん事を悟らずして、民間の愁ふるところを知らざつしかば、久しからずして、亡じにし者どもなり。 近く本朝をうかがふに、承平の将門、天慶の純友、康和の義親、平治の信頼、これらはおごれる心も猛き事も、皆とりどりにこそありしかども、ま近くは、六波羅の入道前太政大臣平朝臣清盛公と申しし人のありさま、伝えへ承るこそ、心もことばも及ばれね。 \u0026lt;/p\u0026gt;  表示例\n 祇園精舍の鐘の声、諸行無常の響きあり。 娑羅双樹の花の色、盛者必衰の理をあらはす。 おごれる人も久しからず、ただ春の夜の夢のごとし。 猛き者もつひには滅びぬ、ひとへに風の前の塵に同じ。 遠く異朝をとぶらへば、秦の趙高、漢の王莽、梁の朱忌、唐の祿山、これらは皆旧主先皇の政にも従はず、樂しみをきはめ、諌めをも思ひ入れず、天下の乱れん事を悟らずして、民間の愁ふるところを知らざつしかば、久しからずして、亡じにし者どもなり。 近く本朝をうかがふに、承平の将門、天慶の純友、康和の義親、平治の信頼、これらはおごれる心も猛き事も、皆とりどりにこそありしかども、ま近くは、六波羅の入道前太政大臣平朝臣清盛公と申しし人のありさま、伝えへ承るこそ、心もことばも及ばれね。 \ncolumn-widthプロパティ column-widthプロパティは、段の幅を指定するプロパティである。値は単位付きの数値またはautoで指定する。\n使用例\n\u0026lt;p style=\u0026quot;background-color: #66ff99; width:700px; height:300px; column-width: 100px;\u0026quot;\u0026gt; 祇園精舍の鐘の声、諸行無常の響きあり。 娑羅双樹の花の色、盛者必衰の理をあらはす。 おごれる人も久しからず、ただ春の夜の夢のごとし。 猛き者もつひには滅びぬ、ひとへに風の前の塵に同じ。 遠く異朝をとぶらへば、秦の趙高、漢の王莽、梁の朱忌、唐の祿山、これらは皆旧主先皇の政にも従はず、樂しみをきはめ、諌めをも思ひ入れず、天下の乱れん事を悟らずして、民間の愁ふるところを知らざつしかば、久しからずして、亡じにし者どもなり。 近く本朝をうかがふに、承平の将門、天慶の純友、康和の義親、平治の信頼、これらはおごれる心も猛き事も、皆とりどりにこそありしかども、ま近くは、六波羅の入道前太政大臣平朝臣清盛公と申しし人のありさま、伝えへ承るこそ、心もことばも及ばれね。 \u0026lt;/p\u0026gt;  表示例\n 祇園精舍の鐘の声、諸行無常の響きあり。 娑羅双樹の花の色、盛者必衰の理をあらはす。 おごれる人も久しからず、ただ春の夜の夢のごとし。 猛き者もつひには滅びぬ、ひとへに風の前の塵に同じ。 遠く異朝をとぶらへば、秦の趙高、漢の王莽、梁の朱忌、唐の祿山、これらは皆旧主先皇の政にも従はず、樂しみをきはめ、諌めをも思ひ入れず、天下の乱れん事を悟らずして、民間の愁ふるところを知らざつしかば、久しからずして、亡じにし者どもなり。 近く本朝をうかがふに、承平の将門、天慶の純友、康和の義親、平治の信頼、これらはおごれる心も猛き事も、皆とりどりにこそありしかども、ま近くは、六波羅の入道前太政大臣平朝臣清盛公と申しし人のありさま、伝えへ承るこそ、心もことばも及ばれね。 \ncolumnsプロパティ columnsプロパティは、前述のcolumn-count,column-widthをまとめて指定できるプロパティである。\n使用例\n\u0026lt;p style=\u0026quot;background-color: #66ff99; width:700px; height:300px; overflow:hidden; columns:2\u0026quot;\u0026gt; 祇園精舍の鐘の声、諸行無常の響きあり。 娑羅双樹の花の色、盛者必衰の理をあらはす。 おごれる人も久しからず、ただ春の夜の夢のごとし。 猛き者もつひには滅びぬ、ひとへに風の前の塵に同じ。 \u0026lt;/p\u0026gt;  表示例\n 祇園精舍の鐘の声、諸行無常の響きあり。 娑羅双樹の花の色、盛者必衰の理をあらはす。 おごれる人も久しからず、ただ春の夜の夢のごとし。 猛き者もつひには滅びぬ、ひとへに風の前の塵に同じ。 \ncolumn-gapプロパティ column-gapプロパティは、段の間隔を設定するプロパティである。値は単位付きの数値を指定する。\n使用例\n\u0026lt;p style=\u0026quot;background-color: #66ff99; width:700px; height:100px; overflow:hidden; column-count:2; column-gap:100px\u0026quot;\u0026gt; 祇園精舍の鐘の声、諸行無常の響きあり。 娑羅双樹の花の色、盛者必衰の理をあらはす。 おごれる人も久しからず、ただ春の夜の夢のごとし。 猛き者もつひには滅びぬ、ひとへに風の前の塵に同じ。 \u0026lt;/p\u0026gt;  表示例\n 祇園精舍の鐘の声、諸行無常の響きあり。 娑羅双樹の花の色、盛者必衰の理をあらはす。 おごれる人も久しからず、ただ春の夜の夢のごとし。 猛き者もつひには滅びぬ、ひとへに風の前の塵に同じ。 \ncolumn-ruleプロパティ 段と段の間にはボーダーと同様の線を引くことができる。その線を設定するプロパティがcolumn-rule系のプロパティである。\nこのプロパティにはいくつか種類があり、以下の通りである。\n プロパティ名 意味   column-rule-style 線の線種   column-rule-color 線の色   column-rule-width 線の太さ   column-rule 上記のプロパティの値を空白区切りでまとめて指定   使用例\n\u0026lt;p style=\u0026quot;background-color: #66ff99; width:700px; height:300px; column-count: 3; column-rule: 3px double red;\u0026quot;\u0026gt; 祇園精舍の鐘の声、諸行無常の響きあり。 娑羅双樹の花の色、盛者必衰の理をあらはす。 おごれる人も久しからず、ただ春の夜の夢のごとし。 猛き者もつひには滅びぬ、ひとへに風の前の塵に同じ。 遠く異朝をとぶらへば、秦の趙高、漢の王莽、梁の朱忌、唐の祿山、これらは皆旧主先皇の政にも従はず、樂しみをきはめ、諌めをも思ひ入れず、天下の乱れん事を悟らずして、民間の愁ふるところを知らざつしかば、久しからずして、亡じにし者どもなり。 近く本朝をうかがふに、承平の将門、天慶の純友、康和の義親、平治の信頼、これらはおごれる心も猛き事も、皆とりどりにこそありしかども、ま近くは、六波羅の入道前太政大臣平朝臣清盛公と申しし人のありさま、伝えへ承るこそ、心もことばも及ばれね。 \u0026lt;/p\u0026gt;  表示例\n 祇園精舍の鐘の声、諸行無常の響きあり。 娑羅双樹の花の色、盛者必衰の理をあらはす。 おごれる人も久しからず、ただ春の夜の夢のごとし。 猛き者もつひには滅びぬ、ひとへに風の前の塵に同じ。 遠く異朝をとぶらへば、秦の趙高、漢の王莽、梁の朱忌、唐の祿山、これらは皆旧主先皇の政にも従はず、樂しみをきはめ、諌めをも思ひ入れず、天下の乱れん事を悟らずして、民間の愁ふるところを知らざつしかば、久しからずして、亡じにし者どもなり。 近く本朝をうかがふに、承平の将門、天慶の純友、康和の義親、平治の信頼、これらはおごれる心も猛き事も、皆とりどりにこそありしかども、ま近くは、六波羅の入道前太政大臣平朝臣清盛公と申しし人のありさま、伝えへ承るこそ、心もことばも及ばれね。 \ncolumn-spanプロパティ column-spanプロパティは、ボックスが段組みされている時に、指定した要素を段の中に収めず、ボックスの幅いっぱい（全ての段を跨いで）に表示させるプロパティである。\n値はall(全ての段に跨いで表示)、none（段を跨いで表示させない）が指定できる。\n使用例\n\u0026lt;div style=\u0026quot;background-color: #66ff99; width:800px; height:300px; overflow:hidden; column-count:3\u0026quot;\u0026gt; \u0026lt;p\u0026gt; 祇園精舍の鐘の声、諸行無常の響きあり。 娑羅双樹の花の色、盛者必衰の理をあらはす。 おごれる人も久しからず、ただ春の夜の夢のごとし。 猛き者もつひには滅びぬ、ひとへに風の前の塵に同じ。 \u0026lt;/p\u0026gt; \u0026lt;p style=\u0026quot;background-color: red; column-span: all;\u0026quot;\u0026gt;〜〜中略〜〜\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; 遠く異朝をとぶらへば、秦の趙高、漢の王莽、梁の朱忌、唐の祿山、これらは皆旧主先皇の政にも従はず、樂しみをきはめ、諌めをも思ひ入れず、天下の乱れん事を悟らずして、民間の愁ふるところを知らざつしかば、久しからずして、亡じにし者どもなり。 近く本朝をうかがふに、承平の将門、天慶の純友、康和の義親、平治の信頼、これらはおごれる心も猛き事も、皆とりどりにこそありしかども、ま近くは、六波羅の入道前太政大臣平朝臣清盛公と申しし人のありさま、伝えへ承るこそ、心もことばも及ばれね。 \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt;  表示例\n  祇園精舍の鐘の声、諸行無常の響きあり。 娑羅双樹の花の色、盛者必衰の理をあらはす。 おごれる人も久しからず、ただ春の夜の夢のごとし。 猛き者もつひには滅びぬ、ひとへに風の前の塵に同じ。 〜〜中略〜〜\n 遠く異朝をとぶらへば、秦の趙高、漢の王莽、梁の朱忌、唐の祿山、これらは皆旧主先皇の政にも従はず、樂しみをきはめ、諌めをも思ひ入れず、天下の乱れん事を悟らずして、民間の愁ふるところを知らざつしかば、久しからずして、亡じにし者どもなり。 近く本朝をうかがふに、承平の将門、天慶の純友、康和の義親、平治の信頼、これらはおごれる心も猛き事も、皆とりどりにこそありしかども、ま近くは、六波羅の入道前太政大臣平朝臣清盛公と申しし人のありさま、伝えへ承るこそ、心もことばも及ばれね。  \nフレキシブルボックスレイアウト displayプロパティにおいて、値をflexと指定すると、その内部の子要素を縦、横、逆順などの順番で配置することができる。このような配置をフレキシブルボックスレイアウトという。\n順番の指定は、flex-directionプロパティで指定できる。指定する値と意味は以下の通り。デフォルトではrowである。\n プロパティ名 意味   row 横（左から右）   row-reverse 横（右から左）   column 縦（上から下）   column-reverse 縦（下から上）   使用例\n\u0026lt;div style=\u0026quot;display:flex; flex-direction:row\u0026quot;\u0026gt; \u0026lt;p style=\u0026quot;background-color:red\u0026quot;\u0026gt;p 1個目\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026quot;background-color:yellow\u0026quot;\u0026gt;p 2個目\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026quot;background-color:green\u0026quot;\u0026gt;p 3個目\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt;  表示例\n p 1個目\np 2個目\np 3個目\n \n"},{"idx":91,"href":"/docs/programming/class_func/lambda/","title":"ラムダ式（無名関数）","content":" ラムダ式（無名関数） ラムダ式（無名関数）についてを述べる。\nJava  Javaでは簡易的なメソッドを実装する方法としてラムダ式というのがある。\n( 実装するメソッドの引数 ) -\u0026gt; { 処理 }\nラムダ式では、関数型インターフェースの変数に、この記法で記述されたコードを代入する。\n関数型インターフェースとはjava.util.functionに定義されているインターフェースであり、それぞれ用途があるが、共通して言えるのは定義されているのが抽象メソッド１つということである。この抽象メソッドをラムダ式で実装することによって利用する。\n記法について、引数には型名も基本必要だが、すでに定義している変数を使う場合は型名が省略できる。\nまた、引数が１つの場合は()を省略できる。\n引数 -\u0026gt; { 処理 }\nただし、引数が無い場合は()の省略はできない。\n() -\u0026gt; { 処理 }\n右辺において、処理が1文の場合は、{}の省略が可能。{}を省略している場合は、returnも省略可能。\n(引数) -\u0026gt; 処理\n実行例を以下に示す。\nimport java.util.function.Function; class Main{ public static void main(String args[]){ Function\u0026lt;String,String\u0026gt; func = (String str) -\u0026gt; { return \u0026#34;Lambda:\u0026#34; + str; }; System.out.println(func.apply(\u0026#34;implemented.\u0026#34;)); func = str -\u0026gt; \u0026#34;none() Lambda:\u0026#34; + str; System.out.println(func.apply(\u0026#34;implemented.\u0026#34;)); } } 実行結果\n$ java Main Lambda:implemented. none() Lambda:implemented.  この例で出てきたFunctionクラスは関数型インターフェースで、中には抽象メソッドR apply(T t)が定義されている(Tは引数の型、Rは返り値の型)。Functionクラスの変数宣言時にラムダ式を代入すると、そのラムダ式の定義が抽象メソッドapplyに適用される。\n他の関数型インタフェースに対しても、同様にラムダ式を定義し代入することで利用できる。（他にどのような関数型インタフェースがあるかはここでは割愛する。）\n Python  Pythonではキーワードlambdaを使って定義することで無名関数が書ける。\nlambda (引数): (返す値、式)\n引数は何個でも設定できる。\n特徴としてはlambdaの式は変数に格納することができる。\nその変数に引数を指定して実行すると、lambdaに渡されて実行される。\n\u0026gt;\u0026gt;\u0026gt; a=lambda x:x+1 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a(0) 1 \u0026gt;\u0026gt;\u0026gt; a(1) 2 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; b=lambda x,y:x*y \u0026gt;\u0026gt;\u0026gt; b(1,2) 2 \u0026gt;\u0026gt;\u0026gt; b(10,-10) -100 \u0026gt;\u0026gt;\u0026gt;    "},{"idx":92,"href":"/docs/front-end/list/","title":"リスト","content":" リスト HTML文書にリストを記載するための要素についてをここでは述べる。\nul要素 ul要素は、箇条書きリストを作成するための要素である。一つの箇条書きリストをul要素で表し、リスト内の項目一つをli要素で表す。\n\u0026lt;p\u0026gt;やることリスト\u0026lt;/p\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;部屋の掃除\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;ゴミ出し\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;ジョギング\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt;  表示例\n やることリスト\n 部屋の掃除 ゴミ出し ジョギング  \nol要素 ol要素は、連番付きリストを作成するための要素である。リストのひとかたまりをol要素で表し、リスト内の項目一つをli要素で表す。\n指定できる属性は以下の通り。\n   属性名 意味     type 行頭の数字の種類(値は\u0026rdquo;1\u0026rdquo;,\u0026ldquo;a\u0026rdquo;,\u0026ldquo;A\u0026rdquo;,\u0026ldquo;i\u0026rdquo;,\u0026ldquo;I\u0026rdquo;)   start 連番の開始番号   reversed リストの番号を逆順にする    \u0026lt;p\u0026gt;サーバー再起動手順\u0026lt;/p\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt;rootユーザにログインする\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;サーバーを停止する\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;サーバーを起動する\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt;  表示例\n サーバー再起動手順\n rootユーザにログインする サーバーを停止する サーバーを起動する  \nli要素 前述のul,ol要素のところで出てきてはいるが、li要素はul,ol要素によるリストの各項目を示す時に用いる要素である。\n使用例・表示例はul,ol要素を参照。\ndl要素・dt要素・dd要素 ul要素は箇条書き、ol要素は連番と決まっていたが、dl要素(description list)はリストの項目の種類を自分で指定できる要素である。記号である必要はなく、具体的な名前を入れても良い。\ndl要素で書いたリストは、dt要素で項目名を指定し、その後dd要素でその具体的な内容を指定する。\n\u0026lt;p\u0026gt;試験時間\u0026lt;/p\u0026gt; \u0026lt;dl\u0026gt; \u0026lt;dt\u0026gt;国語\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;9:00~10:30\u0026lt;/dd\u0026gt; \u0026lt;dt\u0026gt;数学\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;10:45~12:15\u0026lt;/dd\u0026gt; \u0026lt;dt\u0026gt;英語\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;13:30~15:00\u0026lt;/dd\u0026gt; \u0026lt;/dl\u0026gt;  表示例\n 試験時間\n 国語 9:00~10:30 数学 10:45~12:15 英語 13:30~15:00  \n"},{"idx":93,"href":"/docs/programming/list/list_and/","title":"リストa,bに共通して入っている要素のみを表示（積集合）","content":" リストa,bに共通して入っている要素のみを表示（積集合） 2つのリストに共通して入っている要素のみを表示する方法についてを示す。\nJava  JavaではListクラスにretainAll()というメソッドがある。これは呼び出し元のリストに含まれている要素の内、引数に指定したリスト内にも含まれている要素のみを残し、他の要素は全て削除するというメソッドである。\nboolean retainAll(Collection\u0026lt;?\u0026gt; c)\nこのメソッドを活用することにより２つのリストに共通して入っている要素のみを取り出すことができる。ただし同じ値の要素が複数入っていた場合はその数だけ要素が残るということもあるので、重複している値を１つにするにはSet()等を使い重複を排除する。\n使用例を以下に示す。\nimport java.util.ArrayList; import java.util.List; class Main{ //List println  public static void listprint(String name,List\u0026lt;Integer\u0026gt; l){ System.out.print(name + \u0026#34;: \u0026#34;); for(int i=0;i\u0026lt;l.size();i++){ System.out.print(l.get(i) + \u0026#34; \u0026#34;); } System.out.println(); } public static void main(String args[]){ List\u0026lt;Integer\u0026gt; l = new ArrayList\u0026lt;Integer\u0026gt;(); l.add(1); l.add(3); l.add(100); l.add(0); List\u0026lt;Integer\u0026gt; m = new ArrayList\u0026lt;Integer\u0026gt;(); m.add(2); m.add(4); m.add(100); m.add(100); listprint(\u0026#34;l\u0026#34;, l); listprint(\u0026#34;m\u0026#34;, m); l.retainAll(m); listprint(\u0026#34;l\u0026#34;, l); } } 実行結果\n\u0026gt; java Main l: 1 3 100 0 m: 2 4 100 100 l: 100   Python  Pythonではリストをset型に変換し、その後 \u0026amp; 演算子を使うと、重複している要素のみが残る。\nリストに戻したい時は、計算後のsetをlist()で変換してリストにする。\n\u0026gt;\u0026gt;\u0026gt; a=[1,9,8,7,6,5,3,2] \u0026gt;\u0026gt;\u0026gt; b=[2,3,4] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a_and_b=set(a) \u0026amp; set(b) \u0026gt;\u0026gt;\u0026gt; a_and_b {2, 3} \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; list(a_and_b) [2, 3] \u0026gt;\u0026gt;\u0026gt;   "},{"idx":94,"href":"/docs/programming/list/list_except/","title":"リストaにありリストbに入ってない要素のみを表示（差集合）","content":" リストaにありリストbに入ってない要素のみを表示（差集合） リストaにありリストbに入ってない要素のみを表示する方法についてを示す。\nなお、リスト内の要素に重複している要素はないことを前提とする。\nJava  JavaではListクラスにremoveAll()というメソッドがある。これは呼び出し元のリストに含まれている要素の内、引数に指定したリスト内に含まれている要素を削除し、他の要素は全て残すというメソッドである。\nboolean removeAll(Collection\u0026lt;?\u0026gt; c)\nこのメソッドを活用することにより２つのリストの差集合をとることができる。ただし同じ値の要素が複数入っていた場合はその数だけ要素が残るということもあるので、重複している値を１つにするにはSet()等を使い重複を排除する。\n使用例を以下に示す。\nimport java.util.ArrayList; import java.util.List; class Main{ public static void main(String args[]){ List\u0026lt;Integer\u0026gt; l = new ArrayList\u0026lt;Integer\u0026gt;(); l.add(1); l.add(3); l.add(100); l.add(0); List\u0026lt;Integer\u0026gt; m = new ArrayList\u0026lt;Integer\u0026gt;(); m.add(2); m.add(4); m.add(100); m.add(0); System.out.println(\u0026#34;l :\u0026#34; + l); System.out.println(\u0026#34;m :\u0026#34; + m); l.removeAll(m); System.out.println(\u0026#34;l-m:\u0026#34; + l); } } 実行結果\n\u0026gt; java Main l :[1, 3, 100, 0] m :[2, 4, 100, 0] l-m:[1, 3]   Python  Pythonではリストをset型に変換し、その後 - 演算子を使うと、引かれたsetにのみある要素のみが残る。\nリストに戻したい時は、計算後のsetをlist()で変換してリストにする。\n\u0026gt;\u0026gt;\u0026gt; a=[1,9,8,7,6,5,3,2] \u0026gt;\u0026gt;\u0026gt; b=[2,3,4] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a_minus_b=set(a)-set(b) \u0026gt;\u0026gt;\u0026gt; a_minus_b {1, 5, 6, 7, 8, 9} \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; list(a_minus_b) [1, 5, 6, 7, 8, 9] \u0026gt;\u0026gt;\u0026gt;   "},{"idx":95,"href":"/docs/programming/list/list_or/","title":"リストaまたはbに入っている要素を表示（和集合）","content":" リストaまたはbに入っている要素を表示（和集合） 2つのリストの少なくとも一つに入っている要素のみを表示する方法についてを示す。\nなお、リスト内の要素に重複している要素はないことを前提とする。\nJava  Javaでの考え方としては\n addAll()メソッドを利用してリストaにリストbの要素を全て加える リストをSetにして重複要素を排除する 作成したSetを再びListにすると最終的にリストaまたはbに入っている要素が残る  のようなアルゴリズムが考えられる。使用例を以下に示す。\nimport java.util.ArrayList; import java.util.HashSet; import java.util.List; import java.util.Set; class Main{ //List println  public static void listprint(String name,List\u0026lt;Integer\u0026gt; l){ System.out.print(name + \u0026#34;: \u0026#34;); for(int i=0;i\u0026lt;l.size();i++){ System.out.print(l.get(i) + \u0026#34; \u0026#34;); } System.out.println(); } public static void main(String args[]){ List\u0026lt;Integer\u0026gt; a = new ArrayList\u0026lt;Integer\u0026gt;(); a.add(1); a.add(3); a.add(100); a.add(0); listprint(\u0026#34;a\u0026#34;, a); List\u0026lt;Integer\u0026gt; b = new ArrayList\u0026lt;Integer\u0026gt;(); b.add(2); b.add(4); b.add(100); b.add(0); listprint(\u0026#34;b\u0026#34;, b); //a \u0026lt;- b  a.addAll(b); //a(Set) \u0026lt;- a(List)  Set\u0026lt;Integer\u0026gt; set_a = new HashSet\u0026lt;Integer\u0026gt;(a); //a(List) \u0026lt;- a(Set);  a = new ArrayList\u0026lt;Integer\u0026gt;(set_a); listprint(\u0026#34;a or b\u0026#34;, a); } } 実行結果\n\u0026gt; java Main a: 1 3 100 0 b: 2 4 100 0 a or b: 0 1 2 3 100 4   Python  Pythonではリストをset型に変換し、その後 | 演算子を使うと、両リストの少なくとも一つにある要素が残る。\nリストに戻したい時は、計算後のsetをlist()で変換してリストにする。\n\u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a=[1,9,8,7,6,5,3,2] \u0026gt;\u0026gt;\u0026gt; b=[2,3,4] \u0026gt;\u0026gt;\u0026gt; a_or_b = set(a) | set(b) \u0026gt;\u0026gt;\u0026gt; a_or_b {1, 2, 3, 4, 5, 6, 7, 8, 9} \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; list(a_or_b) [1, 2, 3, 4, 5, 6, 7, 8, 9] \u0026gt;\u0026gt;\u0026gt;   "},{"idx":96,"href":"/docs/programming/list/inclusion/","title":"リストから条件に合う要素のみを取得した新しいリストを作成する","content":" リストから条件に合う要素のみを取得した新しいリストを作成する リストから条件に合う要素のみを取得した新しいリストを作成する方法を示す。\nJava  Javaではリストの要素を１個１個見ていって、条件に合っていたら別リストにその要素を追加させていけば、そのリストが条件に合う要素のみを格納したリストになる。\n（単純だが、もっといい方法が無いか模索中）\n一例として、文字列のリストから３文字以上の要素のみを取り出したリストを作る例を示す。\nimport java.util.ArrayList; import java.util.List; class Main{ public static void main(String args[]){ List\u0026lt;String\u0026gt; l = new ArrayList\u0026lt;\u0026gt;(); l.add(\u0026#34;a\u0026#34;); l.add(\u0026#34;bb\u0026#34;); l.add(\u0026#34;ccc\u0026#34;); l.add(\u0026#34;dddd\u0026#34;); System.out.println(l); List\u0026lt;String\u0026gt; m = new ArrayList\u0026lt;\u0026gt;(); for(int i=0;i\u0026lt;l.size();i++){ if(l.get(i).length() \u0026gt;= 3){ m.add(l.get(i)); } } System.out.println(m); } } 実行結果\n\u0026gt; java Main [a, bb, ccc, dddd] [ccc, dddd]   Python  Pythonではリスト内包表記という方法を用いる。\nリストの中でイテラブルオブジェクトの要素を条件に従い取り出す形で定義すると、イテラブルオブジェクトの要素の中で指定した条件に合う要素だけが残ったリストを返してくれる。\n表記例は以下の通り。\n[要素 for 要素 in イテラブルオブジェクト if 条件]\n使用例を以下に示す。\n\u0026gt;\u0026gt;\u0026gt; a=[\u0026#34;a\u0026#34;,\u0026#34;bb\u0026#34;,\u0026#34;ccc\u0026#34;,\u0026#34;dddd\u0026#34;] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a [\u0026#39;a\u0026#39;, \u0026#39;bb\u0026#39;, \u0026#39;ccc\u0026#39;, \u0026#39;dddd\u0026#39;] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; [s for s in a if len(s) \u0026gt;= 3] [\u0026#39;ccc\u0026#39;, \u0026#39;dddd\u0026#39;] \u0026gt;\u0026gt;\u0026gt;    "},{"idx":97,"href":"/docs/programming/list/isempty/","title":"リストが空であるか判別する","content":" リストが空であるか判別する リストが空（＝要素が何も入っていない状態）であるか判別する方法についてを示す。\nJava  JavaではListクラスにリストが空であるかを判別するメソッドisEmpty()がある。\nboolean isEmpty() 空の場合はtrueを、そうでない場合はfalseを返す。\nimport java.util.ArrayList; import java.util.List; import java.util.Collections; class Main{ public static void main(String args[]){ List\u0026lt;Integer\u0026gt; l = new ArrayList\u0026lt;Integer\u0026gt;(); System.out.println(l.isEmpty()); l.add(1); l.add(3); l.add(-2); l.add(100); System.out.println(l.isEmpty()); } } 実行結果\n\u0026gt; java Main true false   Python  Pythonにはリストが空であるかを判別するための関数は無い。\nリストが空であるかを判別するには、以下の方法を利用するなどしてみる。\n リストの長さが0であるかで確認する 関数bool()を使ってBoolean値に変換する。この時リストが空ならFalse、そうでない時はTrueを返す。  リストの長さが0であるかを調べるには単純にlen(リスト) == 0を行えばよいが、\nもう一つの、実はリストが空でない場合、boolで変換するとTrueを返す特性があるという。これを使用してもよい。\n\u0026gt;\u0026gt;\u0026gt; a=[] \u0026gt;\u0026gt;\u0026gt; a [] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; len(a) == 0 #リストが空であるか? True \u0026gt;\u0026gt;\u0026gt; bool(a) #空のリストをboolで変換する False \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; b=[1,2,3,4,5] \u0026gt;\u0026gt;\u0026gt; b [1, 2, 3, 4, 5] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; len(b) == 0 #リストが空であるか? False \u0026gt;\u0026gt;\u0026gt; bool(b) #空でないリストをboolで変換する True \u0026gt;\u0026gt;\u0026gt;   "},{"idx":98,"href":"/docs/programming/list/append/","title":"リストに要素を加える","content":" リストに要素を加える リストに要素を加える方法についてを示す。\nJava  JavaではListクラスにadd()というメソッドがあり、引数の要素をリストの最後に追加する。\nboolean add(E e)\n型の問題などで要素を追加できない時はエラーとなる。\nまた、オーバーロードとしてリストの指定した位置に要素を追加するaddメソッドもある。\nvoid add(int index, E element)\n実行例を以下に示す。\nimport java.util.ArrayList; import java.util.List; class Main{ public static void main(String args[]){ List\u0026lt;Integer\u0026gt; l = new ArrayList\u0026lt;Integer\u0026gt;(); l.add(1); l.add(3); l.add(1,100); for(int i=0;i\u0026lt;l.size();i++){ System.out.println(l.get(i)); } } } 実行結果\n\u0026gt; java Main 1 100 3   Python  Pythonではリストの関数として\n リストの末尾に要素を追加したい場合はappend()\n リストの末尾以外の指定した位置に要素を追加したい場合はinsert()\n  の関数があるので、適宜使い分ける。\n(リストの末尾に要素xを追加したい時)\nlist.append(x)\n(リストの指定した位置iに要素xを追加したい時)\nlist.insert(i, x)\n\u0026gt;\u0026gt;\u0026gt; a=[] \u0026gt;\u0026gt;\u0026gt; a.append(1) \u0026gt;\u0026gt;\u0026gt; a.append(3) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a [1, 3] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a.insert(1,100) \u0026gt;\u0026gt;\u0026gt; a [1, 100, 3] \u0026gt;\u0026gt;\u0026gt;   "},{"idx":99,"href":"/docs/programming/list/sort/","title":"リストのソート","content":" リストのソート リスト内の要素をソートする方法についてを示す。\nJava  Javaではリストに関するメソッドがあるライブラリjava.util.Collectionsに、リストをソートするメソッドsort()があるので、それを利用する。\nimport java.util.ArrayList; import java.util.List; import java.util.Collections; class Main{ public static void main(String args[]){ List\u0026lt;Integer\u0026gt; l = new ArrayList\u0026lt;Integer\u0026gt;(); l.add(1); l.add(3); l.add(-2); l.add(100); for(int i=0;i\u0026lt;l.size();i++){ System.out.print(l.get(i) + \u0026#34; \u0026#34;); } System.out.println(); Collections.sort(l); for(int i=0;i\u0026lt;l.size();i++){ System.out.print(l.get(i) + \u0026#34; \u0026#34;); } } } 実行結果\n\u0026gt; java Main 1 3 -2 100 -2 1 3 100   Python  Pythonではリストをソートする関数は以下の2つがある。\n 組み込み関数sorted()\n リストの関数sort()\n  sorted関数は引数に受け取ったリストをソートしたものを返す。この時、リスト自体はソートされた形にはならない。\nsort関数は引数は無く、ソートしたいリストの関数として呼び出し利用する。実行後、リストはインプレース(コピーを取らず、そのリストオブジェクトを直接ソートする)でソートされる。\n\u0026gt;\u0026gt;\u0026gt; a=[1,9,8,7,6,5,3,2] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; sorted(a) [1, 2, 3, 5, 6, 7, 8, 9] \u0026gt;\u0026gt;\u0026gt; a [1, 9, 8, 7, 6, 5, 3, 2] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a.sort() \u0026gt;\u0026gt;\u0026gt; a [1, 2, 3, 5, 6, 7, 8, 9] \u0026gt;\u0026gt;\u0026gt;   "},{"idx":100,"href":"/docs/programming/list/sum/","title":"リストの全要素の合計値","content":" リストの全要素の合計値 リスト中の全要素を合計した値を取得する方法についてを示す。\nまたここで扱うリスト内の要素は全て数値であることを前提とする。\nJava  Javaにはリスト中の全要素を合計するメソッドはない（はず・・）\nそのため、for文ループで一つずつ計算するなどし、算出する。  Python  Pythonでは組み込み関数としてsum()という関数があり、引数として受け取ったイテラブルな値（リストなど）の全要素の合計値を算出してくれる。\n文字列など、計算が行えない値が入っていた場合はエラーになる。\n\u0026gt;\u0026gt;\u0026gt; a=[1,2,3,4,5,6,7,8,9,10] \u0026gt;\u0026gt;\u0026gt; sum(a) 55 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; b=[\u0026#39;a\u0026#39;,\u0026#39;bb\u0026#39;,\u0026#39;ccc\u0026#39;,\u0026#39;dddd\u0026#39;,\u0026#39;eeeee\u0026#39;] \u0026gt;\u0026gt;\u0026gt; sum(b) Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; TypeError: unsupported operand type(s) for +: \u0026#39;int\u0026#39; and \u0026#39;str\u0026#39; \u0026gt;\u0026gt;\u0026gt;   "},{"idx":101,"href":"/docs/programming/list/join/","title":"リストの全要素を連結して１つの文字列に変換する","content":" リストの全要素を連結して１つの文字列に変換する リストの全要素を連結して1つの文字列にする方法についてを示す。 なお、前提としてここでいうリスト内にある要素は全て文字列型とする。\nJava  JavaではStringにjoin()というメソッドがある。これは引数にデリミタとIterable変数を指定し、Iterableの中にある要素を全てデリミタで繋げて出力するというメソッドである。\npublic static String join(CharSequence delimiter, Iterable\u0026lt;? extends CharSequence\u0026gt; elements)\n使用例を以下に示す。\nimport java.util.ArrayList; import java.util.List; class Main{ public static void main(String args[]){ List\u0026lt;String\u0026gt; l = new ArrayList\u0026lt;\u0026gt;(); l.add(\u0026#34;a\u0026#34;); l.add(\u0026#34;bb\u0026#34;); l.add(\u0026#34;ccc\u0026#34;); l.add(\u0026#34;dddd\u0026#34;); System.out.println(l + \u0026#34; -\u0026gt; \u0026#34; + String.join(\u0026#34;\u0026#34;,l)); } } 実行結果\n\u0026gt; java Main [a, bb, ccc, dddd] -\u0026gt; abbcccdddd   Python  Pythonでは文字列の関数にjoin()というのがあり、引数にリスト等を指定してやると、リスト内の要素を呼び出し元の文字列で繋げた文字列を返す。 呼び出し元を \u0026rdquo;\u0026rdquo; にすると、リスト内の要素が全て連結された形で出てくる。\n使用例を以下に示す。\n\u0026gt;\u0026gt;\u0026gt; a=[\u0026#34;a\u0026#34;,\u0026#34;bb\u0026#34;,\u0026#34;ccc\u0026#34;,\u0026#34;dddd\u0026#34;] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a [\u0026#39;a\u0026#39;, \u0026#39;bb\u0026#39;, \u0026#39;ccc\u0026#39;, \u0026#39;dddd\u0026#39;] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026#39;\u0026#39;.join(a) \u0026#39;abbcccdddd\u0026#39; \u0026gt;\u0026gt;\u0026gt;   "},{"idx":102,"href":"/docs/programming/list/list_overview/","title":"リストの定義","content":" リストの定義 リストについて。\nJava  Javaのリストは配列とは全く別のデータ型として定義されてあり、その定義はjava.util.Listクラスにある。\n配列との違いは、配列は宣言時に長さも指定し、基本指定した長さの分しかデータを格納できないのに対し、\nリストは長さを指定せずに宣言でき、かつ好きなだけデータを格納、取り出すことができ、長さは入っているデータにより変わるという、いわば可変長の配列といってもよい。  Python  配列・リストに関して、Pythonには基本「リスト」という概念しかなく、配列は定義されていない。\n他言語でいう配列といったデータ構造は、pythonの場合この「リスト」にひっくるめられていると考えていい（はず・・・） pythonの場合もリストは長さを指定せずに宣言でき、好きなだけデータを格納、取り出すことも可能、そして長さは入っているデータにより変わる。   "},{"idx":103,"href":"/docs/programming/list/list/","title":"リストの宣言","content":" リストの宣言 リストを使用する方法を示す。\nJava  JavaでのリストはListクラスをインポートして利用する。\nしかし、Listクラスはインターフェースであるため、そのまま使用することはできない。\n使用するには、リストの具体的な定義が書いてあるクラスをListのインスタンスに代入して使う。\nこのクラスは複数あるが、ここでは一般的なArrayListクラスを利用する。\nなお、ArrayListも使用するにはインポートする必要がある。\n実行例を以下に示す。\nimport java.util.ArrayList; import java.util.List; class Main{ public static void main(String args[]){ List\u0026lt;Integer\u0026gt; l = new ArrayList\u0026lt;Integer\u0026gt;(); } } なお、ArrayListを宣言するときの記法は以下の通り。\nList\u0026lt;データ型\u0026gt; 変数名 = new ArrayList\u0026lt;データ型\u0026gt;();\nまた、javaでのリストは基本的に、宣言したデータ型の値しか入れることはできない。 今後、javaではリストはArrayListであることを前提に記していく。\n Python  Pythonでリストを宣言するときは変数に角括弧囲いを代入してやればそれがリストとなる。\nまた最初にデータを入れた状態でも宣言可能である。\n\u0026gt;\u0026gt;\u0026gt; a = [] \u0026gt;\u0026gt;\u0026gt; a [] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; b = [1,2] \u0026gt;\u0026gt;\u0026gt; b [1, 2] \u0026gt;\u0026gt;\u0026gt;   "},{"idx":104,"href":"/docs/programming/list/pop/","title":"リストの指定したインデックスの要素を削除する","content":" リストの指定したインデックスの要素を削除する リストの指定した位置の要素を削除する方法についてを示す。\nJava  JavaではListクラスにリストの指定した位置（インデックス）の要素を削除するメソッドremove()がある。\nE remove(int index)\nこのメソッドはリストから指定したインデックスの要素を取り出して返す。その後リストでは取り出されたインデックスよりも後続の要素を左に移動する動作を行う。\nimport java.util.ArrayList; import java.util.List; import java.util.Collections; class Main{ public static void main(String args[]){ List\u0026lt;Integer\u0026gt; l = new ArrayList\u0026lt;Integer\u0026gt;(); l.add(1); l.add(3); l.add(-2); l.add(100); for(int i=0;i\u0026lt;l.size();i++){ System.out.print(l.get(i) + \u0026#34; \u0026#34;); } System.out.println(); System.out.println(l.remove(1)); //lの1番目の要素を取り出して返す  for(int i=0;i\u0026lt;l.size();i++){ System.out.print(l.get(i) + \u0026#34; \u0026#34;); } } } 実行結果\n\u0026gt; java Main 1 3 -2 100 3 1 -2 100   Python  Pythonでの方法は次の2つがある。\n リストの関数pop()を利用する。\n del 文を利用する  pop関数はリストの指定した位置（インデックス）を引数とし、実行するとリストからそのインデックスの要素を取り出し、返す。\ndel文は リスト[インデックス] の形で入力を行い、実行するとリストからそのインデックスの要素が取り出されるが、値は返されない。\n以下に実行例を示す。\n\u0026gt;\u0026gt;\u0026gt; a=[1,9,8,7,6,5,3,2] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a [1, 9, 8, 7, 6, 5, 3, 2] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #pop では値が返ってくる \u0026gt;\u0026gt;\u0026gt; a.pop(1) 9 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a [1, 8, 7, 6, 5, 3, 2] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #delでは取り出された値は返ってこない (返り値無し) \u0026gt;\u0026gt;\u0026gt; del a[1] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a [1, 7, 6, 5, 3, 2] \u0026gt;\u0026gt;\u0026gt;   "},{"idx":105,"href":"/docs/programming/list/insert/","title":"リストの指定した位置に要素追加","content":" リストの指定した位置に要素追加 リストの指定した位置に要素を追加する方法についてを示す。\nJava  JavaではListクラスにadd()というメソッドがある。リストへの要素追加で述べたメソッドと名前が同じであるが、こちらはそれに挿入する位置を引数に追加したメソッドである。\nvoid add(int index,E element)\nこのメソッドを活用することによりリストの任意の位置に要素を追加することができる。\n使用例を以下に示す。\nimport java.util.List; import java.util.ArrayList; class Main{ public static void main(String args[]){ List\u0026lt;String\u0026gt; l = new ArrayList\u0026lt;\u0026gt;(); l.add(\u0026#34;a\u0026#34;); l.add(\u0026#34;b\u0026#34;); l.add(\u0026#34;c\u0026#34;); l.add(\u0026#34;d\u0026#34;); System.out.println(l); //リストの2番目に要素\u0026#34;[2]\u0026#34;を追加  l.add(2,\u0026#34;[2]\u0026#34;); System.out.println(l); } } 実行結果\n\u0026gt; java Main [a, b, c, d] [a, b, [2], c, d]   Python  Pythonではリストに関数insertがある。これを利用することにより、リストの指定した位置に要素を追加できる。\nlist.insert(i, x)\n第１引数はリストのインデックスで、その位置に第２引数xが挿入される。\n実行例を以下に示す。\n\u0026gt;\u0026gt;\u0026gt; l=[1,2,3,4] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; l [1, 2, 3, 4] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; l.insert(2,\u0026#34;[2]\u0026#34;) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; l [1, 2, \u0026#39;[2]\u0026#39;, 3, 4] \u0026gt;\u0026gt;\u0026gt;    "},{"idx":106,"href":"/docs/programming/list/remove/","title":"リストの指定した要素を削除する","content":" リストの指定した要素を削除する リストの指定した要素を削除する方法についてを示す。\nJava  JavaではListクラスにリストの指定した要素を削除するメソッドremove()がある。\nboolean remove(Object o)\nこのメソッドはリストから指定した要素を削除する。複数ある場合は最初のもののみを削除する。\nintのリストで使いたい時は？ intのリストでこのメソッドを使いたい時、先述のリストの指定したインデックスの要素を削除するで述べた\nE remove(int index)\nと混同するだろう。しかしListのメソッドremoveはintの値を入力した場合、このインデックスから要素を削除する方のメソッドが使われる。\n指定したintの要素を削除したい時はどうするか？\n方法は、intのラッパークラスIntegerを利用する。そのメソッドvalueOfを使ってintの値をIntegerに置き換えてremoveメソッドを使うと、前者の指定した要素を削除するremoveが使われる。\n使用例を以下に示す。\nimport java.util.ArrayList; import java.util.List; class Main{ public static void main(String args[]){ List\u0026lt;Integer\u0026gt; l = new ArrayList\u0026lt;Integer\u0026gt;(); l.add(1); l.add(3); l.add(-2); l.add(100); for(int i=0;i\u0026lt;l.size();i++){ System.out.print(l.get(i) + \u0026#34; \u0026#34;); } System.out.println(); l.remove(1); //この場合だとl[1]を削除する  for(int i=0;i\u0026lt;l.size();i++){ System.out.print(l.get(i) + \u0026#34; \u0026#34;); } System.out.println(); l.remove(Integer.valueOf(1)); //この場合だとlで最初に出る「1」を削除する  for(int i=0;i\u0026lt;l.size();i++){ System.out.print(l.get(i) + \u0026#34; \u0026#34;); } } } 実行結果\n\u0026gt; java Main 1 3 -2 100 1 -2 100 -2 100   Python  Pythonにはリストに指定した要素を削除する関数remove()があるので、これを利用する。\n引数にはリストから削除したい要素を入力する。\n指定した要素がリスト内に複数ある場合は、最初のもののみを削除する。\nリストに存在しない値を入力するとエラーになる。\n\u0026gt;\u0026gt;\u0026gt; a=[1,9,8,7,6,5,3,2] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a [1, 9, 8, 7, 6, 5, 3, 2] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a.remove(9) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a [1, 8, 7, 6, 5, 3, 2] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; b=[1,1,1] \u0026gt;\u0026gt;\u0026gt; b [1, 1, 1] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; b.remove(1) \u0026gt;\u0026gt;\u0026gt; b [1, 1] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; b.remove(2) Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; ValueError: list.remove(x): x not in list \u0026gt;\u0026gt;\u0026gt;    "},{"idx":107,"href":"/docs/programming/list/len/","title":"リストの長さ","content":" リストの長さ リストの長さ（＝リストに入っているデータの個数）を取得する方法を示す。\nJava  JavaではListクラスにsize()というメソッドがあり、これはリストに入っているデータの個数（＝リストの長さ）を返してくれる。\nint size()\n実行例を以下に示す。\nimport java.util.ArrayList; import java.util.List; class Main{ public static void main(String args[]){ List\u0026lt;Integer\u0026gt; l = new ArrayList\u0026lt;Integer\u0026gt;(); l.add(1); l.add(3); System.out.println(l.size()); } } 実行結果\n\u0026gt; java Main 2   Python  Pythonではlen()という関数があり、引数のリストの長さ（リスト内の要素の数）を返してくれる。\n\u0026gt;\u0026gt;\u0026gt; a=[1,2,3] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; len(a) 3 \u0026gt;\u0026gt;\u0026gt;   "},{"idx":108,"href":"/docs/programming/list/clear/","title":"リストを空にする","content":" リストを空にする リストから全ての要素を削除する方法についてを述べる。\nJava  JavaではListクラスにあるメソッドclear() を利用する。\nvoid clear()\n実行例を以下に示す。\nimport java.util.List; import java.util.ArrayList; class Main{ public static void main(String args[]){ List\u0026lt;Integer\u0026gt; l = new ArrayList\u0026lt;\u0026gt;(); l.add(1); l.add(2); l.add(3); l.add(4); System.out.println(\u0026#34;clear前\u0026#34; + l); l.clear(); System.out.println(\u0026#34;clear後\u0026#34; + l); } } 実行結果\n$ java Main clear前[1, 2, 3, 4] clear後[]   Python  Pythonではリストにある関数clear()を使う。\n\u0026gt;\u0026gt;\u0026gt; a=[1,2,3,4,5,6] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a [1, 2, 3, 4, 5, 6] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a.clear() \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a [] \u0026gt;\u0026gt;\u0026gt;    "},{"idx":109,"href":"/docs/programming/list/reverse/","title":"リストを逆順にする","content":" リストを逆順にする リスト内の要素を逆順にする方法についてを示す。\nJava  Javaではライブラリjava.util.Collectionsに、リスト内の要素を逆にするメソッドreverse()があるので、それを利用する。\npublic static void reverse(List\u0026lt;?\u0026gt; list)\n実行例を以下に示す。\nimport java.util.ArrayList; import java.util.List; import java.util.Collections; class Main{ public static void main(String args[]){ List\u0026lt;Integer\u0026gt; l = new ArrayList\u0026lt;Integer\u0026gt;(); l.add(1); l.add(3); l.add(-2); l.add(100); for(int i=0;i\u0026lt;l.size();i++){ System.out.print(l.get(i) + \u0026#34; \u0026#34;); } System.out.println(); Collections.reverse(l); for(int i=0;i\u0026lt;l.size();i++){ System.out.print(l.get(i) + \u0026#34; \u0026#34;); } } } 実行結果\n\u0026gt; java Main 1 3 -2 100 100 -2 3 1   Python  Pythonではリストをソートする関数は以下の2つがある。\n 組み込み関数reversed()\n リストの関数reverse()\n  組み込み関数のreversed関数は引数に受け取ったリスト内の要素を逆順にしたイテレータを返す。しかし、イテレータのままでは表示ができないので、リストとして表示するにはlist()でリストにする必要がある。また、reversed関数を実行してもリスト自体の順番は変わらない。\nリスト型のreverse関数は実行するとリストの順番を逆にするが、返り値は何もない(None)になるので注意。実行した後再度リストを表示すると逆順になっている。\n\u0026gt;\u0026gt;\u0026gt; a=[1,9,8,7,6,5,3,2] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; reversed(a) # reversedの返り値（＝イテレータ）をそのまま出力すると以下のようになる \u0026lt;list_reverseiterator object at 0x000002096F480668\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; list(reversed(a)) #reversedの返り値をリスト化する [2, 3, 5, 6, 7, 8, 9, 1] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a # reversedを実行しても元のリストの順番は変わらない [1, 9, 8, 7, 6, 5, 3, 2] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a.reverse() \u0026gt;\u0026gt;\u0026gt; a [2, 3, 5, 6, 7, 8, 9, 1] \u0026gt;\u0026gt;\u0026gt;   "},{"idx":110,"href":"/docs/programming/list/reverse_sort/","title":"リストを逆順にソート","content":" リストを逆順にソート リスト内の要素を逆順にソートする方法についてを示す。\nJava  Javaではリストを逆順にソートするメソッドは無いため、前述のリストのソートとリストを逆順にする方法を組み合わせて利用する。\n実行例を以下に示す。\nimport java.util.ArrayList; import java.util.List; import java.util.Collections; class Main{ public static void main(String args[]){ List\u0026lt;Integer\u0026gt; l = new ArrayList\u0026lt;Integer\u0026gt;(); l.add(1); l.add(3); l.add(-2); l.add(100); for(int i=0;i\u0026lt;l.size();i++){ System.out.print(l.get(i) + \u0026#34; \u0026#34;); } System.out.println(); Collections.sort(l); Collections.reverse(l); for(int i=0;i\u0026lt;l.size();i++){ System.out.print(l.get(i) + \u0026#34; \u0026#34;); } } } 実行結果\n\u0026gt; java Main 1 3 -2 100 100 3 1 -2   Python  Pythonではリストをソートする方法で述べた2つの関数において、それぞれ引数reverseがあり、それをTrueに設定してやると逆順にソートしてくれる。（デフォルトではこの引数reverseはFalseになっている）\n\u0026gt;\u0026gt;\u0026gt; a=[1,9,8,7,6,5,3,2] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; sorted(a,reverse=True) [9, 8, 7, 6, 5, 3, 2, 1] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a [1, 9, 8, 7, 6, 5, 3, 2] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a.sort(reverse=True) \u0026gt;\u0026gt;\u0026gt; a [9, 8, 7, 6, 5, 3, 2, 1] \u0026gt;\u0026gt;\u0026gt;   "},{"idx":111,"href":"/docs/programming/list/swap/","title":"リスト内の指定した２要素を入れ替える","content":" リスト内の指定した２要素を入れ替える リストの指定した２つの位置の要素を入れ替える方法についてを示す。\nJava  JavaはListの親クラスであるCollectionsクラスにswap()メソッドがあるので、これを利用する。\npublic static void swap(List\u0026lt;?\u0026gt; list,int i,int j)\n使用例を以下に示す。\nimport java.util.Collections; import java.util.ArrayList; import java.util.List; class Main{ //List println  public static void listprint(String name,List\u0026lt;Integer\u0026gt; l){ System.out.print(name + \u0026#34;: \u0026#34;); for(int i=0;i\u0026lt;l.size();i++){ System.out.print(l.get(i) + \u0026#34; \u0026#34;); } System.out.println(); } public static void main(String args[]){ List\u0026lt;Integer\u0026gt; a = new ArrayList\u0026lt;Integer\u0026gt;(); a.add(1); a.add(3); a.add(100); a.add(0); listprint(\u0026#34;a\u0026#34;, a); Collections.swap(a,0,2); listprint(\u0026#34;a\u0026#34;, a); } } 実行結果\n\u0026gt; java Main a: 1 3 100 0 a: 100 3 1 0   Python  Pythonではリストの2要素の交換に関しての関数は特に無いが、以下のように書くことで要素の入れ替えが行える。\n（リストの0番目、1番目の要素の入れ替え）\nl[0],l[1] = l[1],l[0]\n使用例を以下に示す。\n\u0026gt;\u0026gt;\u0026gt; a=[1,9,8,7,6,5,3,2] \u0026gt;\u0026gt;\u0026gt; a [1, 9, 8, 7, 6, 5, 3, 2] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a[0],a[2] = a[2],a[0] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a [8, 9, 1, 7, 6, 5, 3, 2] \u0026gt;\u0026gt;\u0026gt;   "},{"idx":112,"href":"/docs/programming/list/max/","title":"リスト内の要素の最大値を取得する","content":" リスト内の要素の最大値を取得する リスト内の要素のうち一番大きい値を取得する方法についてを示す。\nJava  Javaではリストに関するメソッドがあるライブラリjava.util.Collectionsに、リスト内の要素の最大値を取得するメソッドmax()があるので、それを利用する。\nStringなど文字列のリストの場合は、値を辞書順に並べたときの一番後ろの値が返される。\nimport java.util.ArrayList; import java.util.List; import java.util.Collections; class Main{ public static void main(String args[]){ List\u0026lt;Integer\u0026gt; l = new ArrayList\u0026lt;Integer\u0026gt;(); l.add(1); l.add(3); l.add(-2); l.add(100); for(int i=0;i\u0026lt;l.size();i++){ System.out.print(l.get(i) + \u0026#34; \u0026#34;); } System.out.println(); System.out.println( Collections.max(l) ); List\u0026lt;String\u0026gt; s = new ArrayList\u0026lt;String\u0026gt;(); s.add(\u0026#34;a\u0026#34;); s.add(\u0026#34;c\u0026#34;); s.add(\u0026#34;banana\u0026#34;); s.add(\u0026#34;010101\u0026#34;); for(int i=0;i\u0026lt;s.size();i++){ System.out.print(s.get(i) + \u0026#34; \u0026#34;); } System.out.println(); System.out.println( Collections.max(s) ); } } 実行結果\n\u0026gt; java Main 1 3 -2 100 100 a c banana 010101 c   Python  Pythonには組み込み関数max()があり、引数として受け取ったイテラブルな値の最大値を返してくれる。\n要素が文字列の場合は、辞書順に並べたときの一番後ろの値が返される。\n\u0026gt;\u0026gt;\u0026gt; a=[1,9,8,7,6,5,3,2] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; max(a) 9 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; b=[\u0026#34;a\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;banana\u0026#34;,\u0026#34;0101\u0026#34;] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; max(b) \u0026#39;c\u0026#39; \u0026gt;\u0026gt;\u0026gt; b.append(\u0026#34;e\u0026#34;) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; max(b) \u0026#39;e\u0026#39; \u0026gt;\u0026gt;\u0026gt;   "},{"idx":113,"href":"/docs/programming/list/min/","title":"リスト内の要素の最小値を取得する","content":" リスト内の要素の最小値を取得する リスト内の要素のうち一番小さい値を取得する方法についてを示す。\nJava  Javaではリストに関するメソッドがあるライブラリjava.util.Collectionsに、リスト内の要素の最小値を取得するメソッドmin()があるので、それを利用する。\nStringなど文字列のリストの場合は、値を辞書順に並べたときの一番初めの値が返される。\nimport java.util.ArrayList; import java.util.List; import java.util.Collections; class Main{ public static void main(String args[]){ List\u0026lt;Integer\u0026gt; l = new ArrayList\u0026lt;Integer\u0026gt;(); l.add(1); l.add(3); l.add(-2); l.add(100); for(int i=0;i\u0026lt;l.size();i++){ System.out.print(l.get(i) + \u0026#34; \u0026#34;); } System.out.println(); System.out.println( Collections.min(l) ); List\u0026lt;String\u0026gt; s = new ArrayList\u0026lt;String\u0026gt;(); s.add(\u0026#34;a\u0026#34;); s.add(\u0026#34;c\u0026#34;); s.add(\u0026#34;banana\u0026#34;); s.add(\u0026#34;010101\u0026#34;); for(int i=0;i\u0026lt;s.size();i++){ System.out.print(s.get(i) + \u0026#34; \u0026#34;); } System.out.println(); System.out.println( Collections.min(s) ); } } 実行結果\n\u0026gt; java Main 1 3 -2 100 -2 a c banana 010101 010101   Python  Pythonには組み込み関数min()があり、引数として受け取ったイテラブルな値の最小値を返してくれる。\n要素が文字列の場合は、辞書順に並べたときの一番初めの値が返される。\n\u0026gt;\u0026gt;\u0026gt; a=[1,9,8,7,6,5,3,2] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; min(a) 1 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; b=[\u0026#34;a\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;banana\u0026#34;,\u0026#34;0101\u0026#34;] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; min(b) \u0026#39;0101\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; b.append(\u0026#34;000\u0026#34;) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; b [\u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;0101\u0026#39;, \u0026#39;000\u0026#39;] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; min(b) \u0026#39;000\u0026#39; \u0026gt;\u0026gt;\u0026gt;   "},{"idx":114,"href":"/docs/programming/list/comprehension/","title":"リスト内包表記","content":" リスト内包表記 リスト内包表記についてを示す。\nPython  リスト内包とは大かっこ [ ] の中に式とfor文（・if文）を書くことにより、その式によって評価された値のリストを得られるというものである。\n実行例を以下に示す。\n\u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; # 0~4の値のリスト \u0026gt;\u0026gt;\u0026gt; [i for i in range(5)] [0, 1, 2, 3, 4] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; # 0~40,公差3の等差数列 \u0026gt;\u0026gt;\u0026gt; [i for i in range(0,40,3)] [0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; # 0~100のうち11の倍数 \u0026gt;\u0026gt;\u0026gt; [i for i in range(100) if i%11==0] [0, 11, 22, 33, 44, 55, 66, 77, 88, 99] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt;    "},{"idx":115,"href":"/docs/front-end/ruby/","title":"ルビ","content":" ルビ HTML文書にルビ(ふりがな)を記載するための要素についてをここでは述べる。\nruby要素 ruby要素は文字にルビを振る要素であり、実際にルビを振る文字及びルビとなる部分を囲む事で表現する。\n具体的なルビ及びルビを振る対象の文字の指定は、次のrt,rb,rp,rtc要素を使う。以下にそれぞれの要素についてを示す。\nrt要素 rt要素はルビ(ふりがな)自体を表す要素である。rtはruby textの略である。\nrb要素 rb要素はルビを振る対象の部分を表す要素である。rbはruby base textの略である。\nrp要素 rp要素はルビが未対応のブラウザの時に、ルビを振らずに()などでルビを振る文字の後に表示させる要素である。\n使用する際は、()をそれぞれrp要素で囲んで使用する。\nrtc要素 rtc要素は複数のrt要素をグループ化してまとめる要素である。\n使用例 これら要素の使用例を以下に示す。\n\u0026lt;ruby\u0026gt; \u0026lt;rb\u0026gt;薔\u0026lt;/rb\u0026gt; \u0026lt;rp\u0026gt;(\u0026lt;/rp\u0026gt;\u0026lt;rt\u0026gt;ば\u0026lt;/rt\u0026gt;\u0026lt;rp\u0026gt;)\u0026lt;/rp\u0026gt; \u0026lt;rb\u0026gt;薇\u0026lt;/rb\u0026gt; \u0026lt;rp\u0026gt;(\u0026lt;/rp\u0026gt;\u0026lt;rt\u0026gt;ら\u0026lt;/rt\u0026gt;\u0026lt;rp\u0026gt;)\u0026lt;/rp\u0026gt; \u0026lt;rtc\u0026gt;\u0026lt;rp\u0026gt;(\u0026lt;/rp\u0026gt;\u0026lt;rt\u0026gt;ba\u0026lt;/rt\u0026gt;\u0026lt;rt\u0026gt;ra\u0026lt;/rt\u0026gt;\u0026lt;rp\u0026gt;)\u0026lt;/rp\u0026gt;\u0026lt;/rtc\u0026gt; \u0026lt;/ruby\u0026gt;  表示例\n  薔 (ば) 薇 (ら) (bara)  \n"},{"idx":116,"href":"/docs/front-end/responsive_web_design/","title":"レスポンシブWebデザイン","content":" レスポンシブWebデザイン レスポンシブWebデザインについて。\nレスポンシブWebデザインとは、1つのHTMLを画面幅などの特性が異なったデバイスに応じて、自動的にレイアウトやデザインを変更しそれぞれに対応させるといったWebサイトの開発手法の一つである。\n現代では様々なタイプのPCに加え、スマートフォンやタブレットのような機器までもが登場し、またその種類も多様化してきている。\nまた、その度に各機器用のHTMLを作成していると、開発や運用も大変になる。\nそのため、なるべく多くの機器に少ないHTMLファイルで対応できるように、このような開発手法が登場した。\nこのような方法を実装するには、各機器用のCSSを用意し、必要に応じて切り替えて利用する方法(CSSメディアクエリ)が使われる。\nメリットとデメリット レスポンシブWebデザインのメリットとデメリットにはどのようなものがあるだろうか。\nまず、メリットとしては\n 作るHTMLは1つで済み、開発運用コストが削減できる 画面サイズさえ合えば、現在存在しない機器にも対応可能 HTMLは1つなので、特定デバイス向けのサイトは作らずに済む。またそのようなサイトがある場合と比べ、リダイレクトの時間を削減できる。  デメリットとしては\n 1つのHTMLを複数のCSSで使い回すような構造は逆に困難・高コストになる場合もある HTML/CSSの容量が大きくなる時もあり、場合によってはページ表示や動作が遅くなることもある 画面遷移の変更には対応できない  のようなものがある。\nレスポンシブWebデザインで用いる技術 レスポンシブWebデザインに必要な技術についてを述べる。\nメディアクエリ メディアクエリとはCSSの仕様の1つで、機器の特性に応じてCSSを切り替える方式である。レスポンシブWebデザインのキーとなる技術である。\n設定方法は2つあり、1つはHTMLのlink要素でCSSファイルを読み込む際に、media属性を利用する方法である。\n例\n\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; media=\u0026#34;screen and (max-width:500px)\u0026#34; href=\u0026#34;style.css\u0026#34;\u0026gt; この例は、幅が500px以内の画面に対し、指定したCSSを適用する、と言う意味になる。（具体的な属性名などの意味は後述）\nもう1つは、CSSに@media識別子を利用して条件を記述する方法である。\n例\n@media screen and (max-width:500px) { } これらの設定方法において、設定する値はメディア型と呼ばれる対象とするメディアを示す値、そしてメディア特性と呼ばれる幅や高さといった情報を示す値である。値は空白区切りで複数設定できる。\nメディア型の値は以下の通り。\n 値 意味   all 全ての機器   screen PCやスマートフォンなどの画面   print プリンタ   projection プロジェクタ   tv テレビ   handheld 携帯用機器   tty 文字幅が固定の端末   speech スピーチ・シンセサイザー   braille 点字ディスプレイ   メディア特性の値は以下の通り。\n 値 意味   width\nmin-width\nmax-width 画面の幅(の最小/最大値)   height\nmin-height\nmax-height 画面の高さ(の最小/最大値)   device-width\ndevice-min-width\ndevice-max-width デバイスの幅(の最小/最大値)   device-height\ndevice-min-height\ndevice-max-height デバイスの高さ(の最小/最大値)   aspect-ratio\nmin-aspect-ratio\nmax-aspect-ratio 画面のアスペクト比(の最小/最大値)。水平/垂直の整数で指定   device-aspect-ratio\nmin-device-aspect-ratio\nmax-device-aspect-ratio デバイスのアスペクト比(の最小/最大値)。水平/垂直の整数で指定   grid グリッド(1)かそれ以外(0)の画面であるか   resolution\nmin-resolution\nmax-resolution デバイスの解像度(の最小/最大値)   使用例(css)\n@media screen and (min-width:0px){ body{ color: greenyellow; } } @media screen and (min-width:300px){ body{ color: red; } } @media screen and (min-width:600px){ body{ color: blue; } } (html)\n\u0026lt;!DOCTYPE HTML\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;メディアクエリサンプル\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;media_query.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;メディアクエリのテスト\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;幅0px以上で緑、幅300px以上で赤、幅600px以上で青になるはず。\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;ブラウザの幅を変えると色が変化します\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 表示例\n 可変グリッド 可変グリッドとは、グリッドの幅がウィンドウ幅に応じて変化するシステムである。\nグリッドとは、基準となるラインを設定し、そのラインに沿って画像やテキストを配置する方式である。\nグリッドのラインがコンテンツを配置する基準となっているので、見やすいデザインを作ることができる。\n実装するには、グリッド幅に関してはCSSで幅を%などの相対値で指定することによって実現させる。\nまたは、Javascriptなどのライブラリやフレームワークを使ってCSSを動的に変更させて実装する方法もある。\n可変イメージ 可変イメージとは、画像をウィンドウ幅に応じて変更していく手法である。\n可変イメージは、img要素の「max-width」属性を100%とすれば実現可能となる。\n使用例\n\u0026lt;img src=\u0026#34;/img/front-end/img.jpg\u0026#34; style=\u0026#34;max-width: 100%\u0026#34;\u0026gt; 表示例（ブラウザの幅を変えるとサイズが変化します）\nビューポート ビューポートとは、ブラウザの表示領域のことである。Webブラウザでサイトを閲覧する時は、ビューポートのサイズをもとにコンテンツが表示される。\nビューポートの幅や高さは、スマートフォンなどのデバイスのそれとは異なることが多い。そのため、デバイスによっては、サイトを表示するとコンテンツが小さく表示される場合があるので、注意が必要である。\nビューポートに関する指定は、HTMLのmeta要素で行う。name属性にviewportを指定し、content属性にそれぞれ値を指定する。\n指定できるプロパティと意味は以下の通り。\n 値 意味   width ビューポートの幅   height ビューポートの高さ   initial-scale 表示倍率の初期値   minimum-scale 表示倍率の最小値   maximum-scale 表示位置の最大値   リセットCSS 各Webブラウザには、デフォルトでCSSが設定されており、開発者側でCSSを設定しなくてもWebブラウザが設定しているCSSにより、サイトのコンテンツの表示が変わることがある。\nしかし、このWebブラウザが設定しているCSSを考慮しないまま開発者側でCSSを作っていくと、あるブラウザではうまく表示されても別のブラウザでは表示されなくなる、と言うような事態が起きる場合もある。\nそのため、このブラウザによるCSSを打ち消し、ブラウザ間の表示を揃えるためのCSSをまずは適用させる。このようなCSSをリセットCSSと言う。\nリセットCSSはオープンソースとして公開されているものがいくつかあり、それを利用する場合が多い。\n"},{"idx":117,"href":"/docs/programming/machine_learning/logistic_regression/","title":"ロジスティック回帰モデル","content":" ロジスティック回帰モデル 前述の１次元入力２クラス分類において、最適な決定境界を引くにはどうすれば良いのだろうか。\n方法の一つとしてロジスティック回帰モデルがある。\nただし、これが利用できるのは入力データがガウス分布によって生成された時である。\n実は入力データがガウス分布に従っているとき、この１次元入力２クラス分類の条件付き確率P(t=1|x)はロジスティック回帰モデルで表せることがわかっている。\n前述の１次元入力２クラス分類で扱った入力データがガウス分布により生成されたデータであると仮定しよう。\nロジスティック回帰モデルとは、以下の直線モデル(式(1))が与えられた時に、式(2)で表されるモデルである。\n  $$ \\tag{1} y = w_{0} x + w_{1} \\\\ $$ $$ \\begin{aligned} \\tag{2} y \u0026= \\sigma ( w_{0} x + w_{1} ) \\\\ \u0026= \\frac{1}{1 + \\exp(-(w_{0} x + w_{1}))} \\end{aligned} $$ ここで,σ(x)はシグモイド関数であり、以下の式(3)で表される関数である。\n$$ \\tag{3} \\sigma (x) = \\frac{1}{ 1 + \\exp( -x )} $$ ロジスティック回帰モデルにより、出力は0~1の間に限定される。\n例として、y=x,y=2x+2,y=-x+1のロジスティック回帰モデルは以下のようになる。\nこの図より、決定境界をy=0.5となるxに引くと、以下のように表される。\nところで、このロジスティック回帰モデルで使用した直線モデルは何なのか？\n入力データに対して、どのような直線モデルを用いれば良いのか？\n実は、この1次元入力2クラス分類において、このデータに一番合うようなロジスティック回帰モデル　をなす直線モデルのパラメータ(w0,w1)を求めるのが、この分類問題を解く考え方である。\nそのための方法を次章以降で述べる。\n"},{"idx":118,"href":"/docs/programming/graph/func_plot/","title":"一変数関数f(x)をグラフに描画する","content":" 一変数関数f(x)をグラフに描画する 定義した一変数関数f(x)をグラフに描画する方法を示す。\nPython  一変数関数f(x)を描画するには、まず自分で一変数関数を定義し、そこに入力するデータを用意し、実際に関数に入力して得られるデータを用意する。\n入力データと出力データをplotすると関数のグラフの概形が得られる。\n例として、３次関数f(x) = x3を-10~10の範囲で描画して見る。\n\u0026gt;\u0026gt;\u0026gt; import numpy as np \u0026gt;\u0026gt;\u0026gt; import matplotlib.pyplot as plt \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #f(x)定義 \u0026gt;\u0026gt;\u0026gt; def f(x): ... return x**3 ... \u0026gt;\u0026gt;\u0026gt; #入力データxを-10~10の整数で用意 \u0026gt;\u0026gt;\u0026gt; x=np.arange(-10,11,1) \u0026gt;\u0026gt;\u0026gt; x array([-10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #出力データy=f(x)を用意 \u0026gt;\u0026gt;\u0026gt; y=f(x) \u0026gt;\u0026gt;\u0026gt; y array([-1000, -729, -512, -343, -216, -125, -64, -27, -8, -1, 0, 1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #x,yをプロット(描画)する \u0026gt;\u0026gt;\u0026gt; plt.plot(x,y) [\u0026lt;matplotlib.lines.Line2D object at 0x104089860\u0026gt;] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; plt.show() 実行結果\n  "},{"idx":119,"href":"/docs/programming/number/ternary/","title":"三項演算子","content":" 三項演算子 条件分岐を行う三項演算子についてを示す。\nJava  Javaでは三項演算子 \u0026ldquo;?\u0026rdquo; が実装されている。 例えば\na ? b : c\nとしたとき、aがtrueならbを、falseならcを返すという事になる。\n三項演算子の前（上記例でいうa）には必ずboolean値を返すような式にする。\n実行例を以下に示す。\nclass Main{ public static void main(String args[]){ System.out.println(true ? \u0026#34;Yes\u0026#34; : \u0026#34;No\u0026#34;); int a = 0; int b = 1; System.out.println( a\u0026gt;b ? \u0026#34;a\u0026gt;b\u0026#34; : \u0026#34;a\u0026lt;=b\u0026#34;); } } 実行結果\n\u0026gt; java Main Yes a\u0026lt;=b   Python  Pythonには三項演算子は実装されてはいない。\nしかし、if,elseを利用することで三項演算子と同様の動作を行う式を実装することはできる。\n使用法を以下に示す。\nb if a else c\nこの式では、aがTrueの時bを、Falseならcを返すという意味である。\n無論だが、aにはTrueまたはFalseを返すような式を入力する。\n実行例を以下に示す。\n\u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a = \u0026#34;Yes\u0026#34; if True else \u0026#34;No\u0026#34; \u0026gt;\u0026gt;\u0026gt; print(a) Yes \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a = 0 \u0026gt;\u0026gt;\u0026gt; b = 1 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print( \u0026#34;a\u0026gt;b\u0026#34; if a\u0026gt;b else \u0026#34;a\u0026lt;=b\u0026#34; ) a\u0026lt;=b \u0026gt;\u0026gt;\u0026gt;  Javascript  JavascriptでもJavaと同じく三項演算子 \u0026ldquo;?\u0026rdquo; が実装されている。利用法も同じで\na ? b : c\nである。条件式aがtrueならb、falseならcを実行する。\n  "},{"idx":120,"href":"/docs/programming/procon/bipartite_graph/","title":"二部グラフ","content":" 二部グラフ 前述のグラフの彩色問題において、彩色数(グラフの頂点を彩色するのに必要な最小の色数)が2であるグラフを二部グラフという。\nグラフが与えられたとき、それが二部グラフであるかを判定するには、適当な点から彩色して行っていけば良い。２色のみで塗れたら、二部グラフと判定できる。これには深さ優先探索を用いてやると良い。\nV=10 #頂点の数(入力) G=[[] for _ in range(V)] #グラフ（入力） color=[0 for _ in range(V)] #頂点の色 def dfs(v,c): color[v]=c for i in range(len(G[v])): #隣接している頂点が同じ色ならfalse if(color[G[v][i]]==c): return false #隣接している頂点がまだ塗られていないなら-cで塗る if(color[G[v][i]]==0 and not dfs(G[v][i],-c)): return false #全ての頂点を塗れたらTrue return True for i in range(V): if(color[i]==0): #まだ頂点iが塗られていなければ1で塗る if(not dfs(i,1)): print(\u0026#34;No\u0026#34;) break else: print(\u0026#34;Yes\u0026#34;) 試しに上の図の二部グラフをこれで判定してみよう(以下に図示する)\nこのグラフの上記コードのV,Gで表すと以下のようになる。\nV=7 G=[[1,3,5],[0,2,6],[1,3],[0,2,4],[3,5],[0,4,6],[1,5]] 実行結果\nYes  "},{"idx":121,"href":"/docs/programming/machine_learning/cross_entropy_error/","title":"交差エントロピー誤差","content":" 交差エントロピー誤差 前述のロジスティック回帰モデルにおいて、入力xがt＝1となる確率を次のように表す。\n  $$ y = \\sigma ( w_{0} x + w_{1} ) = P(t=1 \\mid x) $$ ここから、データに合うようなw0とw1を最尤推定法を用いて求めていく。\n「このモデルから入力データが生成されたとして、最もありえる（確率の高い）パラメータを求める」という方針である。\nまずは入力データそれぞれにおいてこのロジスティック回帰モデルから生成された確率（尤度）を求める。\n上式yは入力xに対して出力tが1となる確率なので、入力データxに対しt＝1だったら、ロジスティック回帰モデルから生成される確率はこのロジスティック回帰モデルの出力そのものなのでyとなる。逆に入力データxに対しt＝0だったら、確率は1ーyである。\n$$ \\tag{1} \\begin{aligned} P(t=1 \\mid x) \u0026= y \\\\ P(t=0 \\mid x) \u0026= 1-y \\end{aligned} $$ しかし、この式をできればもう少し一般化して、どのような入力データにも適用できる形にしたい。\nそこで、上式を以下のように書き換える。\n$$ \\tag{2} P(t \\mid x) = y^t (1-y)^{1-t} $$ この式(1)と式(2)は同じ形になる。\nこの式を利用し、データがN個だった場合、入力データX=x0,…xN-1に対し出力データT=t0,…tN-1が得られる確率は、以下の式(3)で表される。\n$$ \\tag{3} \\begin{aligned} P( { \\bf T } \\mid { \\bf X } ) \u0026= \\prod_{n=0}^{N-1} P( t_{n} \\mid x_{n} ) \\\\ \u0026= \\prod_{n=0}^{N-1} y_{n}^{t_{n}} (1-y_{n})^{1-t_{n}} \\end{aligned} $$ この式(3)が、データに対する尤度となる。\n式(3)において、対数尤度を取ることにより、最尤推定値を求めてみよう。\n式(3)の両辺の対数を取ると以下のようになる。\n$$ \\tag{4} \\log P( { \\bf T } \\mid { \\bf X } ) = \\sum_{n=0}^{N-1} ( t_{n} \\log y_{n} + (1 - t_{n}) \\log (1 - y_{n}) ) $$ ここで、この両辺に-1をかけると\n$$ \\tag{5} - \\log P( { \\bf T } \\mid { \\bf X } ) = - \\sum_{n=0}^{N-1} ( t_{n} \\log y_{n} + (1 - t_{n}) \\log (1 - y_{n}) ) $$ となり、この式(5)において左辺の式を交差エントロピー誤差と呼び、最尤推定値はこの交差エントロピー誤差の値が最も小さくなるような値である。\nここで、式(5)の両辺にさらに1/Nをかけると\n$$ \\tag{6} - \\frac{1}{N} \\log P( { \\bf T } \\mid { \\bf X } ) = - \\frac{1}{N} \\sum_{n=0}^{N-1} ( t_{n} \\log y_{n} + (1 - t_{n}) \\log (1 - y_{n}) ) $$ となり、この式(6)において左辺の式を平均交差エントロピー誤差と呼ぶ。実は交差エントロピー誤差よりも、この平均交差エントロピー誤差を最小にすることを考える方が、データ数に影響されにくく、都合が良い。\n以下、ロジスティック回帰モデルを算出するコード、および平均交差エントロピー誤差を算出するコードを示す。\n(logistic_regression.py)\nimport numpy as np from sigmoid import sigmoid #ロジスティック回帰モデル def logistic_regression(w,x): x=w[0]*x + w[1] return sigmoid(x) (cross_entropy_error.py)\nimport numpy as np from logistic_regression import logistic_regression #交差エントロピー誤差 def cross_entropy_error(w,x,t): y=logistic_regression(w,x) cee=0 for n in range(len(y)): cee += -(t[n]*np.log(y[n]) + (1-t[n])*np.log(1-y[n])) return cee #平均交差エントロピー誤差 def ave_cross_entropy_error(w,x,t): return cross_entropy_error(w,x,t)/len(y) これらを利用し、平均交差エントロピー誤差を最小にするようなwを求めていけば良い。\nその方法についてを次章で述べる。\n"},{"idx":122,"href":"/docs/programming/machine_learning/cross_validation/","title":"交差検証","content":" 交差検証 先述のホールドアウト検証では、訓練(テスト)データの選び方によって出力結果が変わってくることを話した。なるべく変化が少なくなるようにするにはどうすれば良いのだろうか。\n方法の一つとして、交差検証という方法を示す。\nこれは簡単にいうとホールドアウト検証を分割した全パターンで行い、それぞれの出力の平均値を評価に利用するという方式である。\nデータを分割した個数でK-分割交差検証とも呼ぶ。\nデータがN個あるとき、Kは1≦K≦Nの範囲で分割を行える。最大の分割数はK=Nで、このときテストデータの個数は１個になる。この場合の交差検証のことを特別にリーブワンアウト交差検定と呼ぶ。\n先ほどのホールドアウト検証において、分割したデータのうち一つをテストデータとおいた場合での実行を全パターン、行ってみる。\nk分割交差検証を行うコードは以下の通り。(k_hold_cross_validation.py)\nimport numpy as np from linear_basis_function import mse from linear_basis_function import design_matrix from linear_basis_function import linear_basis_func #k分割交差検証 x:入力データ、t:実測値、m:線形基底関数モデルの数、k:分割する個数 def k_hold_cross_validation(x,t,m,k): x=np.array(x) t=np.array(t) n=x.shape[0] mse_train=np.zeros(k) mse_test=np.zeros(k) mu=np.linspace(min(x),max(x),m) for i in range(k): x_train = x[np.fmod(range(n),k) != i] t_train = t[np.fmod(range(n),k) != i] x_test = x[np.fmod(range(n),k) == i] t_test = t[np.fmod(range(n),k) == i] w_train = design_matrix(x_train,t_train,mu,1) y_train = linear_basis_func(w_train,x_train,mu,1) mse_train[i] = mse(y_train,t_train) y_test = linear_basis_func(w_train,x_test,mu,1) mse_test[i] = mse(y_test,t_test) return mse_train,mse_test 例として、M=3,k=4とした時の実行結果は以下の通り。(k_hold_cross_validation_example.py)\nimport numpy as np from k_hold_cross_validation import k_hold_cross_validation #入力値 x = np.load(\u0026#39;x.npy\u0026#39;) #実測値 t = np.load(\u0026#39;t.npy\u0026#39;) mse_train,mse_test=k_hold_cross_validation(x,t,3,4) print(mse_train) print(mse_test) #標準偏差(mseの平均の平方根)の算出 print(\u0026#34;train:{0}\u0026#34;.format(np.sqrt(np.mean(mse_train)))) print(\u0026#34;test :{0}\u0026#34;.format(np.sqrt(np.mean(mse_test)))) 実行結果\n[11.34746956 11.29719213 14.20404757 8.14992362] [13.17632534 12.04601311 3.21443304 21.05860186] train:3.354051016302551 test :3.5176474150746544  実行結果において、最初のarrayは訓練データの平均二乗誤差、その次のarrayはテストデータの平均二乗誤差を示している。 k=4のため、データを４分割し、そのうちの一つをテストデータとして利用し、残りを訓練データとして利用するのを４パターン行うため、結果として配列の長さは４になる。 一つのMに対する評価指標としては、この算出した訓練データ及びテストデータの平均二乗誤差の標準偏差とする。\nこのコードを利用し、M:1~10の範囲で、分割数を最大にしたリーブワンアウト検証を利用して最適なMを求めてみることを考える。\nリーブワンアウト検証を利用したMを求めるコードは以下の通り。(k_hold_cross_valisation_plot.py)\nimport numpy as np import matplotlib.pyplot as plt from k_hold_cross_validation import k_hold_cross_validation #入力値 x = np.load(\u0026#39;x.npy\u0026#39;) #実測値 t = np.load(\u0026#39;t.npy\u0026#39;) #分割数 k = len(x) #m M = range(1,10) train=np.zeros(len(M)) test=np.zeros(len(M)) for i in range(len(M)): train_i,test_i=k_hold_cross_validation(x,t,M[i],k) train[i]=np.sqrt(np.mean(train_i)) test[i]=np.sqrt(np.mean(test_i)) plt.xlim(min(M)-1,max(M)+1) plt.ylim(min(min(train),min(test))-1,max(max(train),max(test))+1) plt.plot(M,test,color=\u0026#39;red\u0026#39;,label=\u0026#39;test\u0026#39;) plt.plot(M,train,color=\u0026#39;blue\u0026#39;,label=\u0026#39;train\u0026#39;) plt.legend(loc=\u0026#39;lower left\u0026#39;) plt.grid(True) plt.show() 実行結果\nとなり、リーブワンアウト検証によりM=5の時にテストデータの誤差が最も小さくなり、最適ということになる。\n"},{"idx":123,"href":"/docs/programming/number/log/","title":"任意の底の対数","content":" 任意の底の対数 任意の底の対数を算出する方法についてを示す。 しかし、任意の底の対数を算出するライブラリは無いことが多い。 そのため、以下の公式を用いて算出を行う。（底の変換公式）\nlogab = logcb / logca\nJava  Javaには任意の底での対数を算出するメソッドは無いため、\n底の変換公式 を用いて前述のlog10()、loge() を利用し算出する。\nimport java.lang.Math; class Main{ public static void main(String args[]){ int a = 2; int b = 4; int c = 1024; //log2(n)を算出する  System.out.println(Math.log(b)/Math.log(a)); //log(2)4  System.out.println(Math.log(c)/Math.log(a)); //log(2)1024  } } 実行結果\n\u0026gt; java Main 2.0 10.0   Python  pythonには任意の数を底とする対数を算出する関数が存在し、\nそれは自然対数を算出する時にも利用したmathモジュールにあるlog()関数である。\nmath.log(x,y)\nlog(x,y)関数は、yを底としたxの対数を返す。\nyを略した場合（引数１つの場合）、底は自動的にeとなり、自然対数になる。(→自然対数)\n使用するにはmathモジュールをインポートする。\n\u0026gt;\u0026gt;\u0026gt; import math \u0026gt;\u0026gt;\u0026gt; a=2 \u0026gt;\u0026gt;\u0026gt; b=4 \u0026gt;\u0026gt;\u0026gt; c=1024 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; math.log(b,a) 2.0 \u0026gt;\u0026gt;\u0026gt; math.log(c,a) 10.0 \u0026gt;\u0026gt;\u0026gt;   "},{"idx":124,"href":"/docs/programming/exception/throw/","title":"例外の明示的な発生","content":" 例外の明示的な発生 例外(エラー)は実行時にコードの不備によりに起こるのみではなく、（コード中で）自分で意図的に発生させることもできる。ここではその方法についてを示す。\nJava  Javaではthrow文を使うことで指定した例外を発生することができる。\n使用例\nthrow new Exception(); Exception e = new Exception(); throw e;  実行例を以下に示す。\nclass Main{ public static void main(String args[]){ try{ throw new Exception(); }catch(Exception e){ System.out.println(e.getMessage()); } } } 実行結果\n\u0026gt; java Main null   Python  Pythonではraise文を使うことで指定した例外を発生する事ができる。\n\u0026gt;\u0026gt;\u0026gt; raise NameError(\u0026#34;例外発生!\u0026#34;) Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; NameError: 例外発生! \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; try: ... raise NameError(\u0026#34;例外発生!\u0026#34;) ... except NameError: ... print(\u0026#34;NameError発生!\u0026#34;) ... NameError発生! \u0026gt;\u0026gt;\u0026gt;   "},{"idx":125,"href":"/docs/programming/exception/exception_index/","title":"例外処理","content":" 例外処理 プログラミングをする上で誰もが経験するのはエラー（例外）だろう。\nコンパイルエラーに関しては文法上の問題なので、ここでは主に実行時エラーに関することについてを示す。\n 例外処理  例外処理(try文) 自分で例外クラスを定義する 例外の明示的な発生   "},{"idx":126,"href":"/docs/programming/exception/try/","title":"例外処理(try文)","content":" 例外処理(try文) 実行時エラー(例外)のハンドリングを行うtry文についてを示す。\n言語により微妙に呼び名が違うところがあるので注意。\nJava  Javaではtry-catch(-finally)文で実行時エラー(例外)のハンドリングを行う。\n記法は以下の通り。\ntry { //処理文 } catch(例外クラス名 変数名){ //例外発生時の処理 } //(catch文は何個でも記述できる) finally{ //try文またはcatch文の処理終了時に行う処理 }  Javaでは例外が発生しうる箇所をtry{}で囲んでおくと、例外発生時に処理を中断してcatch文へと飛ぶ。\ncatch文は宣言時に、例外クラス名と(catch文内で利用する)変数を指定する。このcatch文はいくらでも宣言でき、try文内で発生した例外は対応するcatch文へと飛ぶ。try文内で発生した例外がcatch文で書かれていない場合はハンドリングができないので注意。\nfinally文はtry・catch文の処理が終わった後に実行される文である。実行時に例外が発生した場合・しなかった場合の両方の場合で実行する処理をここに記述する。ちなみにfinally文は宣言してもしなくても良い。\n実行例を以下に示す。\nimport java.lang.Math; class Main{ public static void main(String args[]){ //a[0]~a[3]  int[] a = {0,1,2,3}; //0~7の間でランダムに数値生成  int max = (int)(Math.random()*7); System.out.println(\u0026#34;random:\u0026#34;+max); try{ //max\u0026lt;3なら正常終了、3以上なら実行時エラー発生  for(int i=0;i\u0026lt;max;i++){ System.out.println(\u0026#34;a[\u0026#34;+i+\u0026#34;]:\u0026#34;+a[i]); } }catch(ArrayIndexOutOfBoundsException e){ //配列の範囲外参照エラー発生時の処理(ArrayIndexOutOfBoundsException)  System.out.println(\u0026#34;Error!!\u0026#34;); }finally{ //エラー発生してもしなくても実行される  System.out.println(\u0026#34;finally\u0026#34;); } } } 実行結果\n$ java Main random:6 a[0]:0 a[1]:1 a[2]:2 a[3]:3 Error!! finally $ java Main random:3 a[0]:0 a[1]:1 a[2]:2 finally   Python  Pythonではtry-except(-finally)文で実行時エラー(例外)のハンドリングを行う。\n記法は以下の通り。\ntry: # 処理文 except (例外の型名): # 処理文 #exceptは何個でも記述可能 finally: # 処理文  try文の中に例外が発生しうる処理文を記述する。\n例外が発生した場合は処理を中止しexcept文の該当する例外の所に飛ぶ。except文の宣言時には例外の型名を書く。 発生した例外がexcept文で書かれていない場合はハンドリングができないので注意。\nfinally文はjavaと同じく、例外が発生してもしなくても最後に実行される文である。finally文は記述しなくても良い。\n実行例を以下に示す。\n\u0026gt;\u0026gt;\u0026gt; 2//0 Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; ZeroDivisionError: integer division or modulo by zero \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; try: ... print(2//0) ... except ZeroDivisionError: ... print(\u0026#34;ゼロ除算例外発生\u0026#34;) ... finally: ... print(\u0026#34;finally\u0026#34;) ... ゼロ除算例外発生 finally \u0026gt;\u0026gt;\u0026gt;  ここでは0で割ったときにゼロ除算の例外ZeroDivisionErrorが発生するが、try-exceptでハンドリングをすると、例外発生時にそれに対応したexcept文の内容が実行される。\nその後、finally文の内容が実行される。\n  "},{"idx":127,"href":"/docs/about/disclaimer/","title":"免責事項","content":" 免責事項 本ブログにおける免責事項は、下記の通りです。\n本ブログの情報の正確性について 本ブログのコンテンツや情報において、可能な限り正確な情報を掲載するよう努めています。しかし、誤情報が入り込んだり、情報が古くなったりすることもあります。必ずしも正確性を保証するものではありません。また合法性や安全性なども保証致しません。ご参考の際は自己責任でお願いします。\n損害等の責任について 本ブログに掲載された内容によって生じた損害等の一切の責任を負いかねますので、ご了承ください。 また本ブログからリンクやバナーなどによって他のサイトに移動された場合、移動先サイトで提供される情報、サービス等について一切の責任も負いません。 本ブログを利用する場合は、自己責任で行う必要があります。\n"},{"idx":128,"href":"/docs/programming/number/pi/","title":"円周率(π)","content":" 円周率(π) 重要な定数は大体ライブラリ（モジュール）内で定義されていることが多い。 ここでは円周率(π)を参照する方法についてを示す。\nJava  Javaではjava.lang.Mathクラス内にフィールド変数PIが定義されており、これがJava上で円周率に最も近い数とされている。\n利用するにはjava.lang.Mathクラスをインポートする。\nちなみに型はDouble型である。\nimport java.lang.Math; class Main{ public static void main(String args[]){ System.out.println(Math.PI); } } 実行結果\n\u0026gt; java Main 3.141592653589793   Python  pythonではmathモジュールに定数piが定義されており、これがpython上で最も円周率に近い数とされている。 利用するにはmathモジュールをインポートする。\n\u0026gt;\u0026gt;\u0026gt; import math \u0026gt;\u0026gt;\u0026gt; math.pi 3.141592653589793 \u0026gt;\u0026gt;\u0026gt;   "},{"idx":129,"href":"/docs/programming/control/control_index/","title":"制御構文","content":" 制御構文 プログラミングをする上で必ずと言っていいほど出るのがこの制御構文。\n条件分岐やループなど、処理の流れを制御する文の記法などをここでは示す。\n 制御構文  if-else文 for文 while文 break文 continue文 switch文 pass文   "},{"idx":130,"href":"/docs/programming/procon/dynamic_planning/","title":"動的計画法","content":" 動的計画法 動的計画法について。\n動的計画法とはアルゴリズム設計手法の一つで、配列やリストの要素をそれ以前に算出した別の要素を使って算出する手法である。\n要素を漸化式で表せる時に適用しやすい。\n1次元の例(フィボナッチ数列) 1次元での動的計画法の例としてフィボナッチ数列を挙げる。\nフィボナッチ数列とは\n F (n) =  {  0  n = 0    1  n = 1     F (n-2) + F (n-1)   other     で表される数列である。\n大体の場合は以下のように、再帰を使って求められることが多い。\ndef fib(n): if(n=0): return 0 elif(n==1): return 1 elif(n\u0026gt;1): return fib(n-2) + fib(n-1) しかし、数が大きいと計算量が膨大となり、また途中で同じ値を求める計算を複数回行うこともあり非効率な時がある。\nこのような時、動的計画法を使うと一度計算した結果を記憶しているため参照するだけで利用でき、再帰よりも効率的に求められる。\n利用例を以下に示す。\ndp = [0 for _ in range(n+1)] dp[1]=1 def fib(n): if(n==0 or n==1 or dp[n]!=-1): #n=0,1またはdp[n]が計算済みならそれを出力 return dp[n] elif(n\u0026gt;1): #dp[i] = dp[i-1] + dp[i-2]をnまで計算 for i in range(2,n+1): dp[i] = dp[i-1] + dp[i-2] 一連の動作を図で表すと以下の通りになる。\n2次元の例（ナップザック問題） 動的計画法の2次元での問題例として有名なのが　ナップザック問題　である。\nナップザック問題とは 重さがwi、価値がviであるようなn個の品物があった時、重さの総和がWを超えないように品物を選ぶ時の、価値の総和の最大値を求める問題である。(0\u0026lt;i≦n)\n深さ優先探索や全探索等を用いて求める方法が考えられるが、 計算量が膨大( O(2n) )となり非効率な場合もある。\n(ビット)全探索を用いた実装例を以下に示す。\nn=int(input()) #品物の数 w=list(map(int,input().split())) #重さ v=list(map(int,input().split())) #価値 W=int(input()) #重さの閾値 ans=0 #答え for i in range(2**n): bit_i = bin(i)[2:].zfill(n) #数字iをn桁の2進数で表す vi=0 #bit_iのパターンの時の価値 wi=0 #bit_iのパターンの時の重さ for j in range(n): if(bit_i[j] == \u0026#39;1\u0026#39;): vi+=v[i] #bit_iのj番目の桁が1ならj番目の品物を選ぶ wi+=w[i] if(wi\u0026lt;=W): ans=max(ans,vi) #重さがW以下で価値がこれまで調べたものより大きいならそれを最大価値とする print(ans) #最大価値を出力 そこで、動的計画法を用い、計算を効率化させることを考える。\nまず、2次元リストdp[i][j]を用意する。dp[i][j]を「i番目の品物までの間で、重さの総和がjを超えないような選び方での価値の最大値」と定義する。\nこの時、dpは以下の式で表せられる。\n dp i j =  {   max ( dp [ i - 1 ] [ j - w [ i - 1 ] ] + v [ i - 1 ] , dp [ i - 1 ] [ j ] )   ( j \u0026gE; w [ i - 1 ] )     dp [ i - 1 ] [ j ]   ( j  w [ i - 1 ] )     例として、ナップザックの容量Wを9、品物の価値v、重さwを(v,w)={(2,4),(1,3),(3,1),(3,3),(1,2)}とした時の動作を図で表すと以下の通り。\n動的計画法を用いると計算量はO(nW)となり、全探索を行うよりも非常に効率的に行える。\n実装例を以下に示す。\nw=list(map(int,input().split())) #重さ v=list(map(int,input().split())) #価値 W=int(input()) #重さの閾値 dp=[[0 for _ in range(W+1)] for _ in range(n+1)] for i in range(1,n): for j in range(1,W): if(j\u0026lt;w[i-1]): dp[i][j] = dp[i-1][j] else: dp[i][j] = max(dp[i-1][j-w[i-1]]+v[i-1],dp[i-1][j]) print(dp[n][W]) #n番目の品物の中から重さの総和がWを超えない選び方での最大の価値 = 答え"},{"idx":131,"href":"/docs/programming/procon/dp_applied/","title":"動的計画法の応用題","content":" 動的計画法の応用題 動的計画法の応用問題をいくつか紹介する。\n最長共通部分列問題 例えば以下のような問題。\n２つの文字列s,tの共通部分文字列の長さの最大値を求めなさい。 ただし、文字列xの部分文字列とは、xから連続するn文字 (0≦n≦|x|) を取り出してできる文字列のことである。  ２つの文字列の部分文字列として当てはまる文字列のうち、最長となるものの長さを求める問題で、このような問題は最長共通部分列問題(LCS: Longest Common Subsequence)と呼ばれている。この問題も、動的計画法で行える。\n２次元リストdp[i][j]を「sのi文字目までの文字列とtのj文字目までの文字列における最長共通部分文字列の長さ」とする。\nこの時、以下の式が成り立つ。\n  $$ dp[i+1][j+1] = \\begin{cases} max(dp[i][j]+1,dp[i][j+1],dp[i+1][j]) \u0026 ( (sのi+1文字目) = (tのj+1文字目) ) \\\\ max(dp[i][j+1],dp[i+1][j]) \u0026 (それ以外) \\end{cases} $$ 図で表すと、以下のようになる。\n実装例を以下に示す。\ns=input() #文字列s t=input() #文字列t dp=[[0 for _ in range(len(t)+1)] for _ in range(len(s)+1)] for i in range(len(s)): for j in range(len(t)): if(s[i]==t[j]): dp[i+1][j+1] = max(dp[i][j]+1,dp[i+1][j],dp[i][j+1]) else: dp[i+1][j+1] = max(dp[i+1][j],dp[i][j+1]) print(dp[len(s)][len(t)]) #sとtの最長共通部分文字列の長さ = 答え  個数制限なしナップザック問題 重さがwi、価値がviであるようなn個の品物があった時、重さの総和がWを超えないように品物を選ぶ時の、価値の総和の最大値を求めよ。 ただし、同じ品物を複数回選んでも良い。  前述の動的計画法の章では１つの品物は複数回選べない指定であったが、同じ品物を複数回取れるとなるとどのようにすれば良いか。\nこの問題も動的計画法を応用してできる。２次元リストdp[i][j]を以下のように設定する。\ndp[i+1][j] = i番目までの品物から重さの総和がj以下となるような時の、価値の総和の最大値\nすると、漸化式は以下のようになる。\n$$ \\begin{cases} dp[0][j] \u0026= 0 \\\\ dp[i+1][j] \u0026= max( dp[i][j-k*w[i]] + k*v[i] |　0 \\leq k \\leq \\frac{j}{w[i]} ) \\end{cases} $$ 実装例を以下に示す。\n#個数制限なしナップザック問題 #個数,最大の重さ n,W=map(int,input().split()) #価値と重さ v=[] w=[] #vi,wiでi番目の品物の価値と重さ for i in range(n): vi,wi=map(int,input().split()) v.append(vi) w.append(wi) #dp dp=[[0 for _ in range(W+1)] for _ in range(n+1)] #計算 for i in range(n): for j in range(W+1): k=0 while(k*w[i]\u0026lt;=j): dp[i+1][j] = max(dp[i+1][j],dp[i][j-k*w[i]]+k*v[i]) k+=1 #答え print(dp[n][W]) これで良いか、と言いたいところだが、コードを見てくれたらわかるように、このアルゴリズムだと計算量がO(nW2)となり不十分である。\n計算過程を図にすると以下の通りである。(値は例)\n図を見てわかるように、dp[i+1][j]のところでk≧1の計算をするときに計算を複数回行う箇所がある。\nここが改善のポイントで、dp[i][j]からi番目の品物をk個選んだ結果をdp[i+1][j+k*w[i]]とするのではなく、i番目の品物を0個選んだ結果(dp[i+1]j)にi番目の品物を1個選んだときの結果を利用していけばよい。(dp[i+1][j+w[i]]=dp[i+1][j]+v[i]) k≧1での複数回計算をせずとも、この計算1回だけを行えば,kに関するループがなくなる。\n図で表すと以下のようになる。\nコード例は以下の通り。(計算部分のみ抜粋)\n#計算 for i in range(n): for j in range(W+1): if(j\u0026lt;w[i]): dp[i+1][j]=dp[i][j] else: dp[i+1][j]=max(dp[i][j],dp[i+1][j-w[i]]+v[i])  値が大きい時 続いて、例その２。\n重さがwi、価値がviであるようなn個の品物があった時、重さの総和がWを超えないように品物を選ぶ時の、価値の総和の最大値を求めよ。 ただし、同じ品物を複数回選んでも良い。 (制約) 1≦n≦100 1≦wi≦10000000 1≦vi≦100 1≦W≦1000000000  先ほどと同じ問題だが、今度は各変数の最大値がかなり大きな数になっており、先ほどと同じアルゴリズムを適用するとかなり長い時間がかかってしまう。\nしかし、今回は価値の値が小さいので、そちらを使って動的計画法を利用することを考えてみる。\n２次元リストdp[i][j]を以下のように設定する。\ndp[i+1][j] = i番目までの品物から価値の総和がjとなるように選んだ時の、重さの総和の最小値（存在しない場合はINF）\nこの時、漸化式は以下のようになる。\n$$ \\begin{cases} dp[0][0] \u0026= 0 \\\\ dp[0][j] \u0026= INF \\\\ dp[i+1][j] \u0026= min( dp[i][j],dp[i][j-v[i]]+w[i] ) \\end{cases} $$ コード例は以下の通り。(計算部分のみ抜粋)\nimport math dp=[[math.inf for _ in range(n*max(v)+1)] for _ in range(n+1)] dp[0][0]=0 #計算 for i in range(n): for j in range(n*max(v)+1): if(j\u0026lt;v[i]): dp[i+1][j]=dp[i][j] else: dp[i+1][j]=min(dp[i][j],dp[i][j-v[i]]+w[i])  個数制限付き部分和問題 n種類の数aiがそれぞれmi個ずつあります。これらの中からいくつか選び、その総和をちょうどKにすることができるか判定しなさい。 (制約) ・1≦n≦100 ・1≦ai,mi≦100000 ・1≦K≦100000  解き方は様々あるが、一例として2次元リストdpを以下のように設定してみよう。\ndp[i][j]:i番目までの数値でjが作れるか\ni番目までの数値でjを作るには、i-1番目までの数値で j-α×(i番目の数値) が作れる必要がある。(αは0以上の整数)\nしたがって、漸化式は以下のようになる。\n$$ dp[i][j] = \\begin{cases} True \u0026 (dp[i-1][j-k*a_i] = True となるk (0 \\leqq k \\leqq m_{i} かつ k a_i \\leqq j) が存在する場合) \\\\ False \u0026 (otherwise) \\end{cases} $$ コード例は以下の通り。\nn=3 a=[3,5,8] m=[3,2,2] K=17 dp=[[False for _ in range(K+1)] for _ in range(n+1)] dp[0][0]=True for i in range(n): for j in range(K+1): if(dp[i][j]): k=0 while j+k*a[i]\u0026lt;=K: dp[i+1][j+k*a[i]]=True k+=1 print(dp[n][K])  最長増加部分列問題 増加部分列とは、数列aiにおいて、全てのl＜mにおいてal＜amが成り立つ部分列のことである。\n最長増加部分列問題(LIS:Longest Increasing Subsequence)とは、数列の内の最も長い部分列を求める問題である。\n例題を以下に記載する。\n長さnの数列a\u0026lt;sub\u0026gt;0\u0026lt;/sub\u0026gt;,a\u0026lt;sub\u0026gt;1\u0026lt;/sub\u0026gt;,・・・a\u0026lt;sub\u0026gt;n-1\u0026lt;/sub\u0026gt;があります。この数列の増加部分列のうち、最長のものの長さを求めなさい。 (制約) 1≦n≦1000 0≦ai≦1000000  この問題も動的計画法を用いることで解くことができる。リストdpを以下のように設定する。\ndp[i]: 最後がaiであるような最長の部分文字列の長さ\nこの時、dp[i]は以下の式で表される。\n$$ dp[i][j] = max(1,dp[j]+1 |　j コード例を以下に示す。計算量はO(n2)である。\nn=5 a=[4,2,3,1,5] dp=[0 for _ in range(n)] for i in range(n): dp[i]=1 for j in range(i): if(a[j] \u0026lt; a[i]): dp[i]=max(dp[i],dp[j]+1) print(max(dp)) 実行結果\n3   分割数 n個の互いに区別できない品物を、m個以下に分割する方法の総数を求め、Mで割った余りを答えなさい。 (制約) 1≦m≦n≦1000 2≦M≦10000  このような問題をnのm分割という。n=mの時はnの分割数という。\nこれに動的計画法を適用してみよう。リストdpを以下のように定める。\ndp[i][j]:jのi分割の総数\nここでjのi分割の個数は、j-iのi分割にそれぞれ1を足したパターン、及びjのi-1分割に1を追加したパターンとみることができるので、以下のように表せられる。\n$$ dp[i][j] = dp[i][j-1] + dp[i-1][j] $$ 例として、n,m≦10の場合でどうなるかを見てみよう。\nn=10 m=10 M=(10**9)+7 dp=[[0 for _ in range(n+1)] for _ in range(m+1)] dp[0][0]=1 print(dp[0]) for i in range(1,m+1): for j in range(n+1): if(j-i\u0026gt;=0): dp[i][j]=(dp[i-1][j]+dp[i][j-1])%M else: dp[i][j]=dp[i-1][j] print(dp[i]) 実行結果\n[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] [1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] [1, 1, 2, 5, 9, 14, 20, 27, 35, 44, 54] [1, 1, 2, 5, 14, 28, 48, 75, 110, 154, 208] [1, 1, 2, 5, 14, 42, 90, 165, 275, 429, 637] [1, 1, 2, 5, 14, 42, 132, 297, 572, 1001, 1638] [1, 1, 2, 5, 14, 42, 132, 429, 1001, 2002, 3640] [1, 1, 2, 5, 14, 42, 132, 429, 1430, 3432, 7072] [1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 11934] [1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796]   重複組み合わせ n種類の品物があり、i番目の品物はai個あります。異なる種類の品物同士は区別できますが、同じ種類の品物同士は区別できません。 これらの品物の中からm個選ぶ組み合わせの総数を求め、Mで割った余りを答えなさい。 (制約) 1≦n≦1000 1≦m≦1000 1≦ai≦1000 2≦M≦10000  高校数学Aでも出てきた重複組み合わせの問題である。これも動的計画法を適用して考えてみよう。リストdpを以下のように定めてみる。\ndp[i][j]:i番目までの品物からj個選ぶ組み合わせの総数\ni番目までの品物からj個選ぶためには、i-1番目までの品物からj-k個選んで、i番目の品物をk個加えれば良いので、以下の漸化式が成り立つ。\n$$ \\tag{1} dp[i][j] = \\sum_{k=0}^{ min(j,a_{i-1}) } dp[i-1][j-k] $$ ここで、\n$$ \\tag{2} \\begin{aligned} \u0026\\sum_{k=0}^{ min(j,a_{i-1}) } dp[i-1][j-k] \\\\ \u0026= \\sum_{k=0}^{ min(j,a_{i-1}) } dp[i-1][j-1-k] + dp[i-1][j] - dp[i-1][j-1-a_{i-1}] \\end{aligned} $$ となるので、式(1)から式(2)は\n$$ \\tag{3} dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-1][j-1-a_{i-1}] $$ と表される。\nコード例は以下の通り。\nn=3 m=3 a=[1,2,3] M=(10**9)+7 dp=[[0 for _ in range(m+1)] for _ in range(n+1)] for i in range(n+1): # 1個も選ばない方法は1通り dp[i][0]=1 for i in range(1,n+1): for j in range(1,m+1): if(j-1-a[i-1]\u0026gt;=0): dp[i][j]=(dp[i][j-1]+dp[i-1][j]-dp[i-1][j-1-a[i-1]])%M else: dp[i][j]=(dp[i][j-1]+dp[i-1][j])%M print(dp[n][m]) 実行結果\n6  "},{"idx":132,"href":"/docs/programming/machine_learning/steepest_descent_method/","title":"勾配法(最急降下法)","content":" 勾配法(最急降下法) 前述の平均二乗誤差で最も誤差が小さくなるw0,w1を正確に求めるにはどうすればよいのか？\nその一例として、ここでは勾配法という方法についてを述べる。\n勾配法とは曲面(2変数関数のグラフ)において、最初にある座標を定めて曲面の傾きを求め、そこから傾きの方向(=曲面の座標が低くなる方向)へ座標を移していく、という動作を繰り返し、最終的に傾き0の座標にたどり着くことで曲面が最も小さくなる座標を求めるという方法である。\n前述の平均二乗誤差Jにおいて、この勾配法を利用し最もJが小さくなるw0,w1の組み合わせを求めることを考える。\n平均二乗誤差Jの(w0,w1)での傾きは以下のように表される。\n∇ J =     \u0026part;J \u0026part;w0       \u0026part;J \u0026part;w1      =     2 N   \u0026Sum;  n = 0  N-1  (  y n  -  t n  )  x n       2 N   \u0026Sum;  n = 0  N-1  (  y n  -  t n  )      この値はそれぞれJのw0,w1に関する傾きを示している。\nこれを利用し、w0,w1の座標を移動させることで、傾きが0かつJの値が低くなる方向へと近づけていく。\nw = [w0,w1] とし、t回移動させた後のwをw(t)とすると、以下の漸化式が成り立つ。\n w ( t + 1 ) = w ( t ) = α ∇ J      w ( t )    ここでαは学習率と呼ばれるパラメータで、1回の移動でwをどれだけ移動させるかの度合を示す。\nw0,w1それぞれで表すと以下のようになる。\n  w 0  ( t + 1 ) =  w 0  ( t ) - α  \u0026part;J \u0026part;w0        w 0  ( t ) ,  w 1  ( t )      w 1  ( t + 1 ) =  w 1  ( t ) - α  \u0026part;J \u0026part;w1        w 0  ( t ) ,  w 1  ( t )    それではこの式を利用するために、この式に出てくるJをw0,w1で偏微分した値を求めてみよう。\nまずJは前述の平均二乗誤差の定義から以下のような式である。\n J =  1 N   \u0026Sum;  n = 0  N-1    (  y n  -  t n  )  2   ここで   y n  =  w 0  x +  w 1   より\n J =  1 N   \u0026Sum;  n = 0  N-1    (  w 0   x n  +  w 1  -  t n  )  2   これをw0,w1でそれぞれ偏微分すると\n  \u0026part;J \u0026part;w0  =  2 N   \u0026Sum;  n = 0  N-1  (  w 0   x n  +  w 1  -  t n  )  x n  =  2 N   \u0026Sum;  n = 0  N-1  (  y n  -  t n  )  x n     \u0026part;J \u0026part;w1  =  2 N   \u0026Sum;  n = 0  N-1  (  w 0   x n  +  w 1  -  t n  ) =  2 N   \u0026Sum;  n = 0  N-1  (  y n  -  t n  )  になる。これより、上式は\n  w 0  ( t + 1 ) =  w 0  ( t ) - α  2 N   \u0026Sum;  n = 0  N-1  (  y n  -  t n  )  x n     w 1  ( t + 1 ) =  w 1  ( t ) - α  2 N   \u0026Sum;  n = 0  N-1  (  y n  -  t n  )  x n   となる。これを利用して求めてみよう。\nコード例を以下に記載する。\nまずは平均二乗誤差Jのw0,1における勾配を求める関数をd_mseとおくと以下のようになる。(w,x,tを入力とする)\nimport numpy as np def d_mse(w,x,t): y = w[0] * x + w[1] d_w0 = 2 * np.mean((y-t)*x) d_w1 = 2 * np.mean(y-t) return d_w0,d_w1 試しに、w=[10,10]での平均二乗誤差を算出してみる。データは前章で使ったデータを利用する。\nimport numpy as np #入力値  x = np.array([167.9,164.3,171.6,172.7,162.8,170.2,172.3,163.8,168.8,167.2,172.3,166.4,173.1,176.9,178.4,167.1,177.4,173.7,172.0,174.1]) #実測値  t = np.array([58.0,58.2,60.1,65.2,55.0,60.9,61.9,56.4,62.9,57.0,64.9,55.9,68.0,67.9,69.1,60.8,65.6,66.1,59.9,69.5]) #x,tをnpyファイルに保存 np.save(\u0026#39;x.npy\u0026#39;,x) np.save(\u0026#39;t.npy\u0026#39;,t) def d_mse(w,x,t): # 略 d_w = d_mse([10,10],x,t) print(d_w) 実行結果\n(564976.373, 3308.6699999999996)  w=[10,10]ではw0方向への勾配が大きいことがわかる。\nではこのJの勾配を算出する関数d_mseを利用した勾配法を行う関数steepest_descent_method(x,t)を実装してみよう。 wは先ほどの[10,10]から始めるものとし、学習率αは今回は0.000034として行う。\nimport numpy as np def steepest_descent_method(x,t,a,n): w=[10,10] #wの初期値 alpha=a #学習率 N=n #繰り返し回数 min_dJ=0.1 #勾配法をやめる勾配の絶対値の閾値 w_i=np.zeros([N,2]) #w_i[j]にはj回の勾配法で算出したwの値が入る w_i[0,:]=w #w_iの最初の1行をwにする for i in range(1,N): dJ=d_mse(w_i[i-1],x,t) w_i[i,0]=w_i[i-1,0]-alpha*dJ[0] #w0(t+1)=w0(t)-α*∂J/∂w0 w_i[i,1]=w_i[i-1,1]-alpha*dJ[1] #w1(t+1)=w1(t)-α*∂J/∂w1 if( max(np.absolute(dJ)) \u0026lt; min_dJ): break w0=w_i[i,0] w1=w_i[i,1] w_i=w_i[:i,:] return w0,w1,dJ,w_i これを利用し、平均二乗誤差Jの最小値を勾配法を用いて求めて見る。\nimport numpy as np def d_mse(w,x,t): #(略) def steepest_descent_method(x,t,a,n): #(略) #入力値 x = np.load(\u0026#39;x.npy\u0026#39;) #実測値 t = np.load(\u0026#39;t.npy\u0026#39;) w0,w1,dJ,w_history = steepest_descent_method(x,t,0.000034,10000000) print(\u0026#34;繰り返し回数:\u0026#34;+str(w_history.shape[0])) print(\u0026#34;w0:{0:.9f} ,w1:{1:.9f}\u0026#34;.format(w0,w1)) print(\u0026#34;dJ:\u0026#34;+str(dJ)) 実行結果\n繰り返し回数:6800910 w0:0.464910324 ,w1:-17.121946810 dJ:(-0.0005856056965058088, 0.09999999786601492)  となるように、一回ずつシミュレーションを行っていくことで、より最適な値を求めることが可能となる。\nしかし、実は勾配法のようなシミュレーションをせずとも、式の計算だけで最適なw0,w1が求められてしまうパターンもある。\nそれについては次章で解説する。\n"},{"idx":133,"href":"/docs/programming/math/identity/","title":"単位行列","content":" 単位行列 単位行列を生成する方法を述べる。\nPython  単位行列を算出したいときは、numpyモジュールにある関数identityを使用する。\nnumpy.identity(n)\n上記の式により、n×nの単位行列が生成される。\n実行例を以下に示す。\n\u0026gt;\u0026gt;\u0026gt; import numpy as np \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #2×2の単位行列 \u0026gt;\u0026gt;\u0026gt; i = np.identity(2) \u0026gt;\u0026gt;\u0026gt; print(i) [[1. 0.] [0. 1.]] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #5×5の単位行列 \u0026gt;\u0026gt;\u0026gt; i = np.identity(5) \u0026gt;\u0026gt;\u0026gt; print(i) [[1. 0. 0. 0. 0.] [0. 1. 0. 0. 0.] [0. 0. 1. 0. 0.] [0. 0. 0. 1. 0.] [0. 0. 0. 0. 1.]] \u0026gt;\u0026gt;\u0026gt;    "},{"idx":134,"href":"/docs/programming/class_func/variablelength_arg/","title":"可変長引数の関数","content":" 可変長引数の関数 関数やメソッドを定義するとき、引数の数は事前に定義する必要があり、指定された数以外の数を入力することは普通はできない。\nしかし、可変長引数を使うことで、関数やメソッドを任意の個数の引数で利用することができる。\nその方法を以下に示す。\nJava  Javaではメソッドに可変長引数を設定できる仕様がある。\nその仕様は以下の通り。\n 引数のデータ型の後に「\u0026hellip;」と記述する 引数の中で、可変長引数は一番最後に書く 可変長引数は１種類しか利用できない 可変長引数の値は配列としてメソッドに渡される。  使用例は以下の通り。\nclass Main{ public static String calendar(String... s){ String d = s[0]+\u0026#34;/\u0026#34;+s[1]+\u0026#34;/\u0026#34;+s[2]; return d; } public static void main(String args[]){ Main m = new Main(); System.out.println(m.calendar(\u0026#34;2020\u0026#34;,\u0026#34;7\u0026#34;,\u0026#34;19\u0026#34;)); } } 実行結果\n$ javac Main.java $ java Main 2020/7/19   Python  Pythonでは関数を定義するときに引数の頭に*を付けたリストのアンパック型にすると、その部分に入力された値はその引数(タプル)の要素として扱われることになる。アンパック型なので、引数はいくらでも入れられることになり、結果これで可変長引数が実現できることになる。\n実装例\ndef variable_args(*args,sep=\u0026#34;/\u0026#34;): print(args) print(sep.join(args)) 実行結果\n\u0026gt;\u0026gt;\u0026gt; variable_args('2020','7','18') ('2020', '7', '18') 2020/7/18 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; variable_args('2020','7') ('2020', '7') 2020/7 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; variable_args('2020') ('2020',) 2020 \u0026gt;\u0026gt;\u0026gt;    "},{"idx":135,"href":"/docs/programming/procon/inverse_mod/","title":"合同式(mod)・逆元","content":" 合同式(mod)・逆元 最近知ったのだが、今は高校数学の課程に合同式が入っているそうだ。\n自分はゆとり世代ゆえ正式には学んでない（予備校で少し出てきたことはあったが曖昧）ので、改めて学び直してみた。\n同時に、競プロに関係する事項も。\n合同式(mod) 合同式とは以下の定義。\n a,bを整数、mを自然数とした時、\n「aをmで割った余り」と「bをmで割った余り」が等しいことを以下の式で表す。\n  $$ \\tag{1} a \\equiv b \\pmod{m} $$ この式を合同式という。\n プログラムで表現するなら\na%m == b%m  である。\n合同式の定理 合同式には定理がいくつかある。\n合同式の和 整数a,b,c,d、自然数mにおいて　a≡b (mod m) ,c≡d (mod m) の時、以下の式が成立する。\n$$ \\tag{2} a+c \\equiv b+d \\pmod{m} $$ 合同式の差 同様に、整数a,b,c,d、自然数mにおいて　a≡b (mod m) ,c≡d (mod m) の時、以下の式が成立する。\n$$ \\tag{3} a-c \\equiv b-d \\pmod{m} $$ 合同式の積 同様に、整数a,b,c,d、自然数mにおいて　a≡b (mod m) ,c≡d (mod m) の時、以下の式が成立する。\n$$ \\tag{4} ac \\equiv bd \\pmod{m} $$ 以上の式より、\n$$ \\tag{5} a+c \\equiv b+c \\pmod{m} \\\\ a-c \\equiv b-c \\pmod{m} \\\\ ac \\equiv bc \\pmod{m} $$ も成立し、これらの式から、合同式は移項・乗法も可能である。\n合同式のべき乗 整数a,b、自然数mにおいて　a≡b (mod m) の時、以下の式が成立する。\n$$ \\tag{6} a^n \\equiv b^n \\pmod{m} $$ (証明) 整数a,b,c,dを、自然数mと整数p,q,r,s,t,uを用い、以下のように定義する。\n$$ a = pm + t \\\\ b = qm + t \\\\ c = rm + u \\\\ d = sm + u $$ この時、\n$$ a \\equiv b \\pmod{m} \\\\ c \\equiv d \\pmod{m} $$ であり、また\n$$ \\begin{aligned} a+c \u0026= (p+r)m + (t+u) \\\\ b+d \u0026= (q+s)m + (t+u) \\\\ a-c \u0026= (p-r)m + (t-u) \\\\ b-d \u0026= (q-s)m + (t-u) \\\\ ac \u0026= (prm + pu+tr)m + tu \\\\ bd \u0026= (qsm + qu+st)m + tu \\\\ a^n \u0026= (p^{n} m^{n-1} + {}_n \\mathrm{C} _1 p^{n-1} m^{n-2} t + \\cdots + {}_n \\mathrm{C} _{n-1} p t^{n-1})m + t^n \\\\ b^n \u0026= (q^{n} m^{n-1} + {}_n \\mathrm{C} _1 p^{n-1} m^{n-2} t + \\cdots + {}_n \\mathrm{C} _{n-1} p t^{n-1})m + t^n \\end{aligned} $$ である。これらより、\n$$ \\begin{aligned} a+c \u0026 \\equiv b+d \u0026 \\pmod{m} \\\\ a-c \u0026 \\equiv b-d \u0026 \\pmod{m} \\\\ ac \u0026 \\equiv bd \u0026 \\pmod{m} \\\\ a^n \u0026 \\equiv b^n \u0026 \\pmod{m} \\end{aligned} $$ が成立する。\n合同式の除法 整数a,b,c、 自然数mにおいて　ab≡ac (mod m) の時でかつaとmが互いに素の時、以下の式が成立する。\n$$ \\tag{7} \\begin{aligned} ab \u0026 \\equiv ac \u0026 \\pmod{m} \\\\ \\Leftrightarrow　b \u0026 \\equiv c \u0026 \\pmod{m} \\end{aligned} $$ (証明) ab≡ac (mod m)　、かつaとmが互いに素の時において\n$$ \\tag{8} \\begin{aligned} ab \u0026 \\equiv ac \u0026 \\pmod{m} \\\\ \\Leftrightarrow　ab-ac \u0026 \\equiv 0 \u0026 \\pmod{m} \\\\ \\Leftrightarrow　a(b-c) \u0026 \\equiv 0 \u0026 \\pmod{m} \\end{aligned} $$ となり、この式において、a(b-c)と0はmで割った余りが同じであり、0をmで割った余りは0なので、a(b-c)をmで割った余りも0、つまりa(b-c)はmで割り切れる(=mの倍数)ということになる。\naとmは互いに素なので、b-cがmの倍数という事になる。\nこれより、(b-c)≡0 (mod m)が成立するので、\n$$ \\tag{9} \\begin{aligned} (b-c) \u0026 \\equiv 0 \u0026 \\pmod{m} \\\\ \\Leftrightarrow　b \u0026 \\equiv c \u0026 \\pmod{m} \\end{aligned} $$ となり、aとmが互いに素でab≡ac (mod m)の時、b≡c (mod m)が成立する。\nちなみに、aとmが互いに素ではない時、(b-c)がmの倍数でない場合があるため、これは成立しない。\n 以上が、合同式についての定義及び定理の紹介である。\nこれらを踏まえ、次に逆元についてを述べる。\n逆元 modを使った方程式を解いてみることを考える。例えばa,bを整数、mを自然数とした、以下のような式があったとする。\n$$ \\tag{10} ax \\equiv b \\pmod{m} $$ この式でxを求めるにはどのようにすれば良いのだろうか。\nこの時、\n$$ \\tag{11} ay \\equiv 1 \\pmod{m} $$ となるような整数yが存在した場合、合同式の積の定理から、\n$$ \\tag{12} \\begin{aligned} x \u0026 \\equiv x \u0026 \\pmod{m} \\\\ \\Leftrightarrow 1 \\cdot x \u0026 \\equiv ay \\cdot x \u0026 \\pmod{m} \\\\ \\Leftrightarrow x \u0026 \\equiv y \\cdot ax \u0026 \\pmod{m} \\end{aligned} $$ $$ \\tag{13} \\begin{aligned} ax \u0026 \\equiv b \u0026 \\pmod{m} \\\\ \\Leftrightarrow y \\cdot ax \u0026 \\equiv y \\cdot b \u0026 \\pmod{m} \\end{aligned} $$ が成り立つ。これより、\n$$ \\tag{14} \\begin{aligned} x \u0026 \\equiv y \\cdot ax \u0026 \\pmod{m} \\\\ \u0026 \\equiv y \\cdot b \u0026 \\pmod{m} \\end{aligned} $$ と求めることができる。\nこのように、a,mに対して\n$$ \\tag{15} ay \\equiv 1 \\pmod{m} $$ となるような整数yのことを、aの逆元といい、大体はa-1と書く。\n$$ \\tag{16} a \\cdot a^{-1} \\equiv 1 \\pmod{m} $$ また、式(10)において、a,mが互いに素でない場合以下のように書き換えることもできる。\n$$ \\tag{17} \\frac{ax}{gcd(a,m)} \\equiv \\frac{b}{gcd(a,m)} \\pmod{ \\frac{m}{gcd(a,m)} } $$ ここで、gcd(a,m)はaとmの最大公約数である。\n式(14),(16),(17)より、式(10)の解は\n$$ \\tag{18} x = \\left(\\frac{a}{gcd(a,m)}\\right)^{-1} \\cdot \\frac{b}{gcd(a,m)} + k \\cdot \\frac{m}{gcd(a,m)} \\pmod{ m } $$ となる。ただしkは0 ≦ k ≦ gcd(a,m)を満たす整数である。\nフェルマーの小定理 pが素数の時、任意の整数xに対して\n$$ \\tag{19} x^p \\equiv x \\pmod{p} $$ が成り立つ。\n特にxがpで割り切れない場合(互いに素)の時は、合同式の除法より\n$$ \\tag{20} x^{p-1} \\equiv 1 \\pmod{p} $$ が成り立つ。\n式(20)より\n$$ \\tag{21} x \\cdot x^{p-2} \\equiv 1 \\pmod{p} $$ となるので、pが素数の時、整数xの逆元はxp-2であることもわかる。\n$$ \\tag{22} p = p_{1}^{e_{1}} p_{2}^{e_{2}} \\cdots p_{n}^{e_{n}} $$ と表した時、オイラー関数φ(p)を以下のように定義する。 $$ \\tag{23} \\phi(p) = p \\prod_{i=1}^n \\frac{p_{i}-1}{p_{i}} $$ 式(23)は、実はp以下のpと互いに素な自然数の個数と等しくなる。 またこの時、pと互いに素な整数xについて、以下の式も成り立つ。 $$ \\tag{24} x^{\\phi(p)} \\equiv 1 \\pmod{p} $$ -- "},{"idx":136,"href":"/docs/programming/number/increment/","title":"変数の値を1増やす・減らす（インクリメント・デクリメント）","content":" 変数の値を1増やす・減らす（インクリメント・デクリメント） Java  Javaではインクリメント・デクリメントの演算子（ ++、\u0026ndash; ）がそれぞれ用意されている。\n利用するには変数の前または後ろに付け加えて書く。\nただし、変数の前に書いた場合と後ろに書いた場合とで、計算が行われるタイミングが異なるので注意する。\nこれら演算子は他の数式と組み合わせて記述することができるが、変数の前に置いた場合は先にインクリメント・デクリメント計算が行われてから全体の計算式を実行し、後に置いた場合は全体の計算式が実行されてからインクリメント・デクリメント計算が行われる。\n実行例を以下に示す。\nimport java.util.Map; import java.util.HashMap; class Main{ public static void main(String args[]){ int a = 0; //aをインクリメント(1増やす)。a-\u0026gt;1  a++; System.out.println(\u0026#34;a:\u0026#34;+ a); //aをデクリメント(1減らす)。a-\u0026gt;0  a--; System.out.println(\u0026#34;a:\u0026#34;+ a); //aをインクリメントしてから全体の計算式実行（aに1足してからprintln）  System.out.println(\u0026#34;a:\u0026#34;+ ++a); //全体の計算式実行してからaをインクリメント（printlnしてからaに1を足す）  System.out.println(\u0026#34;a:\u0026#34;+ a++); //a表示（↑のprintlnの後にaがインクリメントされているので、aは2）  System.out.println(\u0026#34;a:\u0026#34;+ a); } } 実行結果\n\u0026gt; java Main a:1 a:0 a:1 a:1 a:2  変数のインクリメント・デクリメントを行うタイミングに注意して設定する事。\n Python  PythonではJava等のようなインクリメント・デクリメント用の演算子は存在しない。\nそのため、インクリメントは(変数) += 1、デクリメントは (変数) -= 1 という形で行う。\n\u0026gt;\u0026gt;\u0026gt; a = 0 \u0026gt;\u0026gt;\u0026gt; a 0 \u0026gt;\u0026gt;\u0026gt; a += 1 \u0026gt;\u0026gt;\u0026gt; a 1 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a -= 1 \u0026gt;\u0026gt;\u0026gt; a 0 \u0026gt;\u0026gt;\u0026gt;  Javascript  Javascriptにもインクリメント・デクリメント演算子が（ ++、\u0026ndash; ）がそれぞれ用意されている。\n利用法はJavaと同じ。\n(変数)++; (変数)--;    "},{"idx":137,"href":"/docs/programming/other/var/","title":"変数を宣言する","content":" 変数を宣言する 変数を宣言する方法についてを述べる。\nJava  Javaでの変数の宣言は以下の通り。\n(データ型) (変数名); (変数名) = (値); // または (データ型) (変数名) = (値);  Javaは静的型付け言語(コンパイルなどの実行前の段階で、変数の型を決定する言語)のため、変数の宣言時に設定できる値の型を指定してやる必要がある。\nそのため、変数には指定されたデータ型の値しか格納することはできない。(継承等の場合を除く)\n例\nint a = 3; int b; b = 2;  Python  Pythonでの変数の宣言方法は以下の通り。\n(変数名) = (値)  Pythonは動的型付け言語のため、変数の型は宣言する必要はない。一つの変数にどのような型の値も入れられる。\n例\n\u0026gt;\u0026gt;\u0026gt; a=1 \u0026gt;\u0026gt;\u0026gt; a 1 \u0026gt;\u0026gt;\u0026gt; a=\u0026#39;1\u0026#39; \u0026gt;\u0026gt;\u0026gt; a \u0026#39;1\u0026#39; \u0026gt;\u0026gt;\u0026gt;   Swift  Swiftではvarキーワードを用いて以下の様に表現する。\nvar (変数名):(型名)  Swiftは静的型付け言語(コンパイルなどの実行前の段階で、変数の型を決定する言語)のため、記載時の段階で変数に入れられる型を決める必要がある。\n例\nvar a: Int a = 10  Javascript  Javascriptでもvarキーワードを用いて変数を宣言する。\n記法は以下のとおり。\nvar (変数名)  Javascriptはスクリプト言語のため、型は宣言しなくても良い。\n例\nvar a a = 10    "},{"idx":138,"href":"/docs/programming/file_io/import/","title":"外部ファイルのインポート","content":" 外部ファイルのインポート プログラムの中で、別のプログラムにある変数や関数を利用したい場合もある。その時はファイルをインポートしてくるのが手っ取り早いことが多い。その方法を示す。\nJava  Javaではimport文があり、これを利用することで他のプログラムを利用することができる。\n利用するには、importの後に利用したいクラス名をパッケージ名を含めて記載する。\nただし、自分と同じパッケージに属している他クラスはimport文無しでも利用できるので、import文は主に外部パッケージにあるクラスに対し利用する。\n前述のリストやMapの所では、これらのクラスを利用するためにListクラスやMapクラスをimportしていた。これもimportを利用している例になる。\n指定したパッケージ以下のクラスを全てインポートしたい時は、「*」を利用することで指定したパッケージに属する全てのクラスを利用できる。\nしかし、どのクラスを利用しているかを判別するために、大体は「*」は使わずクラスを明示してインポートする。\n例1(クラスを指定してインポートしたい時。大体はこっちを使用)\nimport java.util.ArrayList; import java.util.List; import java.util.Map; import java.util.HashMap; class Main{ public static void main(String args[]){ List\u0026lt;Integer\u0026gt; l = new ArrayList\u0026lt;Integer\u0026gt;(); l.add(1); l.add(3); l.add(1,100); for(int i=0;i\u0026lt;l.size();i++){ System.out.println(l.get(i)); } Map\u0026lt;String,String\u0026gt; m = new HashMap\u0026lt;\u0026gt;(); m.put(\u0026#34;key\u0026#34;,\u0026#34;value\u0026#34;); m.put(\u0026#34;key2\u0026#34;,\u0026#34;value\u0026#34;); m.put(\u0026#34;key\u0026#34;,\u0026#34;value3\u0026#34;); System.out.println(m); } } 例2（「*」を指定してインポートしたい時）\nimport java.util.*; class Main{ public static void main(String args[]){ List\u0026lt;Integer\u0026gt; l = new ArrayList\u0026lt;Integer\u0026gt;(); l.add(1); l.add(3); l.add(1,100); for(int i=0;i\u0026lt;l.size();i++){ System.out.println(l.get(i)); } Map\u0026lt;String,String\u0026gt; m = new HashMap\u0026lt;\u0026gt;(); m.put(\u0026#34;key\u0026#34;,\u0026#34;value\u0026#34;); m.put(\u0026#34;key2\u0026#34;,\u0026#34;value\u0026#34;); m.put(\u0026#34;key\u0026#34;,\u0026#34;value3\u0026#34;); System.out.println(m); } }  Python  Pythonにもimport文があり、これを利用することで他のプログラム(モジュール)を利用することができる。\nimport (pythonファイル(モジュール)名)\nこれにより、指定したモジュールがインポートされ、利用できるようになる。利用するには、このモジュール名を使う。\nまた、別モジュールが持つ変数や関数のみをインポートしたい時は以下のような構文を利用する。\nfrom (モジュール名) import (変数、関数名)\n実行例を以下に示す。\n$ ls add.py $ cat add.py #add.py。同じディレクトリに作成しておく a=1 b=2 c=3 d=4 def adder(a,b): return a+b $ python Python 3.7.3 (v3.7.3:ef4ec6ed12, Mar 25 2019, 22:22:05) [MSC v.1916 64 bit (AMD64)] on win32 Type \u0026#34;help\u0026#34;, \u0026#34;copyright\u0026#34;, \u0026#34;credits\u0026#34; or \u0026#34;license\u0026#34; for more information. \u0026gt;\u0026gt;\u0026gt; #add.pyをインポート \u0026gt;\u0026gt;\u0026gt; import add \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #addのa \u0026gt;\u0026gt;\u0026gt; add.a 1 \u0026gt;\u0026gt;\u0026gt; #addのb \u0026gt;\u0026gt;\u0026gt; add.b 2 \u0026gt;\u0026gt;\u0026gt; #addのadder \u0026gt;\u0026gt;\u0026gt; add.adder(1,2) 3 \u0026gt;\u0026gt;\u0026gt; add.adder(2,3) 5 \u0026gt;\u0026gt;\u0026gt; quit() $ $ python Python 3.7.3 (v3.7.3:ef4ec6ed12, Mar 25 2019, 22:22:05) [MSC v.1916 64 bit (AMD64)] on win32 Type \u0026#34;help\u0026#34;, \u0026#34;copyright\u0026#34;, \u0026#34;credits\u0026#34; or \u0026#34;license\u0026#34; for more information. \u0026gt;\u0026gt;\u0026gt; #add.pyのaだけインポート \u0026gt;\u0026gt;\u0026gt; from add import a \u0026gt;\u0026gt;\u0026gt; a 1 \u0026gt;\u0026gt;\u0026gt; #addはインポートしてないので以下はエラー \u0026gt;\u0026gt;\u0026gt; add.a Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; NameError: name \u0026#39;add\u0026#39; is not defined \u0026gt;\u0026gt;\u0026gt; #bもインポートしてないのでエラー \u0026gt;\u0026gt;\u0026gt; b Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; NameError: name \u0026#39;b\u0026#39; is not defined \u0026gt;\u0026gt;\u0026gt;   "},{"idx":139,"href":"/docs/programming/list/multisortlist/","title":"多次元リスト(配列)である列をキーにしてソートする","content":" 多次元リスト(配列)である列をキーにしてソートする リストの中に更にリストが入っているようなリストをソートした時どうなるか？ 各要素(リスト)の0番目の項、1番目の\u0026hellip;でソートしたいということは無いだろうか？ ここではその方法についてを示す。\nJava  Javaではリストのソートの記事で述べたCollections.sort()メソッドを用いる。\n違う点は、sort()メソッドにソートしたいリストだけでなく、リストをどのように順序付けるかを定義するComparatorを定義させる。\npublic static \u0026lt;T\u0026gt; void sort(List\u0026lt;T\u0026gt; list,Comparator\u0026lt;? super T\u0026gt; c)\n例えば、数値のリストの1番目の要素でソートさせたい時は、Comparatorを以下のようにする。\n(x,y) -\u0026gt; Integer.compare(x.get(1),y.get(1))\nこの例だと各要素(リスト)の1番目が降順になる用にソートされる。\n使用例を以下に示す。\nimport java.util.Collections; import java.util.ArrayList; import java.util.List; class Main{ public static void main(String args[]){ List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; l = new ArrayList\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt;(); for(int i=0;i\u0026lt;4;i++){ List\u0026lt;Integer\u0026gt; m = new ArrayList\u0026lt;\u0026gt;(); m.add(i); m.add(i*-1); l.add(m); } System.out.println(\u0026#34;before sort:\u0026#34; + l); Collections.sort(l,(x,y)-\u0026gt;Integer.compare(x.get(1), y.get(1))); System.out.println(\u0026#34;after sort:\u0026#34; + l); } } 実行結果\n\u0026gt; java Main before sort:[[0, 0], [1, -1], [2, -2], [3, -3]] after sort:[[3, -3], [2, -2], [1, -1], [0, 0]]   Python  Pythonではリストのsort()関数に、引数keyを指定する。 keyには1引数関数を指定し、各要素(リスト)の比較に用いたいインデックスの項を返すような関数を指定する 例として、リストの1番目の要素でソートさせたい時は以下のようにする。\nリスト.sort(key=lambda x: x[1])\n使用例を以下に示す。\n\u0026gt;\u0026gt;\u0026gt; a=[[1,-1],[2,2],[3,-3],[4,4],[5,-5]] \u0026gt;\u0026gt;\u0026gt; a [[1, -1], [2, 2], [3, -3], [4, 4], [5, -5]] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a.sort(key=lambda x:x[1]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a [[5, -5], [3, -3], [1, -1], [2, 2], [4, 4]] \u0026gt;\u0026gt;\u0026gt;#リストの各要素(リスト)の1番目の要素でソートされる   "},{"idx":140,"href":"/docs/programming/list/multi_array/","title":"多次元配列","content":" 多次元配列 多次元配列とは、配列の中に同じ長さの配列を複数含ませたデータ構造のことである。\nJava  Javaにおいて、例として二次元配列を設定するには以下の形式で宣言する。\nデータ型[][] 配列名 = new データ型[要素数][要素数];  配列の次元数を増やしたい場合は、かっこ[]の数をその数になるように増やして設定する。\n配列への値の代入及び取得は、同様にインデックスを指定して行う。ただし、次元の数に注意する。\nここでは、使用例を以下に記載する。\nclass Main{ public static void main(String args[]){ int[][] table = new int[3][4]; for(int i=0;i\u0026lt;table.length;i++){ for(int j=0;j\u0026lt;table[i].length;j++){ table[i][j] = i+j; System.out.print(table[i][j]+\u0026#34; \u0026#34;); } System.out.println(); } } } 実行結果\n$ java Main 0 1 2 3 1 2 3 4 2 3 4 5   Javascript  Javascriptでは以下の形式で宣言する。なお、JavascriptではJavaとは違い、配列内に入る配列の長さは全て等しくなくても良い。また、宣言時に初期値も入力できる。\nvar 配列名 = [[]]  配列への値の代入及び取得は、Javaと同じようにインデックスを指定して行えば良い。ただし、こちらも次元には注意する。\n  "},{"idx":141,"href":"/docs/programming/other/constant/","title":"定数","content":" 定数 変数は値を記憶するための入れ物であり、基本、何度でも値を代入することが可能である。\nこれに対し定数とは、値の入れ物という点では変数と同じだが、値を一度しか代入できず、代入後は別の値を再代入することはできない物のことを言う。\nここでは、各言語における定数の宣言方法についてを述べる。\nJava  Javaで定数を宣言するには、宣言時にデータ型の前にfinal修飾子をつける。\nfinal データ型 定数名 = 初期値;  定数として宣言すると、初期化以降は値を代入し直すことはできない。\n例\nfinal int N = 50;  Python  Pythonには定数という仕様は存在しない。  Swift  Swiftではletキーワードを用いて定数を宣言する。\n宣言時に値を代入することも可能。\nlet (定数名): (型名) = (値)  例\nlet a: Int = 123   "},{"idx":142,"href":"/docs/programming/number/ceil/","title":"小数点以下切り上げ","content":" 小数点以下切り上げ 小数点以下切り上げする方法についてを示す。\nJava  JavaではMathクラスにあるメソッドceil()を利用することで小数点以下切り上げを行える。\npublic static double ceil(double d)\nこのメソッドは引数に入力した数値以上で最も大きい整数を返す。戻り値はdouble型。\nimport java.lang.Math; class Main{ public static void main(String args[]){ double a = 10.1; double b = 10.0; double c = 9.9; System.out.println(Math.ceil(a)); System.out.println(Math.ceil(b)); System.out.println(Math.ceil(c)); } } 実行結果\n\u0026gt; java Main 11.0 10.0 10.0   Python  主に方法は二つある。\npythonにもmathモジュールにceil()関数がある。それを利用すると小数点以下切り上げが行える。\n\u0026gt;\u0026gt;\u0026gt; import math \u0026gt;\u0026gt;\u0026gt; a=10.1 \u0026gt;\u0026gt;\u0026gt; b=10.0 \u0026gt;\u0026gt;\u0026gt; c=9.9 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; math.ceil(a) 11 \u0026gt;\u0026gt;\u0026gt; math.ceil(b) 10 \u0026gt;\u0026gt;\u0026gt; math.ceil(c) 10 \u0026gt;\u0026gt;\u0026gt; また、もう一つの方法として、割り算の結果を切り上げしたい時は\n以下の計算式により結果を切り上げることができる。\n(a÷bの結果を切り上げたい時)\n- (-a // b)  実行例を以下に示す。\n\u0026gt;\u0026gt;\u0026gt; a=5 \u0026gt;\u0026gt;\u0026gt; b=2 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a/b 2.5 \u0026gt;\u0026gt;\u0026gt; -(-a//b) 3 \u0026gt;\u0026gt;\u0026gt;   "},{"idx":143,"href":"/docs/programming/number/floor/","title":"小数点以下切り捨て","content":" 小数点以下切り捨て 小数点以下切り捨てする方法についてを示す。\nJava  JavaではMathクラスにあるメソッドfloor()を利用することで小数点以下切り捨てを行える。 public static double floor(double d) このメソッドは引数に入力した数値以下で最も大きい整数を返す。戻り値はdouble型。\nimport java.lang.Math; class Main{ public static void main(String args[]){ double a = 10.1; double b = 10.0; double c = 9.9; System.out.println(Math.floor(a)); System.out.println(Math.floor(b)); System.out.println(Math.floor(c)); } } 実行結果\n\u0026gt; java Main 10.0 10.0 9.0   Python  主に方法は二つある。\npythonにもmathモジュールにfloor()関数がある。それを利用すると小数点以下切り捨てが行える。\n\u0026gt;\u0026gt;\u0026gt; import math \u0026gt;\u0026gt;\u0026gt; a=10.1 \u0026gt;\u0026gt;\u0026gt; b=10.0 \u0026gt;\u0026gt;\u0026gt; c=9.9 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; math.floor(a) 10 \u0026gt;\u0026gt;\u0026gt; math.floor(b) 10 \u0026gt;\u0026gt;\u0026gt; math.floor(c) 9 \u0026gt;\u0026gt;\u0026gt;  また、pythonには割り算の結果を丸める演算子 // があるので、これを使って１で割っても切り捨てが行える。\n(先ほどの続き)\n\u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a//1 10.0 \u0026gt;\u0026gt;\u0026gt; b//1 10.0 \u0026gt;\u0026gt;\u0026gt; c//1 9.0 \u0026gt;\u0026gt;\u0026gt;    "},{"idx":144,"href":"/docs/programming/number/log10/","title":"常用対数(底10)","content":" 常用対数(底10) 常用対数を算出する方法についてを示す。\nJava  Javaではjava.lang.Mathクラス内にあるlog10()メソッドがこの役割を果たす。\n利用するにはjava.lang.Mathクラスをインポートする。\npublic static double log10(double a)\nimport java.lang.Math; class Main{ public static void main(String args[]){ int a = 100; int b = 500; System.out.println(Math.log10(a)); System.out.println(Math.log10(b)); } } 実行結果\n\u0026gt; java Main 2.0 2.6989700043360187   Python  pythonで常用対数を算出するにはmathモジュールにある関数 log10() 関数を使用する。\n使用するにはmathモジュールをインポートする。\n\u0026gt;\u0026gt;\u0026gt; import math \u0026gt;\u0026gt;\u0026gt; a = 100 \u0026gt;\u0026gt;\u0026gt; b = 500 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(math.log10(a)) 2.0 \u0026gt;\u0026gt;\u0026gt; print(math.log10(b)) 2.6989700043360187 \u0026gt;\u0026gt;\u0026gt;   "},{"idx":145,"href":"/docs/programming/machine_learning/mse/","title":"平均二乗誤差","content":" 平均二乗誤差 前述の直線モデルにて、データに応じた最適なw0,w1を決めれば最適な関係式が得られると書いたが、 どのようにして最適なw0,w1を求めれば良いのか？\n関係式が最適になるようにするには、入力値に対する実際の結果と関係式による出力結果との差（誤差）が小さくなるようにすればよい。\n前述に倣い、入力をxi、実際の結果をti、関係式による出力結果をyi (= w0 xi + w1 )(i = 1,2,・・・,n) とすると、それぞれの誤差は\n |  y i  -  t i  |  となる。\nこのままやってもよいのだが、計算の簡略化1のために、この誤差の2乗をとり、さらに全てのiにおける平均を取ると以下のような値になる。\n 1 N   \u0026Sum; i=0 N    (  y i  -  t i  )  2   この値を平均二乗誤差(mean square error)といい、この値がなるべく小さくなるようなw0,w1を求めることを考える。\n以下、w,x,tを入力とし、平均二乗誤差を算出するコードを記載する。\nimport numpy as np def mse(w,x,t): y = w[0]*x + w[1] # 理論値 mse = np.mean( (y - t)**2 ) # 平均二乗誤差を算出 return mse  この関数mseにおいて、求めたいのは出力mseが最も小さくなるようなw[0],w[1]の組み合わせである。\nそのため、指定したw0,w1の範囲でmseを算出し、mseをw0,w1のグラフとして可視化させ、どこで一番小さくなるかを確認してみよう。\nとりあえず、w0,w1を-30~30の範囲で絞り、mseを算出してみる。\n#入力値 x = np.array([167.9,164.3,171.6,172.7,162.8,170.2,172.3,163.8,168.8,167.2,172.3,166.4,173.1,176.9,178.4,167.1,177.4,173.7,172.0,174.1]) #実測値 t = np.array([58.0,58.2,60.1,65.2,55.0,60.9,61.9,56.4,62.9,57.0,64.9,55.9,68.0,67.9,69.1,60.8,65.6,66.1,59.9,69.5]) #w0,w1を-30~30の組み合わせでそれぞれ指定してmse算出 w0 = np.linspace(-30,30,100) w1 = np.linspace(-30,30,100) #平均二乗誤差J,全てのw0,w1の組み合わせで算出 J = np.zeros((len(w0),len(w1))) for i0 in range(100): for i1 in range(100): J[i1,i0]=mse((w0[i0],w1[i1]),x,t) 次に、算出したmseをグラフ(3次元と等高線)で可視化させる。\nfrom mpl_toolkits.mplot3d import Axes3D import matplotlib.pyplot as plt #グラフの表示サイズ plt.figure(figsize=(9,4)) #２グラフの間隔を調整 plt.subplots_adjust(wspace=0.5) #subplot,1*2の1つ目に表示するグラフ作成 ax = plt.subplot(1,2,1,projection=\u0026#39;3d\u0026#39;) ww0,ww1 = np.meshgrid(w0,w1) ax.plot_surface(ww0,ww1,J,rstride=10,cstride=10,alpha=0.3,color=\u0026#39;blue\u0026#39;,edgecolor=\u0026#39;black\u0026#39;) ax.set_xticks([i for i in range(-50,60,10)]) ax.set_yticks([i for i in range(-50,60,10)]) ax.set_xlabel(\u0026#39;w0\u0026#39;) ax.set_ylabel(\u0026#39;w1\u0026#39;) #等高線グラフ plt.subplot(1,2,2) cont = plt.contour(ww0,ww1,J,30,colors=\u0026#39;black\u0026#39;,levels=[100000,1000000,10000000,100000000]) cont.clabel(fmt=\u0026#39;%1.0f\u0026#39;,fontsize=8) plt.xlabel(\u0026#39;w0\u0026#39;) plt.ylabel(\u0026#39;w1\u0026#39;) plt.grid(True) plt.show() 実行結果\nグラフによると、w0 = 0のあたりで平均二乗誤差Jが最低となり、最適になるように思えるが、もう少し厳密な値を調べてみたい。\nそこでこのグラフを用いてJが最小となるw0、w1の組み合わせを次章で求めてみる。\n 誤差の二乗を取る理由は諸説あるが、ほとんどはこの理由（らしい）。 [return]   "},{"idx":146,"href":"/docs/programming/machine_learning/cee_ans/","title":"平均交差エントロピー誤差の最適解の導出","content":" 平均交差エントロピー誤差の最適解の導出 前述の平均交差エントロピー誤差\n  $$ \\tag{1} - \\frac{1}{N} \\log P( { \\bf T } \\mid { \\bf X } ) = - \\frac{1}{N} \\sum_{n=0}^{N-1} ( t_{n} \\log y_{n} + (1 - t_{n}) \\log (1 - y_{n}) ) $$ が最小となる値はどのように求めるべきか。\n１次元入力２クラス分類の章で用いた入力データで、平均交差エントロピー誤差を可視化してみよう。グラフ表示したものを以下に示す(コード)\nこの図より最小値はw0=0のあたりだろうと推測できる。\n前に述べた平均二乗誤差のところでは解析解を算出することで求められたが、今回も解析解を求めることは可能だろうか。\n実は、平均交差エントロピー誤差はシグモイド関数を含んでいるため、解析解を求めることは不可能である。\nならばどのようにして求めるのが良いか？\nそこで方法として、平均二乗誤差の章でも述べた、勾配法を用いて求めることを考えてみる。\nまず、平均交差エントロピー誤差を以下のように置き換える。\n$$ \\begin{aligned} \\tag{2} E_{n} ( { \\bf w } ) \u0026= - ( t_{n} \\log y_{n} + (1 - t_{n}) \\log (1 - y_{n}) ) \\end{aligned} $$ $$ \\begin{aligned} \\tag{3} E( { \\bf w } ) \u0026= - \\frac{1}{N} \\log P( { \\bf T } \\mid { \\bf X } ) \\\\ \u0026= - \\frac{1}{N} \\sum_{n=0}^{N-1} ( t_{n} \\log y_{n} + (1 - t_{n}) \\log (1 - y_{n}) ) \\\\ \u0026= \\frac{1}{N} \\sum_{n=0}^{N-1} E_{n} ( { \\bf w } ) \\end{aligned} $$ このE(w)に勾配法を適用して、最適なwを求めることを考える。\nまず、式(3)をw0で偏微分すると以下のようになる。\n$$ \\begin{aligned} \\tag{4} \\frac{\\partial }{\\partial w_{0} }　E( { \\bf w } ) \u0026= \\frac{1}{N} \\frac{\\partial }{\\partial w_{0} } \\sum_{n=0}^{N-1} E_{n} ( { \\bf w } ) \\\\ \u0026= \\frac{1}{N} \\sum_{n=0}^{N-1} \\frac{\\partial }{\\partial w_{0} } E_{n} ( { \\bf w } ) \\end{aligned} $$ ここで\n$$ \\tag{5} y_{n} = \\sigma ( a_{n} ) = \\frac{1}{1 + \\exp(- a_{n}) } $$ $$ \\tag{6} a_{n} = w_{0} x_{n} + w_{1} $$ とおくと、合成関数の微分より\n$$ \\tag{7} \\frac{\\partial E_{n}( { \\bf w } ) }{\\partial w_{0} } = \\frac{\\partial E_{n}( { \\bf w } ) }{\\partial y_{n} } \\cdot \\frac{\\partial y_{n} }{\\partial a_{n} } \\cdot \\frac{\\partial a_{n} }{\\partial w_{0} } $$ であり、また\n$$ \\begin{aligned} \\tag{8} \\frac{\\partial E_{n}( { \\bf w } ) }{\\partial y_{n} } \u0026= \\frac{\\partial }{\\partial y_{n} } (- ( t_{n} \\log y_{n} + (1 - t_{n}) \\log (1 - y_{n}) )) \\\\ \u0026= - \\frac{ t_{n} }{ y_{n} } + \\frac{ 1 - t_{n} }{ 1 - y_{n} } \\\\ \u0026= \\frac{ y_{n} - t_{n} }{ (1-y_{n}) y_{n} } \\end{aligned} $$ $$ \\begin{aligned} \\tag{9} \\frac{\\partial y_{n} }{\\partial a_{n} } \u0026= \\frac{\\partial }{\\partial a_{n} } \\frac{1}{1 + \\exp(- a_{n}) } \\\\ \u0026= \\frac{ \\exp(- a_{n}) }{ (1 + \\exp(- a_{n}))^2 } \\\\ \u0026= \\left( 1- \\frac{ 1 }{ 1 + \\exp(- a_{n}) } \\right) \\left( \\frac{ 1 }{ 1 + \\exp(- a_{n}) } \\right) \\\\ \u0026= (1 - y_{n}) y_{n} \\end{aligned} $$ $$ \\begin{aligned} \\tag{10} \\frac{\\partial a_{n} }{\\partial w_{0} } \u0026= \\frac{\\partial }{\\partial w_{0} } ( w_{0} x_{n} + w_{1} ) \\\\ \u0026= x_{n} \\end{aligned} $$ なので、式(4)は\n$$ \\begin{aligned} \\tag{11} \\frac{\\partial }{\\partial w_{0} }　E( { \\bf w } ) \u0026= \\frac{1}{N} \\sum_{n=0}^{N-1} \\frac{\\partial }{\\partial w_{0} } E_{n} ( { \\bf w } ) \\\\ \u0026= \\frac{1}{N} \\sum_{n=0}^{N-1} \\frac{\\partial E_{n}( { \\bf w } ) }{\\partial y_{n} } \\cdot \\frac{\\partial y_{n} }{\\partial a_{n} } \\cdot \\frac{\\partial a_{n} }{\\partial w_{0} } \\\\ \u0026= \\frac{1}{N} \\sum_{n=0}^{N-1} \\frac{ y_{n} - t_{n} }{ (1-y_{n}) y_{n} } \\cdot (1 - y_{n}) y_{n} \\cdot x_{n} \\\\ \u0026= \\frac{1}{N} \\sum_{n=0}^{N-1} ( y_{n} - t_{n} ) x_{n} \\end{aligned} $$ となる。同様にして、w1で偏微分した時は\n$$ \\tag{12} \\frac{\\partial E_{n}( { \\bf w } ) }{\\partial w_{1} } = \\frac{\\partial E_{n}( { \\bf w } ) }{\\partial y_{n} } \\cdot \\frac{\\partial y_{n} }{\\partial a_{n} } \\cdot \\frac{\\partial a_{n} }{\\partial w_{1} } $$ $$ \\begin{aligned} \\tag{13} \\frac{\\partial a_{n} }{\\partial w_{1} } \u0026= \\frac{\\partial }{\\partial w_{1} } ( w_{0} x_{n} + w_{1} ) \\\\ \u0026= 1 \\\\ \\end{aligned} $$ となるから、式(12),(8),(9),(13)より\n$$ \\begin{aligned} \\tag{14} \\frac{\\partial }{\\partial w_{1} }　E( { \\bf w } ) \u0026= \\frac{1}{N} \\sum_{n=0}^{N-1} \\frac{\\partial }{\\partial w_{1} } E_{n} ( { \\bf w } ) \\\\ \u0026= \\frac{1}{N} \\sum_{n=0}^{N-1} \\frac{\\partial E_{n}( { \\bf w } ) }{\\partial y_{n} } \\cdot \\frac{\\partial y_{n} }{\\partial a_{n} } \\cdot \\frac{\\partial a_{n} }{\\partial w_{1} } \\\\ \u0026= \\frac{1}{N} \\sum_{n=0}^{N-1} \\frac{ y_{n} - t_{n} }{ (1-y_{n}) y_{n} } \\cdot (1 - y_{n}) y_{n} \\cdot 1 \\\\ \u0026= \\frac{1}{N} \\sum_{n=0}^{N-1} ( y_{n} - t_{n} ) \\end{aligned} $$ となる。この式(11),(14)から勾配法を利用して求めていく。\n式(11),(14)の値を求めるコードは以下の通り。\n(d_cee.py)\nimport numpy as np from logistic_regression import logistic_regression #平均交差エントロピー誤差の微分 def d_cee(w,x,t): y = logistic_regression(w,x) d_cee=np.zeros(2) for n in range(len(y)): #w0 d_cee[0]+=(y[n]-t[n])*x[n] #w1 d_cee[1]+=y[n]-t[n] d_cee /= len(y) return d_cee この関数を用い、勾配法で最適なwを求めていく。平均二乗誤差の章ではfor文ループで求めていたが、実はループを用いずに最適解を求める方法がある。\nそれがscipy.optimizeライブラリに含まれるminimize()関数である。\nminimize関数に勾配法で最適解を求めたい関数、変数の初期値、関数の引数、関数の導関数(微分した関数)、勾配法の種類(method=\u0026ldquo;CG\u0026rdquo;)を指定すると、勾配法を用いて最適解を導出してくれる。\nコードを以下に記載する。\n(cee_solve.py)\nfrom cross_entropy_error import ave_cross_entropy_error from scipy.optimize import minimize from d_cee import d_cee import numpy as np def cee_solve(w_init,x,t): ans = minimize(ave_cross_entropy_error,w_init,args=(x,t),jac=d_cee,method=\u0026#34;CG\u0026#34;) return ans.x w_init=[1,1] #入力値 x = np.load(\u0026#39;x.npy\u0026#39;) #実測値 t = np.load(\u0026#39;t.npy\u0026#39;) w_ans=cee_solve(w_init,x,t) print(\u0026#34;w0:{0}\u0026#34;.format(w_ans[0])) print(\u0026#34;w1:{0}\u0026#34;.format(w_ans[1])) 実行結果\n$ python cee_solve.py w0:0.7024819393205183 w1:-27.405983513314283  のように、最適なw0、w1が求められる。\nそれではこの答えをもとに、１次元入力２クラス分類の章で使用したデータ、そして本章で求めたロジスティック回帰モデルおよび決定境界を図示してみよう。\n図示した結果を以下に示す(コードはこちら)\nまた、コードの実行結果は\nw0:0.7024819393205183 w1:-27.405983513314283 決定境界：x=39.03903903903904  となる。\n以上より、ロジスティック回帰モデルを利用して求めた決定境界は39.03..[℃]と決まる。\n入力データがガウス分布に従い生成されたという過程の元だが、これが確率を用いて分類を行う方法の一例となる。\n"},{"idx":147,"href":"/docs/programming/number/root/","title":"平方根","content":" 平方根 平方根（ルート）を計算する方法についてを示す。\n方法は大まかに分けると\n ライブラリにある専用の関数/メソッドを用いる 累乗で求める（n乗根なら1/nを累乗するなど）  の２つに分けられる。\nJava  JavaではMathクラスにsqrt()というメソッドがあり、これを利用すると平方根が計算できる。\npublic static double sqrt(double a)\n利用するにはMathクラスをインポートする。\nまた、Mathクラスにある累乗を行うメソッドpow()も利用できる。\nimport java.lang.Math; class Main{ public static void main(String args[]){ double a = 2.0; double b = 3.0; double c = 4.0; double d = 5.0; System.out.println(\u0026#34;Math.sqrt\u0026#34;); System.out.println(\u0026#34;root 2:\u0026#34;+Math.sqrt(a)); System.out.println(\u0026#34;root 3:\u0026#34;+Math.sqrt(b)); System.out.println(\u0026#34;root 4:\u0026#34;+Math.sqrt(c)); System.out.println(\u0026#34;root 5:\u0026#34;+Math.sqrt(d)); System.out.println(); double n = 1.0/2.0; System.out.println(\u0026#34;Math.pow\u0026#34;); System.out.println(\u0026#34;root 2:\u0026#34;+Math.pow(a,n)); System.out.println(\u0026#34;root 3:\u0026#34;+Math.pow(b,n)); System.out.println(\u0026#34;root 4:\u0026#34;+Math.pow(c,n)); System.out.println(\u0026#34;root 5:\u0026#34;+Math.pow(d,n)); } } 実行結果\n\u0026gt; java Main Math.sqrt root 2:1.4142135623730951 root 3:1.7320508075688772 root 4:2.0 root 5:2.23606797749979 Math.pow root 2:1.4142135623730951 root 3:1.7320508075688772 root 4:2.0 root 5:2.23606797749979   Python  Pythonにはmathモジュールにsqrt()という関数があり、これを利用することで平方根が求められる。\nまたは累乗の演算子＊＊も利用できる。\n\u0026gt;\u0026gt;\u0026gt; import math \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; math.sqrt(2) 1.4142135623730951 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; math.sqrt(3) 1.7320508075688772 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; math.sqrt(4) 2.0 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; math.sqrt(5) 2.23606797749979 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; n = 1/2 \u0026gt;\u0026gt;\u0026gt; n 0.5 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; 2 ** n 1.4142135623730951 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; 3 ** n 1.7320508075688772 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; 4 ** n 2.0 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; 5 ** n 2.23606797749979 \u0026gt;\u0026gt;\u0026gt;   "},{"idx":148,"href":"/docs/programming/machine_learning/mnist/","title":"手書き文字の認識","content":" 手書き文字の認識 ここでは、実用的な問題への応用として、手書き数字をニューラルネットワークを使って認識させてみることを考えてみる。\nMNISTデータベース 手書き文字のデータは、MNISTと呼ばれるデータセットを利用する。\nMNISTデータセットは、Kerasから以下のように利用することができる。\nfrom keras.datasets import mnist # trainに60000個の訓練用データ、testに10000個のテストデータが入る (x_train,y_train),(x_test,y_test) = mnist.load_data() ここで、x_trainには60000*28*28の配列変数で、0~255の値をとるデータが入る。\nまた、y_trainには60000*1の配列変数で、画像の認識結果である0-9の値が入る。\n例として、データを一つとって図示してみよう。以下にその過程を示す。\n#最初のデータだけ図示 x0 = x_train[0] # ヒートマップにして表示 plt.figure() plt.imshow(x0,interpolation=\u0026#39;nearest\u0026#39;,vmin=0,vmax=255,cmap=\u0026#39;binary\u0026#39;) plt.show() #ちなみに認識結果（目標値）は print(\u0026#39;↑の目標値：{0}\u0026#39;.format(y_train[0])) 実行結果\n２層フィードフォワードニューラルネットワークでの学習 では、このデータをニューラルネットワークを用いて学習させてみよう。まずはデータの前処理を行う。\nMNISTでの入力データは1つにつき28*28の配列変数だったので、まずはこれを1*784の形に変形させる。\nまた、値を実数として扱うためにfloat型に変換し、255で割って0~1の範囲に値を収める。\nそして、目標データもKerasの関数を使って1-of-K符号化法で変換する。\nこれらを、テストデータに対しても行わせる。\n以上の流れをコードで実装すると、以下のようになる。(訓練データのみ)\n#行列の型を変換 x_train = x_train.reshape(60000,28*28) #float型に変換 x_train = x_train.astype(\u0026#39;float32\u0026#39;) #0~1の値に収める x_train = x_train/255 #目標データも1-of-K符号化法で表す y_train = np_utils.to_categorical(y_train,10) 次に、中間層、活性化関数を以下のように定義する。\n#ニューラルネットワークの定義 from keras.models import Sequential from keras.layers import Dense,Activation from keras.optimizers import Adam #モデルの定義 model = Sequential() #784次元を入力とする16個の中間層を定義する。活性化関数はシグモイド関数 model.add(Dense(16,input_dim=784,activation=\u0026#39;sigmoid\u0026#39;)) #10個の出力層を定義する。活性化関数はソフトマックス関数 model.add(Dense(10,activation=\u0026#39;softmax\u0026#39;)) #学習方法の設定。目的関数を交差エントロピー誤差、学習の評価として正答率を計算、アルゴリズムをAdamに設定 model.compile(loss=\u0026#39;categorical_crossentropy\u0026#39;,optimizer=Adam(),metrics=[\u0026#39;accuracy\u0026#39;]) #学習を行わせる。trainは訓練データ、全データを学習に使う回数:10、validation_dataにテストデータ。(verbose=1で進行状況表示) history=model.fit(x_train,y_train,epochs=10,batch_size=1000,verbose=1,validation_data=(x_test,y_test)) #学習の評価値を出力 score=model.evaluate(x_test,y_test,verbose=0) ここで、学習を行う(model.fit)時は交差エントロピー誤差を勾配法を用いて最小値を計算しにいくのだが、勾配法だと局所解に嵌った場合抜け出せなくなり、正しい最小値が得られないという場合がありうる。\nそこで、別の方法として、確率的勾配法という手法を用いてここでは計算を行なっている。\n確率的勾配法とは、複数個のデータセットを用いて勾配を計算しパラメータを更新する方法である。これにより、場合によっては局所解から脱出できることがある。\n確率的勾配法で用いるデータセットの個数として、コードではbatch_size=1000(1000個)と指定している。\n次に、学習させたモデルを用いてテストデータを何個か評価させてみよう。\n評価させるためのコードを以下に示す。\ny=model.predict(x_test) plt.figure(2,figsize=(12,8)) plt.gray() for i in range(12*8): plt.subplot(8,12,i+1) x=x_test[i,:] x=x.reshape(28,28) plt.pcolor(1-x) wk=y[i,:] prediction=np.argmax(wk) plt.text(22,25.5,\u0026#34;%d\u0026#34; % prediction, fontsize=12) if prediction != np.argmax(y_test[i,:]): plt.plot([0,27],[1,1],color=\u0026#39;red\u0026#39;,linewidth=5) else: plt.plot([0,27],[1,1],color=\u0026#39;yellow\u0026#39;,linewidth=5) plt.xlim(0,27) plt.ylim(27,0) plt.xticks([],\u0026#34;\u0026#34;) plt.yticks([],\u0026#34;\u0026#34;) plt.show()  実行結果\n黄線が正しく認識できたデータ、赤線が認識できなかったデータを表しているが、この結果を見ると、うまく認識されていないケースが多いように見える。\nそのため、どこか改良してみることを考えてみよう。ここでは、途中の活性化関数を別のものにさせてみる。\nReLU活性化関数 活性化関数として、シグモイド関数ではなくReLU (Rectified Linear Unit)関数を用いてみることを考えてみよう。\nReLU関数とは以下の式で表される関数である。\n  $$ \\tag{1} h(x) \\begin{cases} x \u0026 (x0) \\\\ 0 \u0026 (otherwise) \\end{cases} $$ シグモイド関数は入力値がどのように変化しても常に1に近い値を出力するので、入力の変化が出力に反映されにくくなる。\nその結果、誤差関数の偏微分が0に近い値になり、勾配法による学習が遅くなるという欠点があった。\nそのため、このようなReLU関数を用いることで、その問題を解決することが可能になる。\nでは、先程のコードで、中間層の活性化関数を\u0026rsquo;relu\u0026rsquo;に変えて実行してみよう。\n#モデルの定義 model = Sequential() #784次元を入力とする16個の中間層を定義する。活性化関数はReLU関数 model.add(Dense(16,input_dim=784,activation=\u0026#39;relu\u0026#39;)) #10個の出力層を定義する。活性化関数はソフトマックス関数 model.add(Dense(10,activation=\u0026#39;softmax\u0026#39;)) #学習方法の設定。目的関数を交差エントロピー誤差、学習の評価として正答率を計算、アルゴリズムをAdamに設定 model.compile(loss=\u0026#39;categorical_crossentropy\u0026#39;,optimizer=Adam(),metrics=[\u0026#39;accuracy\u0026#39;]) こちらで先ほどと同じようにテストデータを評価すると以下のようになる。\n少しだけではあるが精度は良くなったように見える。だが、もう少し精度を上げることはできないだろうか？\nここで少し機械学習とはそれるが、画像処理の技術を適用することを次章で考えてみる。\n"},{"idx":149,"href":"/docs/programming/list/list_in/","title":"指定した要素がリスト内にあるか調べる","content":" 指定した要素がリスト内にあるか調べる ある要素がリスト内に存在するかを調べる方法についてを示す。\nJava  JavaではListクラスにcontains()というメソッドがある。これは呼び出し元のリストに引数に指定した要素が含まれていた場合にtrue、そうでない場合falseを返すメソッドである。\nboolean contains(Object o)\n使用例を以下に示す。\nimport java.util.ArrayList; import java.util.List; class Main{ //List println  public static void listprint(String name,List\u0026lt;Integer\u0026gt; l){ System.out.print(name + \u0026#34;: \u0026#34;); for(int i=0;i\u0026lt;l.size();i++){ System.out.print(l.get(i) + \u0026#34; \u0026#34;); } System.out.println(); } public static void main(String args[]){ List\u0026lt;Integer\u0026gt; l = new ArrayList\u0026lt;Integer\u0026gt;(); l.add(1); l.add(3); l.add(100); l.add(0); listprint(\u0026#34;l\u0026#34;, l); } } 実行結果\n\u0026gt; java Main l: 1 3 100 0 true false   Python  Pythonでは in 演算子が利用でき、これにより指定した要素がリスト内に含まれているかを確認できる。\n含まれている場合はTrueを、そうでない場合はFalseを返す。\n\u0026gt;\u0026gt;\u0026gt; a=[1,9,8,7,6,5,3,2] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; 1 in a True \u0026gt;\u0026gt;\u0026gt; 10 in a False \u0026gt;\u0026gt;\u0026gt;   "},{"idx":150,"href":"/docs/programming/list/count/","title":"指定した要素がリスト内にいくつあるか調べる","content":" 指定した要素がリスト内にいくつあるか調べる 指定した要素がリスト内にいくつあるか調べる方法についてを示す。\nJava  Javaでは具体的なメソッドが(調べたところ)無いため、リストの要素を一個一個見ていって調べる。\n（他に方法があるかもしれないので、後に要調査。）\niimport java.util.ArrayList; import java.util.List; class Main{ public static void main(String args[]){ List\u0026lt;String\u0026gt; l = new ArrayList\u0026lt;\u0026gt;(); l.add(\u0026#34;a\u0026#34;); l.add(\u0026#34;b\u0026#34;); l.add(\u0026#34;c\u0026#34;); l.add(\u0026#34;d\u0026#34;); l.add(\u0026#34;a\u0026#34;); l.add(\u0026#34;a\u0026#34;); System.out.println(\u0026#34;l:\u0026#34; + l ); int count=0; for(int i=0;i\u0026lt;l.size();i++){ if(l.get(i)==\u0026#34;a\u0026#34;){ count++; } } System.out.println(\u0026#34;a:\u0026#34; + count); } } 実行結果\n\u0026gt;java Main l:[a, b, c, d, a, a] a:3   Python  Pythonではリストの関数にcount()があり、これは引数に指定した要素がリスト内にいくつあるかを返してくれる。\n\u0026gt;\u0026gt;\u0026gt; l=[\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;a\u0026#39;,\u0026#39;a\u0026#39;] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; l [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;a\u0026#39;] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; l.count(\u0026#39;a\u0026#39;) 3 \u0026gt;\u0026gt;\u0026gt;    "},{"idx":151,"href":"/docs/programming/list/indexof/","title":"指定した要素のリスト内でのインデックスを調べる","content":" 指定した要素のリスト内でのインデックスを調べる 指定した要素がリスト内でどの位置にいるかを調べる方法を示す。\nJava  JavaではListクラスにあるindexOf()というメソッドで、要素があるインデックスを取得することができる。\nint indexOf(Object o)\nなお、リスト内に指定した要素が複数入っていた場合は、一番最初にある要素のインデックスを返す。\n指定した要素がリスト内にない場合は、-1を返す。\nまた、リストで後ろの方から検索を行うlastIndexOf()というメソッドもある。\nint lastIndexOf(Object o)\nindexOfとは逆に、リスト内に指定した要素が複数入っていた場合は、一番最後にある要素のインデックスを返す。\n実行例を下記に示す。\nimport java.util.ArrayList; import java.util.List; class Main{ //List println  public static void listprint(String name,List\u0026lt;Integer\u0026gt; l){ System.out.print(name + \u0026#34;: \u0026#34;); for(int i=0;i\u0026lt;l.size();i++){ System.out.print(l.get(i) + \u0026#34; \u0026#34;); } System.out.println(); } public static void main(String args[]){ List\u0026lt;Integer\u0026gt; l = new ArrayList\u0026lt;Integer\u0026gt;(); l.add(1); l.add(3); l.add(100); l.add(0); l.add(3); listprint(\u0026#34;l\u0026#34;, l); System.out.println(\u0026#34;index of \\\u0026#39;1\\\u0026#39;: \u0026#34; + l.indexOf(1)); System.out.println(\u0026#34;index of \\\u0026#39;3\\\u0026#39;: \u0026#34; + l.indexOf(3)); System.out.println(\u0026#34;index of \\\u0026#39;5\\\u0026#39;: \u0026#34; + l.indexOf(5)); System.out.println(\u0026#34;last index of \\\u0026#39;1\\\u0026#39;: \u0026#34; + l.lastIndexOf(1)); System.out.println(\u0026#34;last index of \\\u0026#39;3\\\u0026#39;: \u0026#34; + l.lastIndexOf(3)); System.out.println(\u0026#34;last index of \\\u0026#39;5\\\u0026#39;: \u0026#34; + l.lastIndexOf(5)); } } 実行結果\n\u0026gt; java Main l: 1 3 100 0 3 index of '1': 0 index of '3': 1 index of '5': -1 last index of '1': 0 last index of '3': 4 last index of '5': -1   Python  Pythonではリストの関数にindex()というのがあり、引数に指定した要素のリスト内でのインデックスを返してくれる。\nlist.index(x[, start[, end]])\n指定した要素xがリスト内に複数ある場合は、リスト内の最初の要素のインデックスを返す。\nリストの指定した範囲内のみで調べたい場合は、引数start,endに値を設定して行うと、指定した範囲内で行える。\n指定した要素xがリスト内に無い場合ValueErrorが返される。\n\u0026gt;\u0026gt;\u0026gt; a=[1,3,100,0,3] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a.index(1) #a全体で1を探索 0 \u0026gt;\u0026gt;\u0026gt; a.index(3) #a全体で3を探索 1 \u0026gt;\u0026gt;\u0026gt; a.index(3,1) #a[1]以降で3を探索 1 \u0026gt;\u0026gt;\u0026gt; a.index(3,2) #a[2]以降で3を探索 4 \u0026gt;\u0026gt;\u0026gt; a.index(3,5) #a[5]以降で3を探索 -\u0026gt; 無いのでエラー Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; ValueError: 3 is not in list \u0026gt;\u0026gt;\u0026gt;   "},{"idx":152,"href":"/docs/programming/number/xor/","title":"排他的論理和(XOR)","content":" 排他的論理和(XOR) XORのビット演算をする方法についてを示す。\nJava  JavaではXORのビット演算子 ^ を使用する。数値型リテラルでも、boolean型でも入力可。\n(左辺) ^ (右辺)\nclass Main{ public static void main(String args[]){ boolean a = true; boolean b = false; int c = 3; //0011  int d = 5; //0101  System.out.println(a ^ a); System.out.println(a ^ b); System.out.println(b ^ b); System.out.println(c ^ c); //0000 -\u0026gt; 0  System.out.println(c ^ d); //0110 -\u0026gt; 6  System.out.println(d ^ d); //0000 -\u0026gt; 0  } } 実行結果\n\u0026gt; java Main false true false 0 6 0   Python  ビット演算に関してはpythonもjavaと同じで ^ を使用する。\n\u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a = True \u0026gt;\u0026gt;\u0026gt; b = False \u0026gt;\u0026gt;\u0026gt; c = 3 \u0026gt;\u0026gt;\u0026gt; d = 5 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(a ^ a) False \u0026gt;\u0026gt;\u0026gt; print(a ^ b) True \u0026gt;\u0026gt;\u0026gt; print(b ^ b) False \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(c ^ c) 0 \u0026gt;\u0026gt;\u0026gt; print(c ^ d) 6 \u0026gt;\u0026gt;\u0026gt; print(d ^ d) 0 \u0026gt;\u0026gt;\u0026gt;   "},{"idx":153,"href":"/docs/programming/machine_learning/supervised_learning/","title":"教師あり学習","content":" 教師あり学習 教師あり学習とは何か？\n教師あり学習とは与えられた入力とそれに対する結果のデータセットを元に、それとは別の新しい入力に対する結果を予測する手法である。\nそのためには、与えられた入力と結果から関係式を算出させることを行う。これが教師から与えられたデータを学習させると言うことに例えられて教師あり学習と言われている。\n教師あり学習には、入力から具体的な数値を算出する 回帰 と言う問題と、入力からどのグループ等に属されるかを算出する 分類 と言う問題に大きく分かれる。\n"},{"idx":154,"href":"/docs/programming/machine_learning/unsupervised_learning/","title":"教師なし学習","content":" 教師なし学習 教師なし学習について。\n教師なし学習は教師あり学習とは違い、入力データに対する答え(目標データ)が与えられず、入力データからデータの特徴などを出力する手法である。\n具体的な例としては、クラスタリング、異常検知、主成分分析などがある。\n"},{"idx":155,"href":"/docs/programming/number/abs/","title":"数値の絶対値を算出する","content":" 数値の絶対値を算出する 数値の絶対値を算出する方法についてを示す。\nJava  Javaではjava.lang.Mathクラス内にあるabs()メソッドがこの役割を果たす。\n利用するにはjava.lang.Mathクラスをインポートする。\npublic static int abs(int a)\nこの例ではint型だが、int型に限らずdouble型、float型、long型などもオーバーロードとして定義されている。\nいずれの場合も利用するには引数、返り値を格納する変数の型は一致させておく必要がある。\nimport java.lang.Math; class Main{ public static void main(String args[]){ int a = 1; int b = -1; System.out.println(Math.abs(a)); System.out.println(Math.abs(b)); } } 実行結果\n\u0026gt; java Main 1 1   Python  pythonで数値の絶対値を算出するには組み込み関数のabs関数を使用する。\n\u0026gt;\u0026gt;\u0026gt; a = 1 \u0026gt;\u0026gt;\u0026gt; b = -1 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(abs(a)) 1 \u0026gt;\u0026gt;\u0026gt; print(abs(b)) 1 \u0026gt;\u0026gt;\u0026gt;   "},{"idx":156,"href":"/docs/programming/number/zfill/","title":"数値の頭をゼロ詰して表示する","content":" 数値の頭をゼロ詰して表示する 数値の頭をゼロ詰して表示する方法についてを示す。\nJava  JavaではStringクラスにあるformat() メソッドで頭をゼロ詰めして表示することができる。\npublic static String format(String format,Object... args)\n第1引数(format)には、値をどのような形式で表示するかを指定する。\n例えば5桁でゼロ詰めしたい時は下記の値を入力する。\n %05d  %　・・・　書式文字列であることを示す 0　・・・　埋める文字。今回の場合0 5　・・・　桁数。今回の場合5桁なので5 d　・・・　出力する値の型。今回は数値なのでd    この第1引数(format)に関しては種類によって記法が定められているので、詳しくは下記の公式レファレンスを参照のこと。\nhttps://docs.oracle.com/javase/jp/8/docs/api/java/util/Formatter.html#syntax\n実行例を下記に示す。\nimport java.lang.Math; class Main{ public static void main(String args[]){ int a = 1; int b = 22; int c = 333; int d = 55555; System.out.println(String.format(\u0026#34;%05d\u0026#34;,a)); System.out.println(String.format(\u0026#34;%05d\u0026#34;,b)); System.out.println(String.format(\u0026#34;%05d\u0026#34;,c)); System.out.println(String.format(\u0026#34;%05d\u0026#34;,d)); } } 実行結果\n\u0026gt; java Main 00001 00022 00333 55555   Python  pythonで数値をゼロ詰めして表示するには文字列の組み込み関数のzfill()を利用する。\nstr.zfill(width)\nこの場合、文字strが長さwidthになるように、strの左から0を詰めていく。\n実行例を以下に示す。\n\u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a=1 \u0026gt;\u0026gt;\u0026gt; b=22 \u0026gt;\u0026gt;\u0026gt; c=333 \u0026gt;\u0026gt;\u0026gt; d=55555 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(str(a).zfill(5)) 00001 \u0026gt;\u0026gt;\u0026gt; print(str(b).zfill(5)) 00022 \u0026gt;\u0026gt;\u0026gt; print(str(c).zfill(5)) 00333 \u0026gt;\u0026gt;\u0026gt; print(str(d).zfill(5)) 55555 \u0026gt;\u0026gt;\u0026gt;   "},{"idx":157,"href":"/docs/programming/number/random/","title":"数値をランダムに取得する(乱数)","content":" 数値をランダムに取得する(乱数) なんでもいいから適当に数値を取ってきたい場合どうするか？その時は乱数というのを使う。ここではその方法についてを示す。\nJava  Javaでは主に以下の２つの方法がある。\n java.util.Randomクラスを用いる。  Random()クラスのインスタンスを生成し、Randomクラスにある多種多様なメソッドを利用する事で数値をランダムに取得することができる。\nメソッドの数は多いため、ここでは割愛する。詳しくは公式レファレンスを参照。\n java.lang.Mathクラスにあるrandomメソッドを使う。  public static double random()\nこのメソッドを用いると、0.0~1.0の範囲のdouble値をランダムに出力する。\n用途にもよるが、2.を使った方が簡単（だと思う）\nimport java.util.Random; import java.lang.Math; class Main{ public static void main(String args[]){ //Randomクラスを使って0~100から５回ランダムに取得して表示  Random random = new Random(); for(int i=0;i\u0026lt;5;i++){ System.out.println(\u0026#34;Random.nextInt[\u0026#34;+i+\u0026#34;]:\u0026#34;+random.nextInt(101)); } //Mathクラスを使って0~100から５回ランダムに取得して表示  for(int i=0;i\u0026lt;5;i++){ System.out.println(\u0026#34;Math.random[\u0026#34;+i+\u0026#34;]:\u0026#34;+(int)(Math.random()*100)); } } } 実行結果\n$ java Main Random.nextInt[0]:18 Random.nextInt[1]:63 Random.nextInt[2]:28 Random.nextInt[3]:31 Random.nextInt[4]:11 Math.random[0]:58 Math.random[1]:34 Math.random[2]:60 Math.random[3]:30 Math.random[4]:69   Python  pythonではrandomモジュールを利用することで乱数を取り扱える。\nrandomモジュールの中に乱数に関する関数が多くあるので、それぞれの説明はここでは省略する。詳しくは公式レファレンスを参照。\n実行例を以下に示す。\n\u0026gt;\u0026gt;\u0026gt; import random \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #0.0~1.0間の数値をランダムに取得 \u0026gt;\u0026gt;\u0026gt; random.random() 0.3762480735792372 \u0026gt;\u0026gt;\u0026gt; random.random() 0.0714801741824369 \u0026gt;\u0026gt;\u0026gt; random.random() 0.1025080846456623 \u0026gt;\u0026gt;\u0026gt; random.random() 0.340342947399805 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #1~100間の整数をランダムに取得 \u0026gt;\u0026gt;\u0026gt; random.randint(1,100) 55 \u0026gt;\u0026gt;\u0026gt; random.randint(1,100) 33 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; random.randint(1,100) 32 \u0026gt;\u0026gt;\u0026gt; random.randint(1,100) 84 \u0026gt;\u0026gt;\u0026gt;    "},{"idx":158,"href":"/docs/programming/number/str/","title":"数値を文字列に変換する","content":" 数値を文字列に変換する 文字列を数値にする方法があったように、逆の数値を文字列に変換する方法も存在する。\nここではその方法を示す。\nJava  Javaでは主に2つ方法がある。\n StringクラスのvalueOf()メソッドを使う\n 数値型の各ラッパークラス(Integerなど)にあるtoString()メソッドを使う\n  どちらを利用してもよい。\nclass Main{ public static void main(String args[]){ int i = 100; String s = String.valueOf(i); String t = Integer.toString(i); System.out.println(s); System.out.println(t); } } 実行結果\n\u0026gt; java Main 100 100   Python  Pythonでは値を文字列に変換する組み込み関数 str() があるので、それを利用して数値を文字列に変換する。\n\u0026gt;\u0026gt;\u0026gt; i = 100 \u0026gt;\u0026gt;\u0026gt; str(i) \u0026#39;100\u0026#39; \u0026gt;\u0026gt;\u0026gt;    "},{"idx":159,"href":"/docs/programming/machine_learning/numerical_differentiation/","title":"数値微分法","content":" 数値微分法 前述のフィードフォワードニューラルネットワークにおいて、最適な重み行列w,vの値を求めるために指標となる誤差関数を、教師あり学習の章でも利用した平均誤差エントロピー誤差を利用し、以下の式で定義する。\n  $$ \\tag{1} E( { \\bf w } ,{ \\bf v } ) = - \\frac{1}{N} \\sum_{n=0}^{N-1} \\sum_{k=0}^{K-1} t_{nk} \\log (y_{nk}) $$ tは目標値、yはニューラルネットワークモデルの出力値である。この2つの誤差が大きいほど、誤差関数の値も大きくなる。\n式(1)はw,vを入力とするが、この時どのようなw,vを入力すれば誤差関数が最も小さくなるか？を考えた時、教師あり学習のところでも出てきた勾配法を用いて考えてみる。\n勾配法の時は偏微分を計算して算出した式を利用していたが、ここでは微分の定義を利用した、近似を利用して偏微分を行なってみよう。\nまず誤差関数をwで偏微分することを考えてみる。\n関数f(x)をxで微分した値は、ある微小な値εを用いると以下のように表される。\n$$ \\tag{2} \\frac{　df(x) }{dx} = \\frac{f(x + \\epsilon )-f(x)}{ \\epsilon } $$ これにより、誤差関数E(w,v)をwで偏微分した値は以下のようになる。\n$$ \\tag{3} \\frac{　\\partial E( { \\bf w } ,{ \\bf v } ) }{ \\partial { \\bf w } } = \\frac{ E( { \\bf w } + \\epsilon ,{ \\bf v } )-E( { \\bf w } ,{ \\bf v } )}{ \\epsilon } $$ 式(3)だが、wには実際にはパラメータが複数ある。例として、wにw0,w1,w2 のパラメータがあるとすると、まずw0での偏微分は以下のようになる。\n$$ \\tag{4} \\frac{　\\partial E( { \\bf w } ,{ \\bf v } ) }{ \\partial { \\bf w } } \\Biggr| _{w_{0},w_{1},w_{2} }= \\frac{ E( ( w_{0} + \\epsilon, w_{1}, w_{2}) ,{ \\bf v } )-E( ( w_{0}, w_{1}, w_{2}) ,{ \\bf v } )}{ \\epsilon } $$ w1,w2に対しても同じことを行い、またvのパラメータ全てに対しても行う。\nつまりは、wとvのパラメータ全てに対して勾配法を行い、誤差関数を小さくする最適なパタメータの組み合わせを求めていく、というものである。\nこの手法の難点は、パラメータの数が多いと計算時間が膨大になってしまうという点である。ニューラルネットワークでは重み行列のパラメータの数が多いので、時間も長くなりがちになる。\nコードでの実装例をこちらのNotebookに記載するが、回数にもよるが時間が長くかかりやすいこともわかる。\nここで、別の方法として述べられているものを次に記載する。\n"},{"idx":160,"href":"/docs/programming/number/digits/","title":"数値（整数）の桁数を調べる","content":" 数値（整数）の桁数を調べる 整数の桁数を調べる方法については、 数値を文字列に変換してその文字列の長さを取得すればよい。\nJava  Javaでは数値を文字列に変換し、その文字列の長さを取得すればOK。\nimport java.lang.Math; class Main{ public static void main(String args[]){ int a = 10; int b = 123; int c = 76543; System.out.println(String.valueOf(a).length()); System.out.println(String.valueOf(b).length()); System.out.println(String.valueOf(c).length()); } } 実行結果\n\u0026gt; java Main 2 3 5   Python  同様にPythonでも数値を文字列に変換し、その文字列の長さを取得すればOK。\n\u0026gt;\u0026gt;\u0026gt; a=10 \u0026gt;\u0026gt;\u0026gt; b=123 \u0026gt;\u0026gt;\u0026gt; c=76543 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; len(str(a)) 2 \u0026gt;\u0026gt;\u0026gt; len(str(b)) 3 \u0026gt;\u0026gt;\u0026gt; len(str(c)) 5 \u0026gt;\u0026gt;\u0026gt;   "},{"idx":161,"href":"/docs/programming/math/math_index/","title":"数学系","content":" 数学系 数学に関する手法などをまとめる。\n都合上、現在はPythonのみ記載。\n線形代数ではnumpyというライブラリを利用する。\n 線形代数  ベクトル  要素が等間隔になるベクトル ベクトルの大きさ(ノルム)  行列  行列の型(サイズ) 零行列 要素が全て１の行列 要素がランダムの行列 行列のサイズを変更する スカラー*行列 行列積(ベクトルの内積) 転置行列 単位行列 逆行列  ndarray型のデータをファイルに保存する  関数  シグモイド関数 ソフトマックス関数 シグモイド関数とソフトマックス関数 ガウス関数 ガウス関数(2次元)  確率・統計  条件付き確率 最尤推定   "},{"idx":162,"href":"/docs/programming/string/length/","title":"文字列の長さ（文字数）を調べる","content":" 文字列の長さ（文字数）を調べる 文字列の長さ（＝文字列が何文字であるか）を取得する方法を示す。\nJava  JavaではStringクラスにlength()というメソッドがあり、これはその文字列の長さ（＝文字数）を返す。\npublic int length()\n実行例を以下に示す。\nimport java.lang.Math; class Main{ public static void main(String args[]){ String a = \u0026#34;ab\u0026#34;; String b = \u0026#34;11223344\u0026#34;; String c = \u0026#34;**************\u0026#34;; System.out.println(a.length()); System.out.println(b.length()); System.out.println(c.length()); } } 実行結果\n\u0026gt; java Main 2 8 14   Python  Pythonでは引数の文字列の長さ（＝文字数）を返す関数len()があるので、それを利用する。\n\u0026gt;\u0026gt;\u0026gt; a = \u0026#34;ab\u0026#34; \u0026gt;\u0026gt;\u0026gt; b = \u0026#34;11223344\u0026#34; \u0026gt;\u0026gt;\u0026gt; c = \u0026#34;**************\u0026#34; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; len(a) 2 \u0026gt;\u0026gt;\u0026gt; len(b) 8 \u0026gt;\u0026gt;\u0026gt; len(c) 14 \u0026gt;\u0026gt;\u0026gt;   "},{"idx":163,"href":"/docs/programming/list/string_list/","title":"文字列を１文字ずつのリストにする","content":" 文字列を１文字ずつのリストにする 文字列を1文字ずつのリストに変換する方法についてを示す。\nJava  Javaでは以下２つの手順を踏んで行う。\n 文字列を分割するString.split()を利用して文字列を１文字ずつの配列に分割する Arrays.asList()メソッドを利用して配列をリストに変換する  String.split()は引数に指定した文字列を境に元の文字列を切り分けるメソッドである。引数に空文字\u0026rdquo;\u0026ldquo;を入力したときは、文字列を１文字ずつに分割する。\nArrays.asList()は引数に指定した配列を対応するリストに変換するというものである。\nimport java.util.ArrayList; import java.util.Arrays; import java.util.List; class Main{ //List println  public static void listprint(String name,List\u0026lt;String\u0026gt; l){ System.out.print(name + \u0026#34;: \u0026#34;); for(int i=0;i\u0026lt;l.size();i++){ System.out.print(l.get(i) + \u0026#34;,\u0026#34;); } System.out.println(); } public static void main(String args[]){ String s = \u0026#34;apple banana\u0026#34;; System.out.println(s); List\u0026lt;String\u0026gt; l = Arrays.asList(s.split(\u0026#34;\u0026#34;)); listprint(\u0026#34;l\u0026#34;, l); } } 実行結果\n\u0026gt; java Main apple banana l: a,p,p,l,e, ,b,a,n,a,n,a,   Python  Pythonでは文字列をそのままlist()の引数に指定してやると、文字列を１文字ずつのリストに変換してくれる。\n使用例を以下に示す。\n\u0026gt;\u0026gt;\u0026gt; s=\u0026#34;apple banana\u0026#34; \u0026gt;\u0026gt;\u0026gt; s \u0026#39;apple banana\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; list(s) [\u0026#39;a\u0026#39;, \u0026#39;p\u0026#39;, \u0026#39;p\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39; \u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;a\u0026#39;] \u0026gt;\u0026gt;\u0026gt;   "},{"idx":164,"href":"/docs/programming/string/find/","title":"文字列中にある文字列が含まれているときにその位置を確認する","content":" 文字列中にある文字列が含まれているときにその位置を確認する 文字列中に特定の文字列が含まれていた時、その位置を確認したい場合どうするか？ ここではその方法についてを示す。\nJava  JavaではStringのメソッドであるindexOf()を利用する。\npublic int indexOf(String str)\nこのメソッドは、文字列内で指定された部分文字列が最初に出現する位置のインデックスを返す。\n文字列の途中の位置から検索したい場合は下記のメソッドを利用する。\npublic int indexOf(String str, int fromIndex)\nこのメソッドは文字列のfromIndex番目以降の文字列で部分文字列が最初に出現する位置のインデックスを返す。\nちなみに部分文字列が存在しない場合は-1を返す。\nclass Main{ public static void main(String args[]){ String s = \u0026#34;apple,banana,cherry,durian\u0026#34;; System.out.println(s.indexOf(\u0026#34;banana\u0026#34;)); System.out.println(s.indexOf(\u0026#34;banana\u0026#34;,10)); } } \u0026gt; java Main 6 -1   Python  pythonでは文字列strの関数find関数を使う。\nstr.find(sub[, start[, end]])\nsubには検索したい部分文字列を入力する。\n実行結果には、strの中でsubが最初に現れる位置のインデックスが返される。\n存在しない場合には-1が返る。\nstrの指定した範囲内だけで検索したい場合には、引数start,endに値を指定して実行する。\n\u0026gt;\u0026gt;\u0026gt; s = \u0026#34;apple,banana,cherry\u0026#34; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; s.find(\u0026#34;banana\u0026#34;) 6 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; s.find(\u0026#34;banana\u0026#34;,10) -1 \u0026gt;\u0026gt;\u0026gt; また、文字列を右から検索する関数rfindもある。\n\u0026gt;\u0026gt;\u0026gt; s.rfind(\u0026#34;banana\u0026#34;) 6 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; s.find(\u0026#34;a\u0026#34;) 0 \u0026gt;\u0026gt;\u0026gt; s.rfind(\u0026#34;a\u0026#34;) 11 \u0026gt;\u0026gt;\u0026gt;   "},{"idx":165,"href":"/docs/programming/procon/minimum_spanning_tree/","title":"最小全域木","content":" 最小全域木 無向グラフが与えられたときに、その内のある辺だけを用いてグラフ中の任意の２頂点を連結(ある頂点から他のどの頂点への経路が存在する)にした木のことを全域木(Spanning Tree)という。\n辺にコストがあったときに、使われる辺のコストの和を最小にした全域木のことを最小全域木(Minimum Spanning Tree)という。\n例えばベルマンフォード・ダイクストラ法で用いたグラフの最小全域木は以下のように表される。\n最小全域木を求めるアルゴリズムとして、一般にプリム法とクラスカル法の2つが知られている。\nプリム法 プリム法は、グラフのある頂点から辺を付け足して行って最小全域木を求めていく手法である。\n始め、1つの頂点vからなるグラフTを考えたとき、ここからグラフTとその他の頂点を結ぶ最小コストの辺をグラフTに追加していく、と言う操作を繰り返すことにより、最小全域木が作成できる。\nプリム法のアルゴリズムは以下の通り。\n入出力：\n 入力  グラフ G = (V,E) W(a,b):頂点aから頂点b(a,b∈V)を結ぶ辺の重み(コスト)。辺が存在しないときはW(a,b)=∞ 頂点s (s∈V)  出力  最小全域木 X = (V\u0026rsquo;,E\u0026rsquo;)   アルゴリズム：\n X=a (a∈V)、Y=V-X とする。aは何でも良い。 頂点x (x∈X) 、頂点y (y∈Y)を結ぶ辺で、Xに追加したときに閉路をなさない辺のうち、最小のコストを持つ辺eを探す。 X=X+(eのY側の要素)、Y=Y-(eのY側の要素)とする。 Y={} (|Y|=0) ならば、Xを出力して終了する。そうでない時は、2.に戻る。  例として、以下のグラフに対しプリム法を適用した場合を追って説明する。\nまずは頂点Aを最小全域木Xとし、その他の頂点をグラフYとする。\n次に、グラフXとグラフYを結ぶ辺のうち、Xに加えた時に閉路をなさず、最小コストである辺を探す。この場合は、頂点A-Bを結ぶ辺が該当する。\nこの辺、及び、頂点BをXに加え、またYから除外する。\nこの動作を繰り返していく。この状態において、グラフXとグラフYを結ぶ辺のうち、Xに加えた時に閉路をなさず、最小コストである辺は、頂点B-Cを結ぶ辺が該当する。よって、頂点CをXに加え、またYから除外する。\n次は、頂点A-Dを結ぶ辺が該当する。\n次は、頂点D-Eを結ぶ辺が該当する。\nYの頂点がなくなったので、Xを出力して終了する。このXが、最小全域木である。\n以上が、プリム法による最小全域木の導出である。これをコードで実装した例を以下に示す。\nINF=float(\u0026#34;inf\u0026#34;) # 設定（ユーザ側で入力） V=0 #頂点数 cost=[[INF for _ in range(V)] for _ in range(V)] #cost[i][j]:頂点iから頂点jへのコスト # 設定（入力しない） ans_cost=[[INF for _ in range(V)] for _ in range(V)] #cost_x[i][j]:(最小全域木の)頂点iから頂点jへのコスト min_cost=[INF for _ in range(V)] #min_cost[i]:Xから頂点iへの最小コスト y_nearest_x=[INF for _ in range(V)] #y_nearest_x[i]:頂点iへのコストが最も低いXの頂点 used=[False for _ in range(V)] #used[i]:頂点iがXに含まれているか示す for i in range(V): ans_cost[i][i]=0 #初めの点の初期設定 min_cost[0]=0 y_nearest_x[0]=0 while True: v=-1 #Xに属さない頂点のうちXからの辺のコストが最小になる頂点を探す for u in range(V): if(not used[u] and (v==-1 or min_cost[u] \u0026lt; min_cost[v])): v=u #全て見終わったら終了 if(v==-1): break #頂点vをXに追加する used[v]=True ans_cost[v][y_nearest_x[v]]=cost[v][y_nearest_x[v]] ans_cost[y_nearest_x[v]][v]=cost[y_nearest_x[v]][v] #xからの最終コスト更新 for u in range(V): if(cost[v][u]\u0026lt;min_cost[u]): min_cost[u]=cost[v][u] y_nearest_x[u]=v print(ans_cost) このコードにおいて、先程の例で示したグラフを表す以下の値を入力する。\nV=5 cost=[[0,2,5,6,INF],[2,0,1,INF,9],[5,1,0,INF,10],[6,INF,INF,0,4],[INF,9,10,4,0]] すると、実行結果は以下のようになる。\n[[0, 2, inf, 6, inf], [2, 0, 1, inf, inf], [inf, 1, 0, inf, inf], [6, inf, inf, 0, 4], [inf, inf, inf, 4, 0]]  クラスカル法 最小全域木を求める2つ目のアルゴリズムとして、クラスカル法を示す。\nクラスカル法は、辺をコストの低い順から、閉路ができないように全ての頂点が含まれるまで追加していくという手法である。この方法で、最小全域木が作成される。\nクラスカル法のアルゴリズムは以下の通り。\n入出力：\n 入力  グラフ G = (V,E) W(a,b):頂点aから頂点b(a,b∈V)を結ぶ辺の重み(コスト)。辺が存在しないときはW(a,b)=∞  出力  最小全域木 X = (V\u0026rsquo;,E\u0026rsquo;)   アルゴリズム：\n Eをコストの小さい順にソートする。 コストが最小の辺e (e∈E)を取り出し、eをEから除外する(E=E-e)。 eをXに追加したときに閉路ができなければ、eをXに追加する。結んでいる頂点もXに追加する。 Xに全ての頂点が含まれたら、Xを出力して終了する。そうでない時は、2.に戻る。  3.の閉路ができるかを判定する方法については、Union-FInd木を用いると判定しやすい。辺を追加するときに、結ぶ頂点が同じUnion-Find木にあるならば、閉路ができると判断できる。\nこれも図を使って流れを説明してみよう。プリム法でも用いた以下のグラフを利用する。\nまずは、辺も頂点もない以下の状態から始まる。\n次に、一番コストが低い辺を探して、最小全域木に加える。この場合は、頂点B-C間の辺である。\n同様にして、次に最もコストが低い頂点A-B間の辺、さらに次に最もコストが低い頂点D-E間の辺を加える。\n次だが、最もコストの低い頂点A-C間の辺は加えると閉路ができてしまうので、ここでは加えない。その次にコストの低い頂点A-D間の辺を加える。\nこれで、全ての頂点が含まれたので、このグラフを出力して終了する。このグラフが、最小全域木となる。\nでは次に、コードでの実装例を以下に示す。(なお、コード中で使用しているUnion-Find木のスクリプトはこちらを参照。)\nfrom union_find import UnionFind_fast INF=float(\u0026#34;inf\u0026#34;) #辺 class edge: def __init__(self,start,end,cost): self.start=start self.end=end self.cost=cost def e_comp(e1,e2): return e1.cost \u0026lt; e2.cost # 設定（ユーザ側で入力） V=0 #頂点数 cost=[[INF for _ in range(V)] for _ in range(V)] #cost[i][j]:頂点iから頂点jへのコスト # 設定（入力しない） es=[edge(i,j,cost[i][j]) for i in range(V) for j in range(i+1,V) if cost[i][j] != INF ] es=sorted(es,key=lambda ei:ei.cost) ans_cost=[[INF for _ in range(V)] for _ in range(V)] #cost_x[i][j]:(最小全域木の)頂点iから頂点jへのコスト uf=UnionFind_fast(V) for i in range(len(es)): ei=es[i] if(not uf.same(ei.start,ei.end)): uf.unite(ei.start,ei.end) ans_cost[ei.start][ei.end]=cost[ei.start][ei.end] ans_cost[ei.end][ei.start]=cost[ei.end][ei.start] print(ans_cost) ここで、プリム法と同じく以下の設定値を入力して実行してみる。\nV=5 cost=[[0,2,5,6,INF],[2,0,1,INF,9],[5,1,0,INF,10],[6,INF,INF,0,4],[INF,9,10,4,0]] 実行結果は以下の通り。\n[[inf, 2, inf, 6, inf], [2, inf, 1, inf, inf], [inf, 1, inf, inf, inf], [6, inf, inf, inf, 4], [inf, inf, inf, 4, inf]]  "},{"idx":166,"href":"/docs/programming/math/maximum_likelihood/","title":"最尤推定","content":" 最尤推定 当たりとハズレがそれぞれ何個か入ったくじがあり、当たりが出た時を１、ハズレが出た時を０と設定する。\nこの時、n回目にくじを引いた時の結果をTn、及び行列Tを以下のように設定する。\n  $$ \\begin{aligned} \\tag{1} {\\bf T} \u0026= \\left[ \\begin{array}{ccc} T_{1} \u0026 \\cdots \u0026 T_{N} \\end{array} \\right] \\end{aligned} $$ 試しにくじを５回引き、その結果がT=[0,0,0,0,1]だったとする。\nここで、くじを引いた時に当たりが出る確率をp (0≦p≦1) とした時、この事象が発生する確率はどうなるだろうか。\nその確率をL(p)とすると、\n$$ \\tag{2} L(p) = (1-p)^4 p $$ となる。\nここで、pがいくつの時に、このような事象が最も出やすくなるだろうか。\nこの事象が最も出やすくなるようなpの値を考えることにより、当たりが出る確率pの値を推定してみることを考えてみよう。\nちなみに、L(p)はpの色々な値における尤もらしさを表す関数とみなすことができ、このような尤もらしさのことを尤度といい、それを関数で表したものを尤度関数という。\n例えばL(p)において、p=0.1の時の尤度(L(0.1))は0.06561、p=0.2の時の尤度(L(0.2))は0.08192となる。\nここで、最尤法という方法を用いて求めることにしてみよう。これは尤度関数を最大にするものを求める推定量とするというものである。\nまた、このような尤度関数L(p)を最大にするようなpのことを最尤推定値、それにより得られる関数の値を最尤推定量という。\n今回の例にあてはめてみると、L(p)を最大にするような最尤推定値pを求める。では、そのようなpを求めてみよう。\nL(p)をpで微分すると以下のようになる。\n$$ \\tag{3} \\frac{dL(p)}{dp} = (1-p)^3 (1-5p) $$ この式より、p=0.2が最尤推定値になり、およびその最尤推定量は0.08192となる。\n念のため、L(p)を図で表すと以下のようになる。この図でもp=0.2の時にL(p)が最大になることは明らかである。\nこれより、求めるpの値は0.2であり、この時にT=[0,0,0,0,1]といった事象が最も出やすくなる、ということになる。\n対数尤度 先ほどはL(p)を微分することで求めたが、対数を取ることで計算が楽になる場合もあるので、その計算方法も示す。\n式(2)において、両辺の対数を取ると以下のようになる。\n$$ \\tag{4} \\log L(p) = 4 \\log (1-p) + \\log p $$ この式(4)において、log L(p)を最大にするpを求めれば、そのpはL(p)を最大にするpにもなるので、ここからpを求めるのも良い。\n式(4)のように、対数をとった尤度を対数尤度という。\n$$ \\begin{aligned} \\tag{5} \\frac{d log L(p)}{dp} \u0026= \\frac{d}{dp} [ 4 \\log (1-p) + \\log p ] \\\\ \u0026= \\frac{-4}{1-p} + \\frac{1}{p} \\\\ \u0026= \\frac{1-5p}{(1-p)p} = 0 \\\\ \u0026\\Leftrightarrow p = \\frac{1}{5} \\end{aligned} $$ この方法でも、p = 1\u0026frasl;5 (=0.2) と求められる。\n"},{"idx":167,"href":"/docs/programming/math/conditional_probability/","title":"条件付き確率","content":" 条件付き確率 私は高校で条件付き確率を学んでこなかったゆとり世代なので、改めて条件付き確率において書き記していく。\n事象A,Bにおいて、ある事象Bが起こったという条件下での事象Aが起こる確率のことを、Bを条件とするAの条件付き確率と呼び、P(A|B)と表す。\nP(A|B)の求め方は、Bが起こった中のうちAが起こりうる確率であるから、以下の式で表される。\n  $$ \\tag{1} P(A|B) = \\frac{ P( A \\cap B ) }{ P(B) } $$ 例題 袋の中に1,2,3の数字が書かれた赤玉と白玉の計６個の玉が入っている。\nこの中から、２以上の数字が書かれた球を取り出す事象をAとおく。事象Aが起こる確率P(A)はいくらか？\n答えは2/3である。\nでは、球を取り出した時に球の色が赤だった事が判明したとする。この時球に書かれた数字が２以上である確率はいくらか？\n先ほどの事象Aに加え、赤い球を取り出す事象をBとおく。この場合は事象Bが起こった上での事象Aが起こる確率であるため、Bを条件とするAの条件付き確率となり、その確率P(A|B)は以下のようになる。\n$$ \\begin{aligned} \\tag{2} P(A|B) \u0026= \\frac{ P( A \\cap B ) }{ P(B) } \\\\ \u0026= \\frac{ \\frac{ 2 }{ 6 } }{ \\frac{ 3 }{ 6 } } \\\\ \u0026= \\frac{ 2 }{ 3 } \\end{aligned} $$ "},{"idx":168,"href":"/docs/programming/machine_learning/ml_index/","title":"機械学習","content":" 機械学習 機械学習の手法についてをまとめる。\n 教師あり学習  回帰  直線モデル(線形回帰) 平均二乗誤差 勾配法(最急降下法) 解析解 2次元入力の面モデル N次元線形回帰モデル 線形基底関数モデル オーバーフィッティング(過学習) ホールドアウト検証 交差検証  分類  １次元入力２クラス分類 ロジスティック回帰モデル 交差エントロピー誤差 平均交差エントロピー誤差の最適解の導出 ２次元入力２クラス分類 ２次元入力３クラス分類   教師なし学習  クラスタリング  K-Means法 歪み尺度 混合ガウスモデル   深層学習(ディープラーニング)  ニューラルネットワーク 数値微分法 誤差逆伝搬法 Kerasでニューラルネットワーク 手書き文字の認識 フィルターと畳み込みニューラルネットワーク   "},{"idx":169,"href":"/docs/programming/other/re/","title":"正規表現","content":" 正規表現 文字列に正規表現を適用してある文字列パターンを抽出・検索したいという場合があると思う。\nその場合に利用する方法を示す。\nちなみに正規表現の文法についてはここでは割愛する。\nPython  Pythonでは正規表現を扱うreモジュールがある。 この中には色々関数があり、これらを利用して文字列パターンの抽出や検索を行う。\nまた、reを使う時、条件として使う正規表現も文字列として入力するが、正規表現で使う文字は特殊文字が多く、そのまま入力すると正規表現として認識してくれない時がある。 それを防ぐため、pythonのraw文字列を使って正規表現を書く。raw文字列を使うと、特殊文字を無視して一文字として扱ってくれるのでこの場合便利。使用法は文字列のクォーテーション(\u0026lsquo;)の前にrを付ける。\n(例)\n\u0026gt;\u0026gt;\u0026gt; print(\u0026#39;C:\\Users\\Downloads\u0026#39;) File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1 SyntaxError: (unicode error) \u0026#39;unicodeescape\u0026#39; codec can\u0026#39;t decode bytes in position 2-3: truncated \\UXXXXXXXX escape \u0026gt;\u0026gt;\u0026gt; # \\u はUnicode文字列として認識されてエラーになる \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(r\u0026#39;C:\\Users\\Downloads\u0026#39;) C:\\Users\\Downloads \u0026gt;\u0026gt;\u0026gt; # \\Uも\\Dも特殊文字とは認識せずそのまま出力する \u0026gt;\u0026gt;\u0026gt; このraw文字列を使い、以下に正規表現の関数の例を示す。\n正規表現の文字列を正規表現オブジェクトに変換する pythonのreで正規表現を使うには、文字列で表した正規表現をそのまま使う方法と、正規表現オブジェクトに変換して使う方法の2つがある。\nどちらでもよいが、正規表現の動作を何回も行わせるときは最初に文字列を正規表現オブジェクトに変換させてそれを繰り返し使わせた方が効率良く利用できる。\n文字列を正規表現オブジェクトに変換するには、reモジュールのcompile関数を使う。\nre.compile(pattern, flags=0)  引数patternに文字列で表した正規表現を入れると、それに対応した正規表現オブジェクトを返してくれる。\n正規表現を使って文字列を検索・抽出する 実際に正規表現を使って文字列から該当する部分を検索・抽出するにはどうすればよいのか？ それにはreモジュールの以下諸関数を利用する。\n ・re.search(pattern, string, flags=0)  #stringで正規表現patternに最初にマッチした部分を返す   ・re.match(pattern, string, flags=0)  #stringの先頭が正規表現patternにマッチしていたらそれを返す   ・re.fullmatch(pattern, string, flags=0)  #string全体が正規表現patternにマッチしていたらそれを返す   ・re.findall(pattern, string, flags=0)  #string中で正規表現patternにマッチしているものをリストにして全て返す   いずれの関数も、もし該当する部分がない場合はNoneが返される。 また、これら諸関数の返り値は文字列ではなく、マッチオブジェクトと呼ばれる型のデータを返す(findallはリストを返す)。 マッチオブジェクトから結果を取得したい場合は、以下の諸関数をさらに利用する。\n  ・Match.start() #マッチした文字列の文字列中での最初のインデックスを返す   ・Match.end() #マッチした文字列の文字列中での最後のインデックスを返す   ・Match.span() #マッチした文字列が文字列中でどこからどこまでのインデックスなのかを返す   ・Match.group() #マッチした文字列を返す   \u0026gt;\u0026gt;\u0026gt; import re \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; s = \u0026#34;aaabbbcccdddeeefffggghhhiiijjjkkklllmmmnnnoooppp\u0026#34; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; pattern=re.compile(r\u0026#39;d+\u0026#39;) \u0026gt;\u0026gt;\u0026gt; m = re.search(pattern,s) \u0026gt;\u0026gt;\u0026gt; m.group() \u0026#39;ddd\u0026#39; \u0026gt;\u0026gt;\u0026gt; m.start() 9 \u0026gt;\u0026gt;\u0026gt; m.end() 12 \u0026gt;\u0026gt;\u0026gt; m.span() (9, 12) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; m = re.match(pattern,s) \u0026gt;\u0026gt;\u0026gt; print(m) #先頭(aaa...)に一致しないのでNone None \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; pattern=re.compile(r\u0026#39;a+\u0026#39;) \u0026gt;\u0026gt;\u0026gt; m = re.match(pattern,s) \u0026gt;\u0026gt;\u0026gt; m.group() \u0026#39;aaa\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; s = \u0026#34;aaa\u0026#34; \u0026gt;\u0026gt;\u0026gt; pattern=re.compile(r\u0026#39;a+\u0026#39;) \u0026gt;\u0026gt;\u0026gt; m = re.fullmatch(pattern,s) \u0026gt;\u0026gt;\u0026gt; m.group() \u0026#39;aaa\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; pattern=re.compile(r\u0026#39;a\u0026#39;) \u0026gt;\u0026gt;\u0026gt; m = re.findall(pattern,s) \u0026gt;\u0026gt;\u0026gt; print(m) [\u0026#39;a\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;a\u0026#39;] \u0026gt;\u0026gt;\u0026gt;  正規表現を使って文字列を置換する 文字列中の正規表現に該当する箇所を別の文字列に置換するにはreモジュールの関数subを使う。\nre.sub(pattern, repl, string, count=0, flags=0)\nこの関数を使うと文字列stringの中で正規表現patternに該当する最も左の箇所をreplに置換した文字列を出力する。 引数のcountには置換を行う最大回数(非負整数)を入力する。デフォルトは0だが、0の場合は回数制限なしに全てを置換する。\n\u0026gt;\u0026gt;\u0026gt; import re \u0026gt;\u0026gt;\u0026gt; s=\u0026#34;aaabbbcccdddeeefff\u0026#34; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; re.sub(r\u0026#39;a+\u0026#39;,\u0026#39;A\u0026#39;,s) \u0026#39;Abbbcccdddeeefff\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; re.sub(r\u0026#39;a\u0026#39;,\u0026#39;A\u0026#39;,s) \u0026#39;AAAbbbcccdddeeefff\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; re.sub(r\u0026#39;aa\u0026#39;,\u0026#39;A\u0026#39;,s) \u0026#39;Aabbbcccdddeeefff\u0026#39; \u0026gt;\u0026gt;\u0026gt;    "},{"idx":170,"href":"/docs/programming/machine_learning/distortion_measure/","title":"歪み尺度","content":" 歪み尺度 教師あり学習では、学習が進み精度が高くなることの指標として、平均交差エントロピー誤差のような関数を利用していた。\n教師なし学習、今回のクラスタリングの場合でもこのような関数を設定し利用することはできないだろうか。\n実は、クラスタリングにおいてもそのような関数があり、歪み尺度と呼ばれている。\n歪み尺度とは、全ての入力データにおいてそれが属するクラスタの中心位置との距離の2乗の和を取ったものである。\nこの値が小さくなればなるほど、クラスタリングがうまく行われているとみなせる。\n歪み尺度を求める式を以下に示す。\n  $$ \\tag{1} J = \\sum_{x_{i} \\in クラスタk}^{} \\sum_{k=0}^{クラスタ数-1} | x_{i} - { \\bf \\mu }_{k} | ^2 $$ では、前述のクラスタリングに歪み尺度を求めるコードを追加してみよう。\nk-means法のコードに歪み尺度を求めるコードを追加し、学習\u0008するループごとにおいて歪み尺度を計算し、表示してみる。\nimport numpy as np k=-1 x=[] mu=[] R=[] ## 新規追加　歪み尺度を求める関数 def distortion_measure(x,mu,r): #クラスタ数 k=r.shape[1] #歪み尺度 J=0 #計算 for i in range(k): xi=x[r[:,i]==1] for j in range(xi.shape[0]): J+=(xi[j][0]-mu[i][0])**2 +(xi[j][1]-mu[i][1])**2 return J #R計算 def calc_r(X,Mu): #初期化　入力データx、μとR用意 x=np.array(X) mu=np.array(Mu) k=len(mu) R=np.zeros((len(x),k)) for i in range(len(x)): ri=np.zeros(k) ri[0]=1 R[i]=ri flag=True count=1 while(flag): flag=False #Rを計算し更新 for i in range(len(x)): d=[(x[i][0]-mu[j][0])**2 + (x[i][1]-mu[j][1])**2 for j in range(k)] ri=np.zeros(k) ri[d.index(min(d))]=1 if(not np.allclose(R[i],ri)): flag=True R[i]=ri #μを調整 for i in range(k): x_i=x[R[:,i]==1] mu_ix=np.mean(x_i[:,0]) mu_iy=np.mean(x_i[:,1]) mu[i]=np.array([mu_ix,mu_iy]) ##この部分を新規追加 学習終了後に歪み尺度を計算して表示 J=distortion_measure(x,mu,R) print(\u0026#34;学習{0}回目,歪み尺度:{1}\u0026#34;.format(count,J)) count+=1 return mu,R 実行結果(コンソール)\n$ python do_k_means.py 学習1回目,歪み尺度:144.6011020740245 学習2回目,歪み尺度:151.78653084347673 学習3回目,歪み尺度:136.5863856799487 学習4回目,歪み尺度:134.59275424760008 学習5回目,歪み尺度:134.59275424760008  となり、初めは尺度が上がっているが、学習が進むにつれ歪み尺度が少なくなっていき、学習の精度が高くなっていることが伺える。\n"},{"idx":171,"href":"/docs/programming/procon/dfs/","title":"深さ優先探索","content":" 深さ優先探索 探索の手法の一つである深さ優先探索についてを述べる。\n深さ優先探索とは、ある状態から始めてそこから遷移出来なくなるまで状態を進めていき、遷移出来なくなったら１つ前の状態に戻ってそこから別の状態へと遷移し、また遷移出来なくなったら１つ前の状態に戻る、を繰り返して全ての状態を探索していく手法である。\n状態遷移が木構造の様な図で表される時に適用しやすい。\n探索のイメージは下図の通り。\n例として、以下の様な問題を考えてみる。\n 1,5,10,50,100,500円玉を１枚ずつ持っている時、k円をちょうど支払う事が可能かを判定しなさい。\n 深さ優先探索を用いて考えると、全ての硬貨において使う/使わないで場合分けし、使った硬貨の金額の和がk円に等しくなればOK、その様なパターンが１つもなければ払えないという事になる。\nコードでの実装例は以下の通り。(python)\n#coin_dfs.py #k円、標準入力から print(\u0026#34;k:\u0026#34;,end=\u0026#34;\u0026#34;) k=int(input()) coin=[1,5,10,50,100,500] #硬貨の場合分けを深さ優先探索で調べる、iが場合分けした硬貨の枚数、nが現在の金額 def dfs(i,n): #全て調べ終わったら判定 if(i==6): return n==k #coin[i]を使わない場合 if( dfs(i+1,n) ): return True #coin[i]を使う場合 if( dfs(i+1,n+coin[i])): return True #どの場合もTrueにならなかった → 払えないのでFalse return False print(dfs(0,0)) 実行例\n$ python coin_dfs.py k:3 False $ python coin_dfs.py k:50 True  なお、この問題における探索のイメージは以下の図の通りである。\ni==6となった時に金額nがkに等しければTrueが返る。\n"},{"idx":172,"href":"/docs/programming/machine_learning/gaussian_mixture_model/","title":"混合ガウスモデル","content":" 混合ガウスモデル 先程のk-means法では、データを必ずどれか一つのクラスターに割り当てていたが、複数のクラスターに割り当てると言うことはできないだろうか？\nここで、教師あり学習でも利用した、確率を使った表現を利用することを考えてみる。\nk-means法では入力データがどのクラスタに属するかを示すものとして行列Rを用いていた。\nここでは、この行列Rを、以下のように行列Γとして設定する。なお、入力データの個数をN個とする。\n  $$ \\tag{1} {\\bf \\Gamma} = \\left[ \\begin{array}{cc} {\\bf \\gamma}_{0} \\\\ {\\bf \\gamma}_{1} \\\\ \\vdots \\\\ {\\bf \\gamma}_{N-1} \\\\ \\end{array} \\right] $$ ここでクラスタ数をKとした時、\n$$ \\tag{2} {\\bf \\gamma}_{i} = \\left[ \\begin{array}{cc} \\gamma_{i0} \u0026 \\gamma_{i1} \u0026 \\cdots \u0026 \\gamma_{i(K-1)} \\end{array} \\right] $$ となる。γikは、i番目の入力データがクラスタkに属する確率を示す。\nまた、これより\n$$ \\tag{3} \\sum_{k=0}^{K-1} \\gamma_{ik} = 1 $$ である。\nデータがクラスタに属する確率とは？ そもそもの話だが、入力データがクラスタkに属する確率とはどう言う意味なのか？\n具体的な例を使って説明してみよう。先程の例では温度とpHを入力としたデータを利用していた。\nここで、例えば温泉の源泉が複数あり、それらの組み合わさったことによって入力データの温度とpHが実現している、と言う説を考えてみよう。\nそうなると、源泉の数だけクラスタが存在すると考えることができ、かつ元となる源泉の温度とpHは固定されているので、それらが各クラスタの中心をなしているとも考えられる。\nこのように、観察はできなかったがデータに影響を与えているだろう変量のことを潜在変数(latent valiable)または隠れ変数(hidden variable)と呼ぶ。\nこの潜在変数を数式で定義するにはどうすれば良いだろうか。式(2)と同様にして、潜在変数の個数をK個とした時、以下のようなziを考えてみる。(0≦i＜N)\n$$ \\tag{4} {\\bf z }_{i} = \\left[ \\begin{array}{cc} z_{i0} \u0026 z_{i1} \u0026 \\cdots \u0026 z_{i(K-1)} \\end{array} \\right] $$ 式(4)において、zijは、i番目のデータがj番目の潜在変数に属していたら１、属していなければ０をとる変数とする。(0≦j＜K)\nこれより、γik（i番目の入力データがクラスタkに属する確率）は、i番目の入力データが潜在変数kに属する確率と言い換えることもでき、以下のような式で表される。\n$$ \\tag{5} {\\bf \\gamma}_{ik} = P(z_{ik} = 1 | x_{i}) $$ 式(5)は、簡単にいうとzikの値がわからない時に、zikの推定値として利用できる。入力データxiがどの潜在変数に属するかわかっていれば、式(5)の値は0または1になるので推定はしなくても良いが、xiがどの潜在変数に属するかがわからない場合はこの式(5)の値が0から1の値を取るので、この値が潜在変数に属する確率として利用できる。\nこの式(5)で表されるγは、「入力データがどの潜在変数(クラスタ)に属する確率」という意味合いから、負担率 (responsibility)とも呼ばれている。\n確率的にクラスタリングを行うということは、データの背後に潜む潜在変数Zを確率的な変数γ(負担率)として推定することである。\n次に、この負担率γを推定する方法についてを述べる。\n混合ガウスモデル 負担率γを求めるために、混合ガウスモデルという確率モデルを導入する。\n混合ガウスモデルは、２次元ガウス関数を複数足し合わせたもので、以下の式で表される。\n$$ \\tag{6} p( {\\bf x} ) = \\sum_{k=0}^{K-1} \\pi_{k} N ({\\bf x} | {\\bf \\mu}_{k} , {\\bf \\Sigma}_{k} ) $$ N(x|μk,Σk)は平均μk、共分散行列Σkの２次元ガウス関数を表している。\nこのモデルのパラメータは、各ガウス分布の中心を表す中心ベクトルμk、分布の散らばり具合を示す共分散行列Σk、各ガウス分布の大きさ(係数)を示す混合係数 πkである。混合係数は0から1の間を取る値であり、また全ての混合係数の和は1となる。\n$$ \\tag{7} \\sum_{k=0}^{K-1} \\pi_{k} = 1 $$ では、どのようにして入力データに対する最適なパラメータμk、Σk、πkを求めれば良いか。そのための方法を次に示す。\nEMアルゴリズム 前述のパラメータを入力データにフィットし、負担率γを求める方法として、EMアルゴリズム(Expectation-Maximization algorithm)を利用する。この方法はK-means法を応用した方法としても見れる。\nK-means法では、各クラスタの中心ベクトルを元にフィッティングを行なったが、EMアルゴリズムでは、中心ベクトルの他に共分散行列もフィッティングに利用する。\n大まかな手順を、以下に記載しながら進める。\n1. パラメータの初期化 まず最初に、パラメータμ、Σ、πを初期化する。\n値は何でも良いが、まずはπはどれも均等に、Σは[[1 0],[0 1]]、μはk-means法と同じ要領で決定する。\n2. γの更新 次に、入力データxiと各パラメータμ、Σ、πから、負担率γを計算する。\n式(5)から、負担率γを算出する式は以下の式(8)のようになる。\n$$ \\tag{8} \\gamma_{ik} = \\frac{ \\pi_{ik} N ({\\bf x}_{i} | {\\bf \\mu}_{k} , {\\bf \\Sigma}_{k} ) }{ \\sum_{k=0}^{K-1} \\pi_{k} N ({\\bf x}_{i} | {\\bf \\mu}_{k} , {\\bf \\Sigma}_{k} ) } $$ 式(5)は「i番目の入力データが潜在変数kに属する確率」なので、その値は「i番目の入力データが潜在変数0~K-1に属する時のガウス関数の値の和」のうち「i番目の入力データが潜在変数kに属する時のガウス関数の値」の確率になる。それを示したのが式(8)である。\nこの式により、γikを一つ一つ求めていく。\nちなみにこの2.の動作を、EMアルゴリズムではE Step(Expectatoin step)と呼ばれる。\n3. パラメータの更新 次に、算出した負担率γにおいて、各クラスタ(潜在変数)への負担率の和Nkを求める。\n$$ \\tag{9} N_{k} = \\sum_{i=0}^{N-1} \\gamma_{ik} $$ このNkは、各クラスタに属する入力データの数に相当する。\nまた、混合係数πkを以下の式(10)により更新する。\n$$ \\tag{10} \\pi_{k} = \\frac{ N_{k} }{ N } $$ Nは入力データの数なので、この式(10)によりクラスタkの混合係数πkは全体に対するクラスタ内の数の割合になる。\nそして、中心ベクトルμkを以下の式(11)に基づき更新する。\n$$ \\tag{11} \\mu_{k} = \\frac{1}{ N_{k} } \\sum_{i=0}^{N-1} \\gamma_{ik} x_{i} $$ 式(11)は、クラスタへの負担率を重みづけた上でのデータの平均となり、この値を新しい中心ベクトルとして利用する。\nそして次に、共分散行列Σを更新する。Σの更新の際には、式(11)で求めたμkを利用するので注意する。\n$$ \\tag{12} \\Sigma_{k} = \\frac{1}{ N_{k} } \\sum_{i=0}^{N-1} \\gamma_{ik} (x_{i} - \\mu_{k}) (x_{i} - \\mu_{k})^{T} $$ 式(12)も式(11)と同じく、計算にはクラスタへの負担率を重みづけた上で行い、出力する。\nこの3.の動作を、EMアルゴリズムではM Step(Maximization Step)と呼ぶ。\n4. 2.へ戻る(E Stepを行う) M stepが終わったらE stepを行い、その後M stepを行い、またE stepを行い、、というように、E stepとM stepを繰り返していき、パラメータが収束するまで行う。\n以上が、混合ガウスモデル、及びEMアルゴリズムによる確率的クラスタリングの算出である。\n尤度 EMアルゴリズムでは混合ガウスモデルが入力データに合うようにパラメータを最適化させていたが、パラメータごとではない、EMアルゴリズムによって最適化される値というのは何かないだろうか。\n実は、それは尤度と呼ばれるもので、入力データが混合ガウスモデルから生成される確率である（教師あり学習　の章で既出）\n尤度の式は、下式(13)で与えられる。\n$$ \\tag{13} p( {\\bf X} | {\\bf \\pi} , {\\bf \\mu} , {\\bf \\Sigma} ) = \\prod_{n=0}^{N-1} \\sum_{k=0}^{K-1} \\pi_{k} N (x_{n} | \\mu_{k} , \\Sigma_{k}) $$ 対数尤度をとると\n$$ \\tag{14} \\log p( {\\bf X} | {\\bf \\pi} , {\\bf \\mu} , {\\bf \\Sigma} ) = \\sum_{n=0}^{N-1} \\{ \\log \\sum_{k=0}^{K-1} \\pi_{k} N (x_{n} | \\mu_{k} , \\Sigma_{k}) \\} $$ 値を最大化(最適化のため)させるために、式(14)に-1をかけて負の対数尤度にし、それを誤差関数E(π,μ,Σ)として定義すると\n$$ \\tag{15} \\begin{aligned} E ( \\pi , \\mu , \\Sigma) \u0026= - \\log p( {\\bf X} | {\\bf \\pi} , {\\bf \\mu} ) \\\\ \u0026= - \\sum_{n=0}^{N-1} \\{ \\log \\sum_{k=0}^{K-1} \\pi_{k} N (x_{n} | \\mu_{k} , \\Sigma_{k}) \\} \\end{aligned} $$ となる。最適化すればするほど、この誤差関数の値が小さくなっていく。\nこの誤差関数を指標とすることで、混合ガウスモデル、EMアルゴリズムが正しく動作されているかを確認できる。\n"},{"idx":173,"href":"/docs/front-end/img/","title":"画像・動画・音声","content":" 画像・動画・音声 画像・動画・音声についての要素を述べる。\nimg要素 img要素は画像を表示させたい時、及びそれが利用できない時に代わりに表示させるテキストを指定する要素である。\n属性がいくつかあり、それらを利用する。\n・ src ・・・　 表示する画像の相対パスまたはアドレス  ・ alt ・・・　 画像が利用できない場合に代わりに使用されるテキスト\n(ブラウザによる)   ・ width ・・・　 幅(整数値)   ・ height ・・・　 高さ(整数値)   使用例\n\u0026lt;img src=\u0026quot;/img/front-end/img.jpg\u0026quot; width=\u0026quot;100\u0026quot; height=\u0026quot;100\u0026quot;\u0026gt; \u0026lt;img src=\u0026quot;/img/front-end/img.jpg\u0026quot; width=\u0026quot;50\u0026quot; height=\u0026quot;50\u0026quot;\u0026gt; \u0026lt;img src=\u0026quot;/img/front-end/img.jpg\u0026quot; width=\u0026quot;100\u0026quot; height=\u0026quot;100\u0026quot; alt=\u0026quot;宗谷岬、青空\u0026quot;\u0026gt;  実行例\n \npicture要素 picture要素はHTML5以降で追加された新しい要素で、複数のsource要素(後述)と一つのimg要素を取りまとめる要素である。これにより、最適なsource要素による画像、source要素が使えないブラウザではimg要素の画像が使われ、柔軟な画像の選定が行われる。\n（使用例はsource要素のところを参照）\nsource要素 source要素は、picture要素・video要素・audio要素の子要素として使用する要素で、複数記述、及び使用条件を指定することで、ブラウザに適した形で画像等を表示できる。\n・ media ・・・　 画像の使用条件  ・ srcset ・・・　 候補画像等のパス   ・ sizes ・・・　 使用条件と画像の表示幅   使用例\n\u0026lt;picture\u0026gt; \u0026lt;source media=\u0026quot;(min-width: 200em)\u0026quot; srcset=\u0026quot;/img/front-end/img3.jpg\u0026quot; title=\u0026quot;img3.jpg\u0026quot;\u0026gt; \u0026lt;source media=\u0026quot;(min-width: 100em)\u0026quot; srcset=\u0026quot;/img/front-end/img2.jpg\u0026quot; title=\u0026quot;img2.jpg\u0026quot;\u0026gt; \u0026lt;img src=\u0026quot;/img/front-end/img.jpg\u0026quot; width=\u0026quot;50\u0026quot; height=\u0026quot;50\u0026quot;\u0026gt; \u0026lt;/picture\u0026gt;  実行例\n   \nvideo要素 video要素は、動画を再生するための要素である。\n指定する属性は以下の通り。\n・ src ・・・　 ファイルのアドレス・パス  ・ controls ・・・　 再生・停止ボタンを表示させる   ・ autoplay ・・・　 再生を自動で開始させる   ・ loop ・・・　 再生を繰り返す(ループ)   ・ muted ・・・　 デフォルトでミュート(音量0)にする   ・ width ・・・　 幅を指定する   ・ height ・・・　 高さを指定する   例を以下に示す。\n\u0026lt;video src=\u0026quot;/img/front-end/IMG_3279.MOV.mp4\u0026quot; controls muted width=\u0026quot;500\u0026quot; height=\u0026quot;200\u0026quot; /\u0026gt;  実行例\n \n(ちなみにこの動画は私が学生時代に研究室の窓から外の吹雪を撮ったものである)\naudio要素 audio要素は音声を再生するための要素である。\n基本的には、video要素から視覚的な内容を排除したものであり、使う属性もvideo要素とほとんど同じ。\n・ src ・・・　 ファイルのアドレス・パス  ・ controls ・・・　 再生・停止ボタンを表示させる   ・ autoplay ・・・　 再生を自動で開始させる   ・ loop ・・・　 再生を繰り返す(ループ)   ・ muted ・・・　 デフォルトでミュート(音量0)にする   先程の動画ファイルをaudio要素で表示させてみよう。\n\u0026lt;audio src=\u0026quot;/img/front-end/IMG_3279.MOV.mp4\u0026quot; controls /\u0026gt;  実行例は以下の通り。\n \ntrack要素 track要素はvideo要素やaudio要素の子要素として利用する要素で、字幕などの外部テキストトラックファイルを指定する場合に使用する要素である。\n使用するテキストトラックファイルは、WebVTT形式(.vtt形式)またはTTML形式ファイルである。\n指定する主な属性は以下の通り。\n・ src ・・・　 ファイルのアドレス・パス  ・ srclang ・・・　 外部テキストファイルの言語   ・ kind ・・・　 外部テキストファイルをどのように使用するかの指定   また、kind属性には以下の値を指定する。\n・ subtitles ・・・　 音は聞こえるが理解できない人向けの字幕、映像に重ねて表示  ・ captions ・・・　 音が（明瞭に）聞こえない人向けの字幕、映像に重ねて表示   ・ descriptions ・・・　 映像が（明瞭には）見えない場合向けの解説、合成音声で読み上げる   ・ chapters ・・・　 映像のチャプターのタイトル、操作により一覧を表示   ・ metadata ・・・　 スクリプトから利用する事を想定したメタデータ   先程の動画ファイルを利用して実行例を示す。\n\u0026lt;video src=\u0026quot;/img/front-end/IMG_3279.MOV.mp4\u0026quot; controls muted width=\u0026quot;500\u0026quot; height=\u0026quot;200\u0026quot; \u0026gt; \u0026lt;track default kind=\u0026quot;captions\u0026quot; srclang=\u0026quot;ja\u0026quot; src=\u0026quot;/img/front-end/track.vtt\u0026quot;\u0026gt; \u0026lt;/video\u0026gt;  ちなみに字幕として利用するvttファイル(track.vtt)は以下の通り。\nWEBVTT 00:00:00.000 --\u0026gt; 00:00:15.000 これは字幕です。15秒まで表示されます。 00:00:15.000 --\u0026gt; 00:00:30.000 雪が降ってます。  表示例\n  \nembed要素 embed要素は、動画や音声などをプラグインを使って組み込む際に使う要素である。\nsrc属性で外部コンテンツを読み込み、ブラウザに追加インストールされたプラグインでコンテンツを利用する。\nよく使われるものとしては、.swfファイル(Flash)、.mpgファイル(MPEG)など。\n・ src ・・・　 組み込むファイルのパス  ・ type ・・・　 組み込むデータの種類   ・ width ・・・　 幅   ・ height ・・・　 高さ   map要素 一つの画像に複数のリンクを設定することをイメージマップという。map要素はこのイメージマップを設定する時に使用する要素である。\n具体的に画像のどの部分をどのリンクに対応させるかは、map要素の子要素として使う後述のarea要素で指定する。\nmap要素のname属性でイメージマップに名前を定義し、画像を定義しているimg要素のusemap属性でその名前を指定するとイメージマップを画像に適用できる。\narea要素 area要素は、イメージマップにおいて指定した領域を指定したリンク先に紐付ける要素である。\n使用する主な属性は以下の通り。\n・ coords ・・・　 領域の座標  ・ shape ・・・　 領域の形状   ・ href ・・・　 リンク先のアドレス   ここで、shape属性で指定できる値は決まっており、以下の通りである。また、それに応じてcoords属性で指定するあたいも変わってくる。\n  値  図形 coords属性に指定する値  ・ rect ・・・　 長方形 左上のx座標,左上のy座標,右下のx座標,右下のy座標  ・ circle ・・・　 円 円の中心のx座標,円の中心のy座標,半径   ・ poly ・・・　 多角形 各座標をx座標、y座標の順に指定   ・ default ・・・　 画像全体 (指定しない)   使用例\n\u0026lt;img src=\u0026quot;/img/front-end/area.png\u0026quot; usemap=\u0026quot;#top\u0026quot; width=\u0026quot;100\u0026quot; height=\u0026quot;100\u0026quot;\u0026gt; \u0026lt;map name=\u0026quot;top\u0026quot;\u0026gt; \u0026lt;area href=\u0026quot;https://wat36.github.io/pages/\u0026quot; shape=\u0026quot;rect\u0026quot; coords=\u0026quot;0,0,100,50\u0026quot;\u0026gt;\u0026lt;/area\u0026gt; \u0026lt;area href=\u0026quot;https://github.com/WAT36\u0026quot; shape=\u0026quot;rect\u0026quot; coords=\u0026quot;0,50,100,100\u0026quot;\u0026gt;\u0026lt;/area\u0026gt; \u0026lt;/map\u0026gt;  表示例（画像の上半分がこのブログのトップ、下半分は私のGithubへのリンク）\n    \nobject要素 object要素は、画像や音声の他、様々な形式の外部データを組み込むための要素である。\n・ data ・・・　 組み込むデータのアドレス  ・ type ・・・　 組み込むデータの種類   ・ width ・・・　 幅   ・ height ・・・　 高さ   param要素 param要素は、object要素における任意のパラメータ(属性)を指定する要素である。\nobject要素内では他の要素よりも前に配置させる。\n ・ name ・・・　 パラメータ名   ・ value ・・・　 パラメータの値   "},{"idx":174,"href":"/docs/programming/machine_learning/linear_model/","title":"直線モデル(線形回帰)","content":" 直線モデル 回帰問題の手法の一つである直線モデルについて。\n教師あり学習 で与えられた入力と結果から関係式を算出すると言うことを述べたが、 必ずしも100%正確な式を算出すると言うことでは無いことを念頭においてほしい。（と言うよりどのような入力に対して100%正解と言えるような値を算出することは不可能である。勿論算出する式は正確性を高くする事を目標に算出するが）\n関係式は、現入力データに対して最も誤差が少ないような結果を出力するような式を算出すると言うやり方で考える。\nその関係式だが、基本となる数式を元に算出を行う。この基本となる数式をモデルと呼ぶ。\n今回は例として、以下の身長と体重からなるデータを用意する。\n   身長 体重     167.9 58.0   164.3 58.2   171.6 60.1   172.7 65.2   162.8 55.0   170.2 60.9   172.3 61.9   163.8 56.4   168.8 62.9   167.2 57.0   172.3 64.9   166.4 55.9   173.1 68.0   176.9 67.9   178.4 69.1   167.1 60.8   177.4 65.6   173.7 66.1   172.0 59.9   174.1 69.5    プロットすると以下のような図になる。\n今回は基本となる数式として直線の式(直線モデル)を利用して予測を行ってみる。\nこのデータに対して、なんとなくだが、以下のような直線を引くとそれらしい予測を行えそうである。\n直線の式は以下の式のように表すことができる。\n  $$ y(x) = w_{0} x + w_{1} $$ 最適な直線モデルの式を求めるには、最適なw0とw1を求めれば良いのだが、どのように求めれば良いのか？\nそちらは次章で記載する。\n\u0026lt;参考\u0026gt;グラフのコード\nPython  \u0026gt;\u0026gt;\u0026gt; import numpy as np \u0026gt;\u0026gt;\u0026gt; import matplotlib.pyplot as plt \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; x = np.array([167.9,164.3,171.6,172.7,162.8,170.2,172.3,163.8,168.8,167.2,172.3,166.4,173.1,176.9,178.4,167.1,177.4,173.7,172.0,174.1]) \u0026gt;\u0026gt;\u0026gt; y = np.array([58.0,58.2,60.1,65.2,55.0,60.9,61.9,56.4,62.9,57.0,64.9,55.9,68.0,67.9,69.1,60.8,65.6,66.1,59.9,69.5]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; plt.scatter(x,y) \u0026lt;matplotlib.collections.PathCollection object at 0x11d2fcef0\u0026gt; \u0026gt;\u0026gt;\u0026gt; plt.xlim(160,180) (160, 180) \u0026gt;\u0026gt;\u0026gt; plt.ylim(50,75) (50, 75) \u0026gt;\u0026gt;\u0026gt; plt.grid(True) \u0026gt;\u0026gt;\u0026gt; plt.show() \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #↑でplt.gridまで行う \u0026gt;\u0026gt;\u0026gt; def f(x): ... return (0.9038 * x) - 92.1461 ... \u0026gt;\u0026gt;\u0026gt; x2 = np.array([0,100,200]) \u0026gt;\u0026gt;\u0026gt; y2 = f(x2) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; plt.plot(x2,y2,color=\u0026#39;red\u0026#39;) [\u0026lt;matplotlib.lines.Line2D object at 0x120b47ba8\u0026gt;] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; plt.show()   "},{"idx":175,"href":"/docs/programming/procon/procon_index/","title":"競プロテク","content":" 競プロテク 競技プログラミングでよく使う手法についてまとめる。 個人的に学びながらなので進度遅めかも\n 探索  深さ優先探索 キュー(Pythonでの実装モジュール「deque」)  データ構造  二分探索(Pythonで二分探索を行うライブラリ「bisect」) 優先度付きキュー(Pythonで実装するライブラリ「heapq」) Union-Find木 セグメント木 Binary Indexed Tree  グラフ  グラフの表現方法 二部グラフ グラフの頂点彩色・面彩色・辺彩色(Welsh・Powellのアルゴリズム) ベルマンフォード法 ワーシャル・フロイド法 ダイクストラ法 最小全域木  動的計画法  動的計画法の応用題  合同式(mod)・逆元 繰り返し二乗法  "},{"idx":176,"href":"/docs/programming/class_func/inheritance/","title":"継承","content":" 継承 クラスを実装できる言語の大半は、他のクラスの構造を受け継ぎ、そこから新しい変数やメソッド(関数)等を付け足す形でクラスを定義することができる。\nこれを継承という。\nクラスの継承の方法についてをここでは示す。\nJava  Javaでのクラスの継承の方法は以下の通り。\n[アクセス修飾子]　class クラス名 extends 継承元クラス(スーパークラス)名 { //文 }  Javaでは継承する元となるクラスをスーパークラス、継承して作成したクラスをサブクラスという。\nサブクラスはスーパークラスを継承して作成されるため、スーパークラスで定義した変数やメソッドは全て受け継がれる。 サブクラスからはスーパークラスの変数やメソッドを利用することができる（ただし設定されているアクセス修飾子により、利用できない場合がある）\n実行例を以下に示す。\nBeverageクラス\nclass Beverage{ int price = 0; String name = \u0026#34;\u0026#34;; public Beverage(int p,String n){ price = p; name = n; } public void howMuch(){ System.out.println(\u0026#34;This \u0026#34;+name+\u0026#34; is \u0026#34;+price+\u0026#34; yen.\u0026#34;); } } Liquorクラス（Beverageクラスを継承）\nclass Liquor extends Beverage{ int alcohol_content=100; public Liquor(int p,String n,int a){ super(p,n); //スーパークラスのコンストラクタ  alcohol_content=a; } } Mainクラス\nclass Main{ public static void main(String args[]){ Beverage orange_juice = new Beverage(100,\u0026#34;orange juice\u0026#34;); Liquor screw_driver = new Liquor(1000,\u0026#34;screw driver\u0026#34;,15); //orange_juice,変数、メソッドを表示  System.out.println(\u0026#34;orange_juice.price:\u0026#34; + orange_juice.price); System.out.println(\u0026#34;orange_juice.name :\u0026#34; + orange_juice.name); // 以下、Beverageクラスはalcohol_contentは持ってないので、参照しようとするとエラーになる // というよりコンパイルエラーになるので、一時的にコメントアウト // System.out.println(\u0026#34;orange_juice.alcohol_content:\u0026#34; + orange_juice.alcohol_content);  orange_juice.howMuch(); //screw_driver、変数、メソッドを表示  System.out.println(\u0026#34;screw_driver.price:\u0026#34; + screw_driver.price); System.out.println(\u0026#34;screw_driver.name :\u0026#34; + screw_driver.name); System.out.println(\u0026#34;screw_driver.alcohol_content:\u0026#34; + screw_driver.alcohol_content); screw_driver.howMuch(); } } 実行結果\n\u0026gt; java Main orange_juice.price:100 orange_juice.name :orange juice This orange juice is 100 yen. screw_driver.price:1000 screw_driver.name :screw driver screw_driver.alcohol_content:15 This screw driver is 1000 yen.   Python  Pythonでのクラスの継承の方法は以下の通り。\nclass クラス名(継承元クラス名): //文  ここで定義したクラスは継承元クラスが持つ変数や関数を受け継ぐので、文中に定義しなくても参照が可能である。\n別クラスを継承したクラスに定義した変数や関数はそのクラスのみが持ち、継承元のクラスは利用できない。\n実行例を以下に示す。\n\u0026gt;\u0026gt;\u0026gt; #Beverageクラス(飲み物) \u0026gt;\u0026gt;\u0026gt; class Beverage(): ... price=0 ... name=\u0026#34;\u0026#34; ... def __init__(self,p,n): ... self.price=p ... self.name=n ... def howmuch(self): ... return \u0026#34;This \u0026#34;+self.name+\u0026#34; is \u0026#34;+str(self.price)+\u0026#34; yen.\u0026#34; ... \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #Liquorクラス(アルコール飲料)、Beverageクラスを継承 \u0026gt;\u0026gt;\u0026gt; class Liquor(Beverage): ... alcohol_content=100 ... def __init__(self,p,n,a): ... self.price=p ... self.name=n ... self.alcohol_content=a ... \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; orange_juice = Beverage(100,\u0026#34;orange juice\u0026#34;) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; screw_driver = Liquor(1000,\u0026#34;screw driver\u0026#34;,15) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #Beverageクラスのprice,nameは参照できる \u0026gt;\u0026gt;\u0026gt; orange_juice.price 100 \u0026gt;\u0026gt;\u0026gt; orange_juice.name \u0026#39;orange juice\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #Beverageクラスはalcohol_contentは持ってないので、参照しようとするとエラーになる \u0026gt;\u0026gt;\u0026gt; orange_juice.alcohol_content Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; AttributeError: \u0026#39;Beverage\u0026#39; object has no attribute \u0026#39;alcohol_content\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #Beverageクラスのhowmuch関数は利用できる \u0026gt;\u0026gt;\u0026gt; orange_juice.howmuch() \u0026#39;This orange juice is 100 yen.\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #LiquorクラスはBeverageクラスを継承しているので、変数price,nameを参照できる。 \u0026gt;\u0026gt;\u0026gt; screw_driver.price 1000 \u0026gt;\u0026gt;\u0026gt; screw_driver.name \u0026#39;screw driver\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #Liquorクラスはalcohol_contentを定義しているので、これも参照できる。 \u0026gt;\u0026gt;\u0026gt; screw_driver.alcohol_content 15 \u0026gt;\u0026gt;\u0026gt; #LiquorクラスはBeverageクラスを継承しているので、関数howmuch()を利用できる。 \u0026gt;\u0026gt;\u0026gt; screw_driver.howmuch() \u0026#39;This screw driver is 1000 yen.\u0026#39; \u0026gt;\u0026gt;\u0026gt;  Javascript  Javascriptではコンストラクタを使って作られたオブジェクトを使った継承が行える。\n例えば以下のようなオブジェクトがあったとする。\nvar Person = function(name){ this.name = name this.introduce = function(){ console.log(\u0026#39;My name is \u0026#39; + this.name) } } var Student = function(name,grade){ this.name = name this.grade = grade }  ここで、StudentオブジェクトにもPersonオブジェクトが持つプロパティを持たせたい（継承）とき、以下のようにする。\nStudent.prototype = new Person();  これにより、StudentオブジェクトにPersonオブジェクトが持つプロパティを持たせることができる。これがjavascriptでの継承の方法である。この後の例を以下に示す。\nvar mary = new Student(\u0026#39;Mary\u0026#39;,1) console.log(mary.introduce())  実行結果\nMy name is Mary    "},{"idx":177,"href":"/docs/programming/machine_learning/linear_basis_function/","title":"線形基底関数モデル","content":" 線形基底関数モデル 先ほどまでの章では、データの予測に直線モデルを利用していたが、勿論直線モデルを利用するのが必ずしも最適ではないという場合もある。\n直線ではなく、曲線となるような関数をモデルにしてみるのはどうだろうか？ここではそれについて述べる。\nと言っても曲線となる関数は色々あるが、今回はその中でも汎用性が高いと言われている線形基底関数モデルを利用する。\n基底関数とは、元となる関数という意味で、先ほどの線形関数(y=w0x+w1)のxを基底関数φ(x)に置き換えたものが線形基底関数モデルになる。\n基底関数には色々種類があるが、ここではガウス関数を基底関数と置いた場合を例にとる。\nその場合の線形基底関数モデルの式は以下のようになる。\n  $$ \\tag{1} y(x, {\\bf w} ) = w_{0} \\phi_{0} (x) + w_{1} \\phi_{1} (x) + w_{2} \\phi_{2} (x) + \\cdots + w_{M} $$ ここでφj(x)はガウス関数で、以下のように表される。\n$$ \\tag{2} \\phi_{j} (x) = \\exp( - \\frac{ ( x - \\mu_{j} )^2 }{ 2 v^2} ) $$ μjはガウス関数φj(x)の中心位置で、vは関数の広がりの程度を示す。\n次に、この線形基底関数モデルの式を行列を用い表現することを考えてみる。\n式(1)において、\n$$ {\\bf w} = \\left[ \\begin{array}{cccc} w_{0} \\\\ w_{1} \\\\ \\vdots \\\\ w_{M} \\end{array} \\right] , {\\bf \\Phi} = \\left[ \\begin{array}{cccc} \\phi_{0} \\\\ \\phi_{1} \\\\ \\vdots \\\\ \\phi_{M} \\end{array} \\right] $$ とおくと、式(1)は以下のように表される。\n$$ \\tag{3} y({\\bf x}, {\\bf w} ) = \\sum_{i=0}^{M} w_{i} \\phi_{i} (x) = {\\bf w} ^\\mathrm{T} {\\bf \\Phi} ( {\\bf x} ) $$ ここで、式(1)を見ても分かるように、第M項目はwMのみであり、　φM(x) は実は存在しない。\n実はφM(x)は先述のN次元線形回帰モデルのところでもあったように、φM(x)は式(3)での行列計算のために入れているダミーの基底関数であり、wMφM(x) が wMになる様にφM(x) = 1　とする。\nこの式(3)を用い、これまでと同様にして平均二乗誤差Jを求めてみよう。\n実測値を{tn}とおくと、平均二乗誤差Jは次の式(4)で表される。\n$$ \\tag{4} J( {\\bf w} ) = \\frac{1}{N} \\sum_{n=0}^{N-1} ( {\\bf w} ^\\mathrm{T} {\\bf \\Phi} ( x_{n} ) - t_{n} ) ^2 $$ この式(4)だが、先述のN次元線形回帰モデルの式(4)に類似している。\n$$ J( {\\bf w} ) = \\frac{1}{N} \\sum_{n=0}^{N-1} ( {\\bf w} ^\\mathrm{T} {\\bf x}_{n} - t_{n} )^2 $$ xnがφn(x)に変わったのみであり、そのため実はこの線形基底関数モデルにおいても、解はムーアーペンローズの擬似逆行列の形になる。\nよって、Jを最小化するwは以下の式のようになる。\n$$ \\tag{5} {\\bf w} = ( {\\bf \\Phi} ^\\mathrm{T} {\\bf \\Phi} )^{-1} {\\bf \\Phi} ^\\mathrm{T} {\\bf t} $$ ただし\n$$ \\tag{6} {\\bf \\Phi} = \\left[ \\begin{array}{cccc} \\phi_{0} (x_{0}) \u0026 \\phi_{1} (x_{0}) \u0026 \\cdots \u0026 \\phi_{M} (x_{0}) \\\\ \\phi_{0} (x_{1}) \u0026 \\phi_{1} (x_{1}) \u0026 \\cdots \u0026 \\phi_{M} (x_{1}) \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ \\phi_{0} (x_{N-1}) \u0026 \\phi_{1} (x_{N-1}) \u0026 \\cdots \u0026 \\phi_{M} (x_{N-1}) \\end{array} \\right] $$ である。この式(6)で表される行列を計画行列と言う。\n基底関数としているガウス関数を多次元入力に対応させると、以下のようになる。\n$$ \\tag{7} {\\bf \\Phi} = \\left[ \\begin{array}{cccc} \\phi_{0} ({\\bf x}_{0}) \u0026 \\phi_{1} ({\\bf x}_{0}) \u0026 \\cdots \u0026 \\phi_{M} ({\\bf x}_{0}) \\\\ \\phi_{0} ({\\bf x}_{1}) \u0026 \\phi_{1} ({\\bf x}_{1}) \u0026 \\cdots \u0026 \\phi_{M} ({\\bf x}_{1}) \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ \\phi_{0} ({\\bf x}_{N-1}) \u0026 \\phi_{1} ({\\bf x}_{N-1}) \u0026 \\cdots \u0026 \\phi_{M} ({\\bf x}_{N-1}) \\end{array} \\right] $$ では、以上の式をコードで実装してみよう。\nまず、ガウス関数とそれを利用した線形基底関数モデルは以下のようになる。(linear_basis_function.py)\nimport numpy as np #ガウス関数 (式(2)) def gauss(x,mu,v): return np.exp(-(x-mu)**2/(2* v**2)) #線形基底関数モデル (式(1)) def linear_basis_func(w,x,mu,v): y=np.zeros_like(x) #xと同じ次数の零行列をyの初期値とする for i in range(len(w)-1): y = y + w[i]*gauss(x,mu[i],v) #y+=wiφi(x) y = y + w[len(w)-1] #y+=wM return y #平均二乗誤差MSE (式(4)) def mse(y,t): return np.mean((y-t)**2) 次に、計画行列を算出するコードを記載する。(linear_basis_function.py)\nimport numpy as np #計画行列算出 (式(7)) def design_matrix(x,t,mu,v): n=x.shape[0] m=len(mu) phi=np.ones((n,m+1)) #計画行列、初期値は全て１にする(最後の１列は全て１になる) for j in range(m): phi[:,j] = gauss(x,mu[j],v) #計画行列のj列目を算出 phi_T=np.transpose(phi) b=np.linalg.inv(phi_T.dot(phi)) #(φ*φ^-1)^-1 c=b.dot(phi_T) #(φ^T*φ^-1)^-1*φ^T w=c.dot(t) #(φ^T*φ^-1)^-1*φ^T*t return w 例として、直線モデルの章で利用したデータに対し、この線形基底関数モデルを適用させてみよう。\nまず元データは以下のような図になる。\n例としてmを1,4,7,10,13,16で設定した時のyを算出し、標準偏差SD(平均二乗誤差の平方根)とともにそれぞれプロットして表示する。\nコードは以下の通り。(linear_basis_function_plot.py)\nimport math import matplotlib.pyplot as plt import numpy as np from linear_basis_function import mse from linear_basis_function import design_matrix from linear_basis_function import linear_basis_func #入力値 x = np.load(\u0026#39;x.npy\u0026#39;) #実測値 t = np.load(\u0026#39;t.npy\u0026#39;) #mを設定 M=[1,5,9,13] plt.figure(figsize=(20,7.5)) plt.subplots_adjust(wspace=0.25,hspace=0.3) for i in range(len(M)): #2*2のi+1番目にプロット plt.subplot(2,2,i+1) m=M[i] #ガウス関数の中心 はxの最小値〜最大値の間で設定 mu=np.linspace(min(x),max(x),m) #w,y算出 w=design_matrix(x,t,mu,1) y=linear_basis_func(w,x,mu,1) #入力値xを(yを対応づけたまま)ソート xy=[[x[i],y[i]] for i in range(len(x))] xy.sort(key=lambda a:a[0]) xi,yi=zip(*xy) #標準偏差SD sd = math.sqrt(mse(y,t)) #プロット plt.scatter(x,t,label=\u0026#39;t\u0026#39;) plt.xlim(min(x)-1,max(x)+1) plt.ylim(min(t)-1,max(t)+1) plt.plot(xi,yi,\u0026#39;-\u0026#39;,color=\u0026#39;red\u0026#39;,label=\u0026#39;y\u0026#39;) plt.legend(loc=\u0026#39;lower right\u0026#39;) plt.title(\u0026#34;M={0:d}, SD={1:.2f}\u0026#34;.format(m,sd)) plt.grid(True) plt.show() 実行結果\nとなり、直線モデルよりも誤差が少なく、汎用性の高い予測式が得られる。\n"},{"idx":178,"href":"/docs/programming/procon/repeated_square/","title":"繰り返し二乗法","content":" 繰り返し二乗法 例えば、210100を計算しようとした時、単純にループで１回ずつ掛け算していくと計算にかなりの時間を要してしまう。\nループで一つずつ計算した場合、xnを求めるための計算量はO(n)となる。\nこの計算量を少しでも減らす方法は無いのだろうか。\nその方法の一つとしてあるのが、繰り返し二乗法である。\nこれは、まずxを２乗してx2を、次にx2を２乗してx4を、さらにx4を２乗してx8を・・を繰り返していくことで、x2iを求める。\n次に、nを2進数で表し、i桁目が1になっているものに対して、x2iを掛け合わせていく。それの最終的な結果が、xnとなる。\nこれにより、計算量はO(log2n)まで削減できる。\nしかし、注意して欲しいのが、いくらこの方法で計算量は削減できると言っても、かなり大きな数を計算しようとした時は、大きな数同士の掛け算を何回かすることにより計算時間がかかってしまうことに変わりはないということである。\n競技プログラミングでは大きな数を計算するときに「1000000007で割った余りを求めよ」と指定されていることが多い。このようにすることで1000000007以下の数字のみ計算に使用することになるので、計算量は通常よりも削減可能になる。そのため、繰り返し二乗法の計算には、途中で剰余を求める計算も組み入れることが多い。\nコード例を以下に示す。\n#x^nを繰り返し二乗法で求める関数 #結果が大きくなるような数を入力すると大きすぎる数を計算しようとしてエラーになりやすい #実際に使うときは、MOD=10000007 などの剰余計算を組み込んで使うこと！ MOD=(10**9)+7 def repeated_square(x,n): #nを2進数で表して順序反転 bit_n=bin(n)[2:][::-1] ans=1 ni=x if(bit_n[0]==\u0026#34;1\u0026#34;): ans*=ni for i in range(1,len(bit_n)): ni=((ni%MOD)*(ni%MOD))%MOD #i桁目が1なら、x^(2^i)を加える if(bit_n[i]==\u0026#34;1\u0026#34;): ans=((ans%MOD)*(ni%MOD))%MOD return ans"},{"idx":179,"href":"/docs/programming/exception/myexception/","title":"自分で例外クラスを定義する","content":" 自分で例外クラスを定義する 基本、例外(エラー)はあらかじめ定義されている、対応する例外を示すクラスが投げられるという形で例外の発生を示すが、\nこの例外を示すクラスをユーザー側で定義し、特定の例外が発生した時にこのクラスを利用することができる。\nここでは、自分でその例外クラスを実装する方法についてを示す。\nJava  JavaではExceptionクラスを継承して作る事で自作の例外クラスを定義できる。\n[修飾子] 自作の例外クラス名 extends Exception { // 文 }  実行例を以下に示す。\nMyException(独自の例外)\npublic class MyException extends Exception{ public MyException(String msg){ super(msg); } } Mainクラス\nclass Main{ public static void main(String args[]){ try{ throw new MyException(\u0026#34;throw MyException\u0026#34;); }catch(MyException e){ System.out.println(e.getMessage()); } } } 実行結果\n\u0026gt; javac .\\MyException.java \u0026gt; javac .\\Main.java \u0026gt; java Main throw MyException   Python  PythonでもExceptionクラスから継承したクラスを作ると、それがユーザー定義の例外クラスになる。\nclass 例外クラス名(Exception): //文 //(def __init__ など書く)  実行例を以下に示す。\n\u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #偶数だと例外発生、中身は無し \u0026gt;\u0026gt;\u0026gt; class EvenError(Exception): ... pass ... \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #入力した数に応じ、偶数ならEvenError、奇数なら\u0026#34;OK!\u0026#34; \u0026gt;\u0026gt;\u0026gt; def inputNum(i): ... if(i%2==0): ... raise EvenError ... else: ... print(\u0026#34;OK!\u0026#34;) ... \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; inputNum(1) OK! \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; inputNum(0) Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 3, in inputNum __main__.EvenError \u0026gt;\u0026gt;\u0026gt;   "},{"idx":180,"href":"/docs/programming/number/loge/","title":"自然対数(底e)","content":" 自然対数(底e) 自然対数を算出する方法についてを示す。\nJava  Javaではjava.lang.Mathクラス内にあるlog()メソッドがこの役割を果たす。\n利用するにはjava.lang.Mathクラスをインポートする。\npublic static double log(double a)\nimport java.lang.Math; class Main{ public static void main(String args[]){ int a = 100; int b = 500; System.out.println(Math.log(a)); System.out.println(Math.log(b)); } } 実行結果\n\u0026gt; java Main 4.605170185988092 6.214608098422191   Python  pythonで自然対数を算出するにはmathモジュールにある関数 log() 関数を使用する。\n使用するにはmathモジュールをインポートする。\n\u0026gt;\u0026gt;\u0026gt; import math \u0026gt;\u0026gt;\u0026gt; a = 100 \u0026gt;\u0026gt;\u0026gt; b = 500 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(math.log(a)) 4.605170185988092 \u0026gt;\u0026gt;\u0026gt; print(math.log(b)) 6.214608098422191 \u0026gt;\u0026gt;\u0026gt;   "},{"idx":181,"href":"/docs/programming/math/matrix/","title":"行列","content":" 行列 行列の定義についてを示す。\nPython  行列(2次元配列)もベクトルと同様、numpyライブラリにある関数array(list)を使って定義する。引数のリストは2次元にする。\ntype()を使って型を確認すると、numpy.ndarray型となっていることがわかる。\n行列の要素を書き換えたいときはリストの時と同様にインデックスを指定して書き換える。インデックスは0から始まる事に注意。\n\u0026gt;\u0026gt;\u0026gt; import numpy as np \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; x = np.array([[1,2,3],[4,5,6]]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; x array([[1, 2, 3], [4, 5, 6]]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(x) [[1 2 3] [4 5 6]] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #行列の要素を書き換える \u0026gt;\u0026gt;\u0026gt; x[1][1] = 100 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(x) [[ 1 2 3] [ 4 100 6]] \u0026gt;\u0026gt;\u0026gt; #x[1][1]が100に書き換わっている \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; type(x) \u0026lt;class \u0026#39;numpy.ndarray\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #xはndarray型 \u0026gt;\u0026gt;\u0026gt;    "},{"idx":182,"href":"/docs/programming/math/reshape/","title":"行列のサイズを変更する","content":" 行列のサイズを変更する 行列のサイズを変更する方法についてを示す。\nPython  行列のサイズを変更したい場合は変数名.reshape(n,m)を使う。\n変更後の行列と変更前の行列の要素数は同じでないといけない（違う場合はエラー）\n実行例を示す。\n\u0026gt;\u0026gt;\u0026gt; import numpy as np \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a = np.arange(10) \u0026gt;\u0026gt;\u0026gt; a array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(a) [0 1 2 3 4 5 6 7 8 9] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a.reshape(2,5) array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a.reshape(3,5) Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; ValueError: cannot reshape array of size 10 into shape (3,5) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt;    "},{"idx":183,"href":"/docs/programming/math/matrix_size-2/","title":"行列の型(サイズ)","content":" 行列の型(サイズ) 行列の型(サイズ)を調べる方法についてを示す。\nPython  行列(2次元配列)のサイズはnumpy.ndarray型の変数.shapeでわかる。\nshapeは関数ではなく、ndarray型変数が持つ属性なので括弧は不要（括弧をつけるとエラー）\n\u0026gt;\u0026gt;\u0026gt; import numpy as np \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; x = np.array([[1,2,3],[4,5,6]]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; x array([[1, 2, 3], [4, 5, 6]]) \u0026gt;\u0026gt;\u0026gt; # 2*3行列 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; x.shape() Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; TypeError: \u0026#39;tuple\u0026#39; object is not callable \u0026gt;\u0026gt;\u0026gt; # 関数ではないので()つけるとエラー \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; x.shape (2, 3) \u0026gt;\u0026gt;\u0026gt; #shapeはタプル型 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; y = np.array([[1],[2],[3]]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; y array([[1], [2], [3]]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; y.shape (3, 1) \u0026gt;\u0026gt;\u0026gt;    "},{"idx":184,"href":"/docs/programming/math/matrix_size/","title":"行列の型(サイズ)","content":" 行列の型(サイズ) 行列の型(サイズ)を調べる方法についてを示す。\nPython  行列(2次元配列)のサイズはnumpy.ndarray型の変数.shapeでわかる。\nshapeは関数ではなく、ndarray型変数が持つ属性なので括弧は不要（括弧をつけるとエラー）\n\u0026gt;\u0026gt;\u0026gt; import numpy as np \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; x = np.array([[1,2,3],[4,5,6]]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; x array([[1, 2, 3], [4, 5, 6]]) \u0026gt;\u0026gt;\u0026gt; # 2*3行列 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; x.shape() Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; TypeError: \u0026#39;tuple\u0026#39; object is not callable \u0026gt;\u0026gt;\u0026gt; # 関数ではないので()つけるとエラー \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; x.shape (2, 3) \u0026gt;\u0026gt;\u0026gt; #shapeはタプル型 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; y = np.array([[1],[2],[3]]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; y array([[1], [2], [3]]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; y.shape (3, 1) \u0026gt;\u0026gt;\u0026gt;    "},{"idx":185,"href":"/docs/programming/math/dot/","title":"行列積(ベクトルの内積)","content":" 行列積(ベクトルの内積) 行列積、ベクトルでいう内積を算出する方法についてを示す。\nPython  行列積を算出したいときは、numpy変数の関数dotを使用すれば良い。\nこの関数はnumpyにも、ndarray型変数にも定義されているのでどちらを利用しても良い。\nnumpy.dot(行列1,行列2)\nまたは\n(行列1).dot(行列2)\n行列1,2が行列積を算出できない組み合わせ(サイズが違うなど)の時はエラーが発生する。\n\u0026gt;\u0026gt;\u0026gt; import numpy as np \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a=np.array([[1,2,3],[4,5,6]]) \u0026gt;\u0026gt;\u0026gt; b=np.array([[1,2],[3,4],[5,6]]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a array([[1, 2, 3], [4, 5, 6]]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; b array([[1, 2], [3, 4], [5, 6]]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; np.dot(a,b) array([[22, 28], [49, 64]]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a.dot(b) array([[22, 28], [49, 64]]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; c=np.array([[1,2],[3,4]]) \u0026gt;\u0026gt;\u0026gt; c array([[1, 2], [3, 4]]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; np.dot(a,c) Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; ValueError: shapes (2,3) and (2,2) not aligned: 3 (dim 1) != 2 (dim 0) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a.dot(c) Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; ValueError: shapes (2,3) and (2,2) not aligned: 3 (dim 1) != 2 (dim 0) \u0026gt;\u0026gt;\u0026gt;    "},{"idx":186,"href":"/docs/programming/number/max/","title":"複数の数字のうち最も大きい数字をとる","content":" 複数の数字のうち最も大きい数字をとる 複数の数値から一番大きい数値を取り出したい時の方法を示す。\nJava  Javaではjava.lang.Mathクラス内にあるmax()メソッドがこの役割を果たす。 利用するにはjava.lang.Mathクラスをインポートする。\npublic static int max(int a,int b)\nまた、int型に限らず、double型、float型、long型などもオーバーロードとして定義されている。 無論だが、いずれの場合も利用するには引数、返り値の型は一致させておく必要がある。 ちなみに、引数は２つしか指定できないので、２値間での最大値しか測れない。 ３つ以上の値で最大値を取りたい場合は、maxメソッドを入れ子にして利用するなどする。 使用例を以下に示す。(クラスはここではMain.javaとする)\nimport java.lang.Math; class Main{ public static void main(String args[]){ int a = 1; int b = 2; int c = 3; System.out.println(Math.max(a,b)); //a,bで大きい値 \tSystem.out.println(Math.max(b,c)); //b,cで大きい値  //a,bで大きい方とcで大きい値 -\u0026gt; a,b,cで最も大きい値 \tSystem.out.println(Math.max(Math.max(a,b),c)); } } 実行後\n$ java Main 2 3 3   Python  Pythonでは組み込み関数のmax()関数を利用する。 javaと違い、こちらは引数の数に制限はないため、比較したい値をいくらでも入力できる。\n\u0026gt;\u0026gt;\u0026gt; a=1 \u0026gt;\u0026gt;\u0026gt; b=2 \u0026gt;\u0026gt;\u0026gt; c=3 \u0026gt;\u0026gt;\u0026gt; max(a,b) 2 \u0026gt;\u0026gt;\u0026gt; max(a,b,c) 3 \u0026gt;\u0026gt;\u0026gt;    "},{"idx":187,"href":"/docs/programming/number/min/","title":"複数の数字のうち最も小さい数字をとる","content":" 複数の数字のうち最も小さい数字をとる 複数の数値から一番小さい数値を取り出したい時の方法を示す。\nJava  Javaではjava.lang.Mathクラス内にあるmin()メソッドがこの役割を果たす。 利用するにはjava.lang.Mathクラスをインポートする。\npublic static int min(int a,int b)\nmax()の時と同様に、int型に限らずdouble型、float型、long型などもオーバーロードとして定義されている。 無論だが、いずれの場合も利用するには引数、返り値の型は一致させておく必要がある。 ちなみに、引数は２つしか指定できないので、２値間での最小値しか測れない。 ３つ以上の値で最小値を取りたい場合は、minメソッドを入れ子にして利用するなどする。 使用例を以下に示す。(クラスはここではMain.javaとする)\nimport java.lang.Math; class Main{ public static void main(String args[]){ int a = 1; int b = 2; int c = 3; System.out.println(Math.min(a,b)); //a,bで小さい値 \tSystem.out.println(Math.min(b,c)); //b,cで小さい値  System.out.println(Math.min(Math.min(a,b),c));//a,bで小さい方とcで小さい値 \t//-\u0026gt; a,b,cで最も小さい値 \t} } 実行後\n$ java Main 1 2 1   Python  Pythonでは組み込み関数のmin()関数を利用する。 javaと違い、こちらは引数の数に制限はないため、比較したい値をいくらでも入力できる。\n\u0026gt;\u0026gt;\u0026gt; a=1 \u0026gt;\u0026gt;\u0026gt; b=2 \u0026gt;\u0026gt;\u0026gt; c=3 \u0026gt;\u0026gt;\u0026gt; min(b,c) 2 \u0026gt;\u0026gt;\u0026gt; min(a,b,c) 1 \u0026gt;\u0026gt;\u0026gt;    "},{"idx":188,"href":"/docs/programming/math/ones/","title":"要素が全て１の行列","content":" 要素が全て１の行列 要素が全て１の行列を生成する方法についてを示す。\nPython  numpyの関数onesを使うと、要素が全て１の行列を生成できる。\n零行列の時と同様、引数に１つの整数を渡した場合は1次元(ベクトル)、行列のサイズ(タプル型)を渡した場合は行列になる。サイズの長さに制限はなく、行列は何次元でも生成可能である。\n\u0026gt;\u0026gt;\u0026gt; import numpy as np \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; np.ones(10) array([1., 1., 1., 1., 1., 1., 1., 1., 1., 1.]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(np.ones(10)) [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; np.ones((4,3)) array([[1., 1., 1.], [1., 1., 1.], [1., 1., 1.], [1., 1., 1.]]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(np.ones((4,3))) [[1. 1. 1.] [1. 1. 1.] [1. 1. 1.] [1. 1. 1.]] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; np.ones((2,2,2)) array([[[1., 1.], [1., 1.]], [[1., 1.], [1., 1.]]]) \u0026gt;\u0026gt;\u0026gt;    "},{"idx":189,"href":"/docs/programming/math/arange-2/","title":"要素が等間隔になるベクトル","content":" 要素が等間隔になるベクトル 指定した範囲内で、全ての要素の感覚が等しくなるようなベクトルを生成する方法についてを示す。\nPython  主に方法は二つある。\n numpy.arange() を利用する  numpyの関数arangeは、始点start、終点stop、間隔stepの等差数列となるようなベクトルを生成する。\nnumpy.arange([start, ]stop, [step, ]dtype=None)\nただし、終点stopは生成されるベクトルに含まれないため、終点に指定した値も含みたい時は終点stopに間隔stepを足した値を終点stopとする。\n始点startのデフォルト値は0、間隔stepのデフォルト値は1であり、指定しなくても良い。\n numpy.linspace() を利用する  numpy.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None, axis=0)\nnumpyの関数linspaceもarangeと似たようなものだが、arangeと違う点は終点stopも生成されるベクトルに含まれる(endpoint=Falseにすると含まれない)ことと、指定するのが間隔ではなく始点~終点間に設定する点の数numという点である。\nlinspaceで生成されるベクトルは、要素間の間隔が全て等しくなるように設定される。\nnumはデフォルトで50、retstep=Trueにすると間隔も返ってくる。\n使用例を以下に示す。\n\u0026gt;\u0026gt;\u0026gt; import numpy as np \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #1以上10未満、間隔1(デフォルト)のベクトル \u0026gt;\u0026gt;\u0026gt; x = np.arange(1,10) \u0026gt;\u0026gt;\u0026gt; x array([1, 2, 3, 4, 5, 6, 7, 8, 9]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #0(デフォルト)以上10未満、間隔1(デフォルト)のベクトル \u0026gt;\u0026gt;\u0026gt; x = np.arange(10) \u0026gt;\u0026gt;\u0026gt; x array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #1以上10未満、間隔2のベクトル \u0026gt;\u0026gt;\u0026gt; x = np.arange(1,10,2) \u0026gt;\u0026gt;\u0026gt; x array([1, 3, 5, 7, 9]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #linspace \u0026gt;\u0026gt;\u0026gt; #1以上10以下、要素数10 \u0026gt;\u0026gt;\u0026gt; x = np.linspace(1,10,10) \u0026gt;\u0026gt;\u0026gt; x array([ 1., 2., 3., 4., 5., 6., 7., 8., 9., 10.]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #1以上10以下、要素数2 \u0026gt;\u0026gt;\u0026gt; x = np.linspace(1,10,2) \u0026gt;\u0026gt;\u0026gt; x array([ 1., 10.]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #1以上10以下、要素数5 \u0026gt;\u0026gt;\u0026gt; x = np.linspace(1,10,5) \u0026gt;\u0026gt;\u0026gt; x array([ 1. , 3.25, 5.5 , 7.75, 10. ]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #1以上10未満、要素数2 \u0026gt;\u0026gt;\u0026gt; x = np.linspace(1,10,2,endpoint=False) \u0026gt;\u0026gt;\u0026gt; x array([1. , 5.5]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #1以上10以下、要素数2 に加え間隔も返る \u0026gt;\u0026gt;\u0026gt; x = np.linspace(1,10,2,retstep=True) \u0026gt;\u0026gt;\u0026gt; x (array([ 1., 10.]), 9.0) \u0026gt;\u0026gt;\u0026gt; #タプル型でベクトル、間隔が返ってくる これらarange,linspaceは、matplotlib等で使うグラフの描画のところでよく使われる。\nグラフ描画では終点stopも含まれるlinspaceの方がよく多用される（と考えている）。\n  "},{"idx":190,"href":"/docs/programming/math/arange/","title":"要素が等間隔になるベクトル","content":" 要素が等間隔になるベクトル 指定した範囲内で、全ての要素の感覚が等しくなるようなベクトルを生成する方法についてを示す。\nPython  主に方法は二つある。\n numpy.arange() を利用する  numpyの関数arangeは、始点start、終点stop、間隔stepの等差数列となるようなベクトルを生成する。\nnumpy.arange([start, ]stop, [step, ]dtype=None)\nただし、終点stopは生成されるベクトルに含まれないため、終点に指定した値も含みたい時は終点stopに間隔stepを足した値を終点stopとする。\n始点startのデフォルト値は0、間隔stepのデフォルト値は1であり、指定しなくても良い。\n numpy.linspace() を利用する  numpy.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None, axis=0)\nnumpyの関数linspaceもarangeと似たようなものだが、arangeと違う点は終点stopも生成されるベクトルに含まれる(endpoint=Falseにすると含まれない)ことと、指定するのが間隔ではなく始点~終点間に設定する点の数numという点である。\nlinspaceで生成されるベクトルは、要素間の間隔が全て等しくなるように設定される。\nnumはデフォルトで50、retstep=Trueにすると間隔も返ってくる。\n使用例を以下に示す。\n\u0026gt;\u0026gt;\u0026gt; import numpy as np \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #1以上10未満、間隔1(デフォルト)のベクトル \u0026gt;\u0026gt;\u0026gt; x = np.arange(1,10) \u0026gt;\u0026gt;\u0026gt; x array([1, 2, 3, 4, 5, 6, 7, 8, 9]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #0(デフォルト)以上10未満、間隔1(デフォルト)のベクトル \u0026gt;\u0026gt;\u0026gt; x = np.arange(10) \u0026gt;\u0026gt;\u0026gt; x array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #1以上10未満、間隔2のベクトル \u0026gt;\u0026gt;\u0026gt; x = np.arange(1,10,2) \u0026gt;\u0026gt;\u0026gt; x array([1, 3, 5, 7, 9]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #linspace \u0026gt;\u0026gt;\u0026gt; #1以上10以下、要素数10 \u0026gt;\u0026gt;\u0026gt; x = np.linspace(1,10,10) \u0026gt;\u0026gt;\u0026gt; x array([ 1., 2., 3., 4., 5., 6., 7., 8., 9., 10.]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #1以上10以下、要素数2 \u0026gt;\u0026gt;\u0026gt; x = np.linspace(1,10,2) \u0026gt;\u0026gt;\u0026gt; x array([ 1., 10.]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #1以上10以下、要素数5 \u0026gt;\u0026gt;\u0026gt; x = np.linspace(1,10,5) \u0026gt;\u0026gt;\u0026gt; x array([ 1. , 3.25, 5.5 , 7.75, 10. ]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #1以上10未満、要素数2 \u0026gt;\u0026gt;\u0026gt; x = np.linspace(1,10,2,endpoint=False) \u0026gt;\u0026gt;\u0026gt; x array([1. , 5.5]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #1以上10以下、要素数2 に加え間隔も返る \u0026gt;\u0026gt;\u0026gt; x = np.linspace(1,10,2,retstep=True) \u0026gt;\u0026gt;\u0026gt; x (array([ 1., 10.]), 9.0) \u0026gt;\u0026gt;\u0026gt; #タプル型でベクトル、間隔が返ってくる これらarange,linspaceは、matplotlib等で使うグラフの描画のところでよく使われる。\nグラフ描画では終点stopも含まれるlinspaceの方がよく多用される（と考えている）。\n  "},{"idx":191,"href":"/docs/front-end/element/","title":"要素とタグ","content":" 要素とタグ HTMLは、各コンテンツの内容をタグで囲い、それが文書の内の何であるかを示す言語である。\nHTML文書内の各構成要素の事を要素(elements)、\n要素の前につけるタグを開始タグ、後につけるタグを終了タグという。\n終了タグのタグ名の頭にはスラッシュ(/)が入る。\n(例)\n \u0026lt;h1\u0026gt;HTMLの要素\u0026lt;/h1\u0026gt; \n空要素 要素の中には、内容（コンテンツ）が無く、開始タグのみで成立するものもある。このような要素を空要素という。 例としては、改行を表す\u0026lt;br\u0026gt;がある。 空要素には終了タグを指定できないので注意。また空要素のタグの\u0026gt;の直前にはスラッシュ(/)を入れられる。\n(例)\n\u0026lt;br/\u0026gt;\n属性 要素には開始タグのタグ名の後に属性を指定することができる。書式は (属性名)=(値) であり、スペースで区切って指定する。属性はいくらでも指定することができる。\n(例)\n\u0026lt;img src=\u0026quot;test.png\u0026quot;\u0026gt;  "},{"idx":192,"href":"/docs/front-end/elements_type/","title":"要素の種類","content":" 要素の種類 先程述べた要素には色々な種類がある。\n大きく分けると以下の7種類。\n フローコンテンツ  見出しコンテンツ セクショニングコンテンツ フレージングコンテンツ 読み込みコンテンツ インタラクティブコンテンツ メタデータコンテンツ   "},{"idx":193,"href":"/docs/programming/machine_learning/analytical_solution/","title":"解析解","content":" 解析解 先程の直線モデルの例では勾配法を用いてw0、w1の値を求めたが、実は勾配法を用いなくても数式を計算していけば最適なw0、w1が求められる場合がある。\n勾配法のような数値計算法で求められた近似的な解は数値解といい、方程式を解くことによって求められた厳密な解は解析解という。\n先程の勾配法の章において、平均二乗誤差Jが極小になる時がw0、w1の求める値なので、この条件式からw0、w1の解析解を求めていく。\n  $$ \\begin{aligned} \\frac{\\partial J}{\\partial w_{0} } \u0026= \\frac{2}{N} \\sum_{n=0}^{N-1} (w_{0} x_{n} + w_{1} - t_{n}) x_{n} \u0026= 0 \\\\ \\frac{\\partial J}{\\partial w_{1} } \u0026= \\frac{2}{N} \\sum_{n=0}^{N-1} (w_{0} x_{n} + w_{1} - t_{n}) \u0026= 0 \\end{aligned} $$ この2式は以下のように展開できる。\n$$ \\begin{aligned} \u0026w_{0} \\frac{1}{N} \\sum_{n=0}^{N-1} x_{n}^2 + w_{1} \\frac{1}{N} \\sum_{n=0}^{N-1} x_{n} - \\frac{1}{N} \\sum_{n=0}^{N-1} t_{n} x_{n} = 0 \\\\ \u0026w_{0} \\frac{1}{N} \\sum_{n=0}^{N-1} x_{n} + w_{1} - \\frac{1}{N} \\sum_{n=0}^{N-1} t_{n} = 0 \\end{aligned} $$ この時、   1 N   \u0026Sum;  n = 0  N-1   x n   はxnの平均値を表す。\nここで、avg(x)をxの平均値を算出する関数とおくと、上式は以下のように置き換えられる。\n$$ \\begin{aligned} \u0026w_{0} avg(x_{n} ^2) + w_{1} avg(x_{n}) - avg(t_{n} x_{n}) = 0 \\\\ \u0026w_{0} avg(x_{n}) + w_{1} - avg(t_{n}) = 0 \\end{aligned} $$ これらの式をw0、w1についてそれぞれ解くと、w0、w1は以下のように表される。\n$$ \\begin{aligned} w_{0} \u0026= \\frac{ avg(t_{n} x_{n}) - avg(t_{n}) avg(x_{n}) }{avg(x_{n} ^2) - avg(x_{n})^2} \\\\ w_{1} \u0026= avg(t_{n}) - w_{0} avg(x_{n}) \\\\ \u0026= avg(t_{n}) - \\frac{ avg(t_{n} x_{n}) - avg(t_{n}) avg(x_{n}) }{avg(x_{n} ^2) - avg(x_{n})^2} avg(x_{n}) \\end{aligned} $$ では、実際にx、tを代入してw0、w1を求めてみよう。(x,tは前章のnpyファイルから取得)\nimport numpy as np def d_mse(w,x,t): y = w[0] * x + w[1] d_w0 = 2 * np.mean((y-t)*x) d_w1 = 2 * np.mean(y-t) return d_w0,d_w1 #入力値 x = np.load(\u0026#39;x.npy\u0026#39;) #実測値 t = np.load(\u0026#39;t.npy\u0026#39;) #t*x tx = [t[i]*x[i] for i in range(len(x))] #x^2 xx = [x[i]*x[i] for i in range(len(x))] #w0 w0 = (np.mean(tx) - np.mean(t)*np.mean(x))/(np.mean(xx) - np.mean(x)*np.mean(x)) #w1 w1 = np.mean(t) - w0*np.mean(x) print(\u0026#34;w0 = {0:.9f}\u0026#34;.format(w0)) print(\u0026#34;w1 = {0:.9f}\u0026#34;.format(w1)) dJ=d_mse([w0,w1],x,t) print(\u0026#34;dJ(w0,w1) = [{0:.9f} {1:.9f}]\u0026#34;.format(dJ[0],dJ[1])) 実行結果\nw0 = 0.906006875 w1 = -92.445073277 dJ(w0,w1) = [-0.000000000 -0.000000000]  となり、閾値を設定して求めた前述の勾配法よりもより詳細な値が求められる。\nでは、当初の目的であったこの求めたw0,w1を使った直線モデルの式を求めてみる。\nimport numpy as np import matplotlib.pyplot as plt x = np.load(\u0026#39;x.npy\u0026#39;) t = np.load(\u0026#39;t.npy\u0026#39;) def f(x): return (0.906006875 * x) - 92.445073277 y = f(x) plt.scatter(x,t) x=np.append(x,0) y=np.append(y,f(0)) x=np.append(x,200) y=np.append(y,f(200)) plt.plot(x,y,color=\u0026#39;red\u0026#39;) plt.xlim(160,180) plt.ylim(50,75) plt.grid(True) plt.show() 実行結果\n(最初になんとなく求めたのとそこまで変わらない気がするが、)\nこれでこの入力データにおいて、直線モデルでの最も誤差が少ない最適な式が求められる。\n"},{"idx":194,"href":"/docs/programming/machine_learning/back_propagation/","title":"誤差逆伝搬法","content":" 誤差逆伝搬法（バックプロパゲーション） 誤差逆伝搬法（バックプロパゲーション）はフィードフォワードネットワークモデルに学習をさせる方法として有名な方法であり、これはネットワークの出力と目標値との誤差の情報を使って、出力層、中間層へと重みを更新していくことから、この名がついている。しかし、実態は勾配法そのものである。\nまずは、前章のn1つ分に対する交差エントロピー誤差Enを以下のように考える。\n  $$ \\tag{1} E_{n} ( { \\bf w } ,{ \\bf v } ) = - \\sum_{n=0}^{N-1} \\sum_{k=0}^{K-1} t_{nk} \\log (y_{nk}) $$ これを利用して、以下のように置き換える。\n$$ \\tag{2} E ( { \\bf w } ,{ \\bf v } ) = - \\frac{1}{N} \\sum_{n=0}^{N-1} \\sum_{k=0}^{K-1} E_{n} ( { \\bf w } ,{ \\bf v } ) $$ ここから、重み行列の各パラメータに対する偏微分を行なっていこう。誤差関数をwjiで偏微分すると、以下のようになる。\n$$ \\tag{3} \\begin{aligned} \\frac{\\partial E}{ \\partial w_{ji} } \u0026= - \\frac{\\partial }{ \\partial w_{ji} } \\frac{1}{N} \\sum_{n=0}^{N-1} E_{n} \\\\ \u0026= \\frac{1}{N} \\sum_{n=0}^{N-1} \\frac{\\partial E_{n} }{ \\partial w_{ji} } \\end{aligned} $$ また、パラメータにはvもあるので、vkjに対しても偏微分を行う。すると、式(3)と同じようになる。\nこの式に出てくる、∂En/∂wjiと∂En/∂vkjを求めてみることを考える。まずは、∂En/∂vkjを見てみよう。\n偏微分の連鎖律を使って、∂En/∂vkjは以下のように置き換えられる。\n$$ \\tag{4} \\frac{ \\partial E_{n} }{ \\partial v_{kj} } = \\frac{\\partial E_{n} }{\\partial a_{k}} \\frac{\\partial a_{k} }{\\partial v_{kj} } $$ この式(4)において、まずは例として出力値の数を3(K=3),k=0の場合を見てみる。\nすると、∂En/∂a0は、Eを変形して以下のように置き換えられる。\n$$ \\tag{5} \\frac{ \\partial E_{n} }{ \\partial a_{0} } = \\frac{\\partial }{\\partial a_{0}} ( -t_{0} \\log y_{0} -t_{1} \\log y_{1} -t_{2} \\log y_{2} ) $$ ここで、tiは目標データなのでskで変化することはないが、yiは入力総和a0から算出されるので、関係している。\nこれにより式(16)は以下のように置き換えられる。\n$$ \\tag{6} \\frac{ \\partial E_{n} }{ \\partial a_{0} } = -t_{0} \\frac{1}{y_{0}} \\frac{\\partial y_{0}}{\\partial a_{0}} -t_{1} \\frac{1}{y_{1}} \\frac{\\partial y_{1}}{\\partial a_{0}} -t_{2} \\frac{1}{y_{2}} \\frac{\\partial y_{2}}{\\partial a_{0}} $$ u=exp(a0)+exp(a1)+exp(a2)とおいて計算すると\n$$ \\tag{7} \\begin{aligned} \\frac{\\partial y_{0}}{\\partial a_{0}} \u0026= \\frac{\\partial }{ \\partial a_{0} } \\frac{ \\exp (a_{0}) }{u} \\\\ \u0026= \\frac{ \\exp (a_{0}) u - \\exp (a_{0}) \\exp (a_{0}) }{ u^2 } \\\\ \u0026= \\frac{\\exp (a_{0})}{u} ( \\frac{u - \\exp (a_{0})}{u} ) \\\\ \u0026= \\frac{\\exp (a_{0})}{u} ( 1- \\frac{\\exp (a_{0})}{u} ) \\\\ \u0026= y_{0} (1 - y_{0}) \\end{aligned} $$ また、i≠0の時は\n$$ \\tag{8} \\begin{aligned} \\frac{\\partial y_{i}}{\\partial a_{0}} \u0026= \\frac{\\partial }{ \\partial a_{0} } \\frac{ \\exp (a_{i}) }{u} \\\\ \u0026= \\frac{ 0* u - \\exp (a_{i}) \\exp (a_{0}) }{ u^2 } \\\\ \u0026= \\frac{ - \\exp (a_{i}) \\exp (a_{0}) }{ u^2 } \\\\ \u0026= - \\frac{\\exp (a_{i})}{u} \\frac{\\exp (a_{0})}{u} \\\\ \u0026= - y_{i} y_{0} \\end{aligned} $$ となる。これら式(7)(8)を使うと、式(6)は\n$$ \\begin{aligned} \\tag{9} \\frac{ \\partial E_{n} }{ \\partial a_{0} } \u0026= -t_{0} (1-y_{0}) +t_{1} y_{0} +t_{2} y_{0} \\\\ \u0026= ( t_{0} + t_{1} + t_{2} )y_{0} - t_{0} \\\\ \u0026= y_{0} - t_{0} \\end{aligned} $$ のように置き換えられる。同様にして\n$$ \\tag{10} \\frac{ \\partial E_{n} }{ \\partial a_{1} } = y_{1} - t_{1} $$ $$ \\tag{11} \\frac{ \\partial E_{n} }{ \\partial a_{2} } = y_{2} - t_{2} $$ となる、これから\n$$ \\tag{12} \\frac{ \\partial E_{n} }{ \\partial a_{k} } = y_{k} - t_{k} $$ と表せる。\nでは次に、式(4)の右部分である∂ak/∂vkjを見てみよう。同じくまずは例として出力値の数を3(K=3),k=0の場合を見てみる。すると、a0は以下のようになる。\n$$ \\tag{13} a_{0}= v_{00} z_{0} + v_{01} z_{1} + v_{02} z_{2} $$ ので、この式(13)から以下の式が成り立つ。\n$$ \\tag{14} \\frac{ \\partial a_{0} }{ \\partial v_{0i} } = z_{i} $$ k=1,2\u0026hellip;の場合でも同様の結果が得られるので、式(14)は以下の式のようにも置き換えられる。\n$$ \\tag{15} \\frac{ \\partial a_{k} }{ \\partial v_{ki} } = z_{i} $$ では、この結果を式(15)と合わせてみよう。すると、以下のようになる。\n$$ \\begin{aligned} \\tag{16} \\frac{ \\partial E_{n} }{ \\partial v_{kj} } \u0026= \\frac{\\partial E_{n} }{\\partial a_{k}} \\frac{\\partial a_{k} }{\\partial v_{kj} } \\\\ \u0026= (y_{k} - t_{k})z_{j} \\end{aligned} $$ この式(16)を利用して、勾配法でパラメータvkjを更新していくための漸化式を以下のように定める。\n$$ \\tag{17} v_{kj}(t+1) = v_{kj}(t) - \\alpha \\frac{\\partial E_{n} }{\\partial v_{kj} } = v_{kj}(t) - \\alpha (y_{k} - t_{k})z_{j} $$ ここで、αは0~1の値を取る実数である。\n以上より、∂E/∂vkjが求められた。\n次に、もう一つの重み行列であるwのパラメータwjiの偏微分を求めてみよう。\nこちらも先ほどと同様に、連鎖律を使って以下のように求めていく。ここで、シグモイド関数をh(x)とおく。\n$$ \\tag{18} \\begin{aligned} \\frac{ \\partial E_{n} }{ \\partial w_{ji} } \u0026= \\frac{\\partial E_{n} }{\\partial b_{j}} \\cdot \\frac{\\partial b_{j} }{\\partial w_{ji} } \\\\ \u0026= ( \\sum_{k=0}^{K-1} \\frac{\\partial E_{n} }{\\partial a_{k}} \\cdot \\frac{\\partial a_{k} }{\\partial z_{j}} ) \\frac{\\partial z_{j} }{\\partial b_{j} } \\cdot \\frac{\\partial }{\\partial w_{ji}} \\sum_{i=0}^{D} w_{ji} x_{i} \\\\ \u0026= ( \\sum_{k=0}^{K-1} (y_{k}-t_{k}) \\cdot \\frac{\\partial }{\\partial z_{j}} \\sum_{j=0}^{M} v_{kj} z_{j} ) \\frac{\\partial }{\\partial b_{j} } h(b_{j}) \\cdot x_{i} \\\\ \u0026= ( \\sum_{k=0}^{K-1} (y_{k}-t_{k}) \\cdot v_{kj} ) h'(b_{j}) \\cdot x_{i} \\\\ \\end{aligned} $$ この式(18)において、入力層の重み行列wの偏微分は、先述の中間層の重み行列vのパラメータ及び偏微分の結果を利用して算出している形になっていることがわかる。つまり、出力結果で生じた誤差を逆方向に伝達させて計算しているともみることができる。\nこの性質から、フィードフォワードニューラルネットワークモデルの勾配法が、誤差逆伝搬法（バックプロパゲーション）とも呼ばれている。\n長くなったが、誤差逆伝搬法の一連の手順を以下にまとめる。\n 入力値、重み行列から出力値を算出する 中間層の出力z,出力層の出力y,目標データtから、新しい重み行列vの値を算出する（まだ更新はしない） 入力データx,中間層の入力総和b,重み行列v,出力層の出力y,目標データtから、新しい重み行列wの値を算出する（まだ更新はしない） 算出した新しい重み行列v,wのパラメータを更新する  この手順を繰り返すことで、誤差逆伝搬法を行なっていく。\nでは、コードを書いて学習させてみよう。こちらのJupyter Notebookに誤差逆伝搬法のコードを記載する。\nNotebookの結果より、誤差逆伝搬法は数値微分法よりも計算速度が速くなることが解る。\n"},{"idx":195,"href":"/docs/programming/number/or_bit/","title":"論理和(OR)","content":" 論理和(OR) ORのビット演算をする方法についてを示す。\nJava  JavaではORのビット演算子 | を使用する。論理演算の時とは違い、こちらは|1個なので注意。数値型リテラルでも、boolean型でも入力可。\n(左辺) | (右辺)\nclass Main{ public static void main(String args[]){ boolean a = true; boolean b = false; int c = 3; //0011  int d = 5; //0101  System.out.println(a | a); System.out.println(a | b); System.out.println(b | b); System.out.println(c | c); //0011 -\u0026gt; 3  System.out.println(c | d); //0111 -\u0026gt; 7  System.out.println(d | d); //0101 -\u0026gt; 5  } } 実行結果\n\u0026gt; java Main true true false 3 7 5   Python  ビット演算に関してはpythonもjavaと同じで | を使用する。\n\u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a = True \u0026gt;\u0026gt;\u0026gt; b = False \u0026gt;\u0026gt;\u0026gt; c = 3 \u0026gt;\u0026gt;\u0026gt; d = 5 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(a | a) True \u0026gt;\u0026gt;\u0026gt; print(a | b) True \u0026gt;\u0026gt;\u0026gt; print(b | b) False \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(c | c) 3 \u0026gt;\u0026gt;\u0026gt; print(c | d) 7 \u0026gt;\u0026gt;\u0026gt; print(d | d) 5 \u0026gt;\u0026gt;\u0026gt;   "},{"idx":196,"href":"/docs/programming/number/logical_operator/","title":"論理演算","content":" 論理演算 論理演算を行う際に利用する演算子についてを述べる。\nAND演算 AND演算は入力した２値が両方とも真であった時に真を返し、それ以外は偽を返す演算方法である。\nそれぞれの言語における方法を示す。\nJava  JavaではANDの論理演算子 \u0026amp;\u0026amp; を使用する。戻り値はboolean型。\n(左辺) \u0026amp;\u0026amp; (右辺)\nちなみに、左辺がfalseだった場合は右辺の計算は行わずにfalseを出力する。\nclass Main{ public static void main(String args[]){ boolean a = true; boolean b = false; System.out.println(a \u0026amp;\u0026amp; a); System.out.println(a \u0026amp;\u0026amp; b); System.out.println(b \u0026amp;\u0026amp; b); } } 実行結果\n\u0026gt; java Main true false false   Python  pythonでAND演算を行うには単純に and を使用する。\n\u0026gt;\u0026gt;\u0026gt; a = True \u0026gt;\u0026gt;\u0026gt; b = False \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(a and b) False \u0026gt;\u0026gt;\u0026gt; print(a and a) True \u0026gt;\u0026gt;\u0026gt;  Javascript  Javascriptでは、Javaと同じく論理演算子 \u0026amp;\u0026amp; があるのでこれを使用する。戻り値はboolean型。\n(左辺) \u0026amp;\u0026amp; (右辺)     OR演算 OR演算は入力した２値が両方とも偽であった時に偽を返し、それ以外は真を返す演算方法である。\n各言語における方法を示す。\nJava  JavaではORの論理演算子 || を使用する。戻り値はboolean型。\n(左辺) || (右辺)\nちなみに、左辺がtrueだった場合は右辺の計算は行わずにtrueを出力する。\nclass Main{ public static void main(String args[]){ boolean a = true; boolean b = false; System.out.println(a || a); System.out.println(a || b); System.out.println(b || b); } } 実行結果\n\u0026gt; java Main true true false   Python  pythonでOR演算を行うには単純に or を使用する。\n\u0026gt;\u0026gt;\u0026gt; a = True \u0026gt;\u0026gt;\u0026gt; b = False \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(a or b) True \u0026gt;\u0026gt;\u0026gt; print(b or b) False \u0026gt;\u0026gt;\u0026gt;  Javascript  Javascriptでは、Javaと同じく論理演算子 || があるのでこれを使用する。戻り値はboolean型。\n(左辺) || (右辺)    "},{"idx":197,"href":"/docs/programming/number/and_bit/","title":"論理積(AND)","content":" 論理積(AND) ANDのビット演算をする方法についてを示す。\nJava  JavaではANDのビット演算子 \u0026amp; を使用する。論理演算の時とは違い、こちらは\u0026amp;1個なので注意。数値型リテラルでも、boolean型でも入力可。\n(左辺) \u0026amp; (右辺)\nclass Main{ public static void main(String args[]){ boolean a = true; boolean b = false; int c = 3; //0011  int d = 5; //0101  System.out.println(a \u0026amp; a); System.out.println(a \u0026amp; b); System.out.println(b \u0026amp; b); System.out.println(c \u0026amp; c); //0011 -\u0026gt; 3  System.out.println(c \u0026amp; d); //0001 -\u0026gt; 1  System.out.println(d \u0026amp; d); //0101 -\u0026gt; 5  } } 実行結果\n\u0026gt; java Main true false false 3 1 5   Python  ビット演算に関してはpythonもjavaと同じで \u0026amp; を使用する。\n\u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a = True \u0026gt;\u0026gt;\u0026gt; b = False \u0026gt;\u0026gt;\u0026gt; c = 3 \u0026gt;\u0026gt;\u0026gt; d = 5 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(a \u0026amp; a) True \u0026gt;\u0026gt;\u0026gt; print(a \u0026amp; b) False \u0026gt;\u0026gt;\u0026gt; print(b \u0026amp; b) False \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(c \u0026amp; c) 3 \u0026gt;\u0026gt;\u0026gt; print(c \u0026amp; d) 1 \u0026gt;\u0026gt;\u0026gt; print(d \u0026amp; d) 5 \u0026gt;\u0026gt;\u0026gt;   "},{"idx":198,"href":"/docs/programming/math/transpose/","title":"転置行列","content":" 転置行列 転置行列を算出する方法についてを示す。\nPython  転置行列を算出したい時は、(ndarray型の変数).Tで行う。\n\u0026gt;\u0026gt;\u0026gt; import numpy as np \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a = np.array([[1, 2]]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(a) [[1 2]] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(a.T) [[1] [2]] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; b = np.array([[1,2,3],[4,5,6]]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(b) [[1 2 3] [4 5 6]] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(b.T) [[1 4] [2 5] [3 6]] \u0026gt;\u0026gt;\u0026gt;    "},{"idx":199,"href":"/docs/programming/graph/label/","title":"軸にラベルを設定する","content":" 軸にラベルを設定する Python  グラフの軸にラベルを設定、表示するにはpyplotの関数xlabel(\u0026lsquo;ラベル名\u0026rsquo;)、ylabel(\u0026lsquo;ラベル名\u0026rsquo;)を利用する。\n例として、前述のグラフに色をつけるで作成したグラフの軸にラベルを設定する例を示す。\n\u0026gt;\u0026gt;\u0026gt; import numpy as np \u0026gt;\u0026gt;\u0026gt; import matplotlib.pyplot as plt \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; def f(x,w): ... return (x-w)*x*(x+w) ... \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; x = np.linspace(-3,3,61) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #y:f(x) = x**3、w=0という凡例をつける \u0026gt;\u0026gt;\u0026gt; y = f(x,0) \u0026gt;\u0026gt;\u0026gt; plt.plot(x,y,color=\u0026#39;black\u0026#39;,label=\u0026#39;$w=0$\u0026#39;) [\u0026lt;matplotlib.lines.Line2D object at 0x118e0b748\u0026gt;] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #y2:f(x) = (x-2)x(x+2)、w=2という凡例をつける \u0026gt;\u0026gt;\u0026gt; y2 = f(x,2) \u0026gt;\u0026gt;\u0026gt; plt.plot(x,y2,color=\u0026#39;red\u0026#39;,label=\u0026#39;$w=2$\u0026#39;) [\u0026lt;matplotlib.lines.Line2D object at 0x118e0bb38\u0026gt;] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #凡例表示 \u0026gt;\u0026gt;\u0026gt; plt.legend(loc=\u0026#34;best\u0026#34;) \u0026lt;matplotlib.legend.Legend object at 0x1165a8048\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #x軸にラベル表示 \u0026gt;\u0026gt;\u0026gt; plt.xlabel(\u0026#39;x\u0026#39;) Text(0.5, 0, \u0026#39;x\u0026#39;) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #y軸にラベル表示 \u0026gt;\u0026gt;\u0026gt; plt.ylabel(\u0026#39;y\u0026#39;) Text(0, 0.5, \u0026#39;y\u0026#39;) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #グラフ表示 \u0026gt;\u0026gt;\u0026gt; plt.show() \u0026gt;\u0026gt;\u0026gt;  実行結果\n  "},{"idx":200,"href":"/docs/programming/map/map/","title":"辞書(Map)","content":" 辞書(Map) 辞書(Map)とは何か？\n辞書(Map)とは \u0026ldquo;キー\u0026rdquo; と \u0026ldquo;値\u0026rdquo; の２つの要素からなるデータ構造で、キーを指定した時、辞書(Map)内でそのキーに対応づけられている値が返ってくるというデータ構造である。\nまたこの定義上、キーは辞書(Map)内では一意でないといけない（キーが重複してはならない）。ただし、値の方は一意になってなくても良い（重複しても良い）\n定義の方法をそれぞれの言語で示す。\nJava  Javaではjava.util.Mapをインポートして利用する。\nただし、このMapクラスはインタフェースなので、利用するには具体的な実装がある別のMapのクラスをインポートして利用する。\n特に指定無い場合はjava.util.HashMapを使う。\nimport java.util.Map; import java.util.HashMap; class Main{ public static void main(String args[]){ Map\u0026lt;String,String\u0026gt; m = new HashMap\u0026lt;\u0026gt;(); } } 実際にこのMap内にキー・要素を入れる方法については別項に記載する。\n Python  Pythonでは辞書という名前で呼ばれ、{} のカッコ内で囲まれたものが辞書となる。\n{キー: 値}\n\u0026gt;\u0026gt;\u0026gt; a={} \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a {} \u0026gt;\u0026gt;\u0026gt;  実際にこの辞書内にキー・要素を入れる方法については別項に記載する。\n  "},{"idx":201,"href":"/docs/programming/map/keylist/","title":"辞書(Map)からキーのリストを取得","content":" 辞書(Map)からキーのリストを取得 辞書(Map)からキーのリストを取得する方法についてを示す。\nJava  JavaではMapクラスにkeySet()というメソッドがある。これによりMapのキーをSetで取得することができる。\nSet\u0026lt;K\u0026gt; keySet()\nListに変換したい時はListの変数の初期化時にこのSetを指定してやればよい。\n実行例を以下に示す。\nimport java.util.Set; import java.util.Map; import java.util.HashMap; import java.util.List; import java.util.ArrayList; class Main{ public static void main(String args[]){ Map\u0026lt;String,String\u0026gt; m = new HashMap\u0026lt;\u0026gt;(); m.put(\u0026#34;key\u0026#34;,\u0026#34;value\u0026#34;); m.put(\u0026#34;key2\u0026#34;,\u0026#34;value2\u0026#34;); m.put(\u0026#34;key3\u0026#34;,\u0026#34;value3\u0026#34;); System.out.println(m); Set\u0026lt;String\u0026gt; key = m.keySet(); List\u0026lt;String\u0026gt; keylist = new ArrayList\u0026lt;\u0026gt;(key); System.out.println(keylist); } } 実行結果\n\u0026gt; java Main {key2=value2, key3=value3, key=value} [key2, key3, key]   Python  Pythonは辞書の関数にkeys()という関数があり、これを利用することで辞書のキーのイテラブルオブジェクトを取得できる。\nただし、このkeys関数で返されるオブジェクトはリストではなくdict_keys型なので注意。リストに変換したい場合はlist()を使って変換する。\nfor文でループさせたい時は for i in 辞書.keys() のようにすればよい。\n実行例を以下に示す。\n\u0026gt;\u0026gt;\u0026gt; d={\u0026#39;key\u0026#39;:\u0026#39;value\u0026#39;, \u0026#39;key2\u0026#39;:\u0026#39;value2\u0026#39;, \u0026#39;key3\u0026#39;:\u0026#39;value3\u0026#39;} \u0026gt;\u0026gt;\u0026gt; d {\u0026#39;key\u0026#39;: \u0026#39;value\u0026#39;, \u0026#39;key2\u0026#39;: \u0026#39;value2\u0026#39;, \u0026#39;key3\u0026#39;: \u0026#39;value3\u0026#39;} \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; keylist=d.keys() \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; keylist dict_keys([\u0026#39;key\u0026#39;, \u0026#39;key2\u0026#39;, \u0026#39;key3\u0026#39;]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; list(keylist) [\u0026#39;key\u0026#39;, \u0026#39;key2\u0026#39;, \u0026#39;key3\u0026#39;] \u0026gt;\u0026gt;\u0026gt;   "},{"idx":202,"href":"/docs/programming/map/get/","title":"辞書(Map)からキーを指定して値を取得","content":" 辞書(Map)からキーを指定して値を取得 辞書(Map)からキーを指定して値を取得する方法についてを示す。\nJava  JavaではMapクラスにget()というメソッドがあり、引数にキーを指定すると、Map内でそのキーに対応づけられている値が返る。\nV get(Object key)\n指定したキーがMapに無い場合はnullが返る。\n実行例を以下に示す。\nimport java.util.Map; import java.util.HashMap; class Main{ public static void main(String args[]){ Map\u0026lt;String,String\u0026gt; m = new HashMap\u0026lt;\u0026gt;(); m.put(\u0026#34;key\u0026#34;,\u0026#34;value\u0026#34;); m.put(\u0026#34;key2\u0026#34;,\u0026#34;value\u0026#34;); m.put(\u0026#34;key\u0026#34;,\u0026#34;value3\u0026#34;); System.out.println(m.get(\u0026#34;key\u0026#34;)); System.out.println(m.get(\u0026#34;key2\u0026#34;)); System.out.println(m.get(\u0026#34;key3\u0026#34;)); } } 実行結果\n\u0026gt; java Main value3 value null   Python  Pythonでは以下の二つの方法がある。\n 単に 辞書[キー] と書く 辞書のメソッドget()を使う (使用例： 辞書.get(キー) )  存在しないキーを指定した場合、\n前者はエラーになるが、後者はデフォルト値としてNoneが返る。このデフォルト値は自分で指定でき、指定したい場合はgetメソッドの第２引数に指定する（省略した場合はNoneになる）。\n実行例を以下に示す。\n\u0026gt;\u0026gt;\u0026gt; d={} \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; d[\u0026#34;key\u0026#34;]=\u0026#34;value\u0026#34; \u0026gt;\u0026gt;\u0026gt; d[\u0026#34;key2\u0026#34;]=\u0026#34;value2\u0026#34; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; d {\u0026#39;key\u0026#39;: \u0026#39;value\u0026#39;, \u0026#39;key2\u0026#39;: \u0026#39;value2\u0026#39;} \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; d[\u0026#34;key\u0026#34;] \u0026#39;value\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; d[\u0026#34;key3\u0026#34;] Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; KeyError: \u0026#39;key3\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; d.get(\u0026#34;key\u0026#34;) \u0026#39;value\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; d.get(\u0026#34;key3\u0026#34;) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; d.get(\u0026#34;key3\u0026#34;,\u0026#34;Not Found\u0026#34;) \u0026#39;Not Found\u0026#39; \u0026gt;\u0026gt;\u0026gt;    "},{"idx":203,"href":"/docs/programming/map/valuelist/","title":"辞書(Map)から値のリストを取得","content":" 辞書(Map)から値のリストを取得 辞書(Map)から値のリストを取得を取得する方法についてを示す。\nJava  JavaではMapクラスにvalues()というメソッドがある。これによりMapのキーをCollection型で取得することができる。\nCollection\u0026lt;V\u0026gt; values()\nListに変換したい時はListの変数の初期化時にこの返り値を指定してやればよい。\n実行例を以下に示す。\nimport java.util.Map; import java.util.HashMap; import java.util.List; import java.util.ArrayList; class Main{ public static void main(String args[]){ Map\u0026lt;String,String\u0026gt; m = new HashMap\u0026lt;\u0026gt;(); m.put(\u0026#34;key\u0026#34;,\u0026#34;value\u0026#34;); m.put(\u0026#34;key2\u0026#34;,\u0026#34;value2\u0026#34;); m.put(\u0026#34;key3\u0026#34;,\u0026#34;value3\u0026#34;); System.out.println(m); List\u0026lt;String\u0026gt; valuelist = new ArrayList\u0026lt;\u0026gt;(m.values()); System.out.println(valuelist); } } 実行結果\n\u0026gt; java Main {key2=value2, key3=value3, key=value} [value2, value3, value]   Python  Pythonは辞書の関数にvalues()という関数があり、これを利用することで辞書の値のイテラブルオブジェクトを取得できる。\nただし、このvalues関数で返されるオブジェクトはリストではなくdict_values型なので注意。リストに変換したい場合はlist()を使って変換する。\nfor文でループさせたい時は for i in 辞書.values() のようにすればよい。\n実行例を以下に示す。\n\u0026gt;\u0026gt;\u0026gt; d={\u0026#39;key\u0026#39;:\u0026#39;value\u0026#39;, \u0026#39;key2\u0026#39;:\u0026#39;value2\u0026#39;, \u0026#39;key3\u0026#39;:\u0026#39;value3\u0026#39;} \u0026gt;\u0026gt;\u0026gt; d {\u0026#39;key\u0026#39;: \u0026#39;value\u0026#39;, \u0026#39;key2\u0026#39;: \u0026#39;value2\u0026#39;, \u0026#39;key3\u0026#39;: \u0026#39;value3\u0026#39;} \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; valuelist=d.values() \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; valuelist dict_values([\u0026#39;value\u0026#39;, \u0026#39;value2\u0026#39;, \u0026#39;value3\u0026#39;]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; list(valuelist) [\u0026#39;value\u0026#39;, \u0026#39;value2\u0026#39;, \u0026#39;value3\u0026#39;] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; for v in valuelist: ... print(v) ... value value2 value3 \u0026gt;\u0026gt;\u0026gt;    "},{"idx":204,"href":"/docs/programming/map/maxkey/","title":"辞書(Map)から最大のキーを取得","content":" 辞書(Map)から最大のキーを取得 辞書(Map)から最大のキーを取得する方法についてを示す。\nJava  JavaでMapにあるキーの最大値を取得するには以下の手順で行う。\n MapのメソッドkeySet()を使い、キーのみをSetに格納したデータを取得する そのキーのSetをCollectionsクラスのmax()メソッドを用いて最大値を取得する(参考：リストの内一番大きい要素を調べる)  MapクラスのkeySet()メソッドは、MapにあるキーをSetに格納したものを返すメソッドである。SetはListから重複要素を除外させたデータ構造である。\nSet\u0026lt;K\u0026gt; keySet()\n実行例を以下に示す。\nimport java.util.Set; import java.util.Map; import java.util.HashMap; import java.util.Collections; class Main{ public static void main(String args[]){ Map\u0026lt;String,String\u0026gt; m = new HashMap\u0026lt;\u0026gt;(); m.put(\u0026#34;key\u0026#34;,\u0026#34;value\u0026#34;); m.put(\u0026#34;key2\u0026#34;,\u0026#34;value2\u0026#34;); m.put(\u0026#34;key3\u0026#34;,\u0026#34;value3\u0026#34;); System.out.println(m); Set\u0026lt;String\u0026gt; key = m.keySet(); String maxkey = Collections.max(key); System.out.println(\u0026#34;max key: \u0026#34; + maxkey); } } 実行結果\n\u0026gt; java Main {key2=value2, key3=value3, key=value} max key: key3   Python  Pythonでは単に組み込み関数max()を使えば、辞書にある最大のキーを取得できる。\n\u0026gt;\u0026gt;\u0026gt; d={\u0026#39;key\u0026#39;:\u0026#39;value\u0026#39;, \u0026#39;key2\u0026#39;:\u0026#39;value2\u0026#39;, \u0026#39;key3\u0026#39;:\u0026#39;value3\u0026#39;} \u0026gt;\u0026gt;\u0026gt; d {\u0026#39;key\u0026#39;: \u0026#39;value\u0026#39;, \u0026#39;key2\u0026#39;: \u0026#39;value2\u0026#39;, \u0026#39;key3\u0026#39;: \u0026#39;value3\u0026#39;} \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; max(d) \u0026#39;key3\u0026#39; \u0026gt;\u0026gt;\u0026gt;    "},{"idx":205,"href":"/docs/programming/map/maxval/","title":"辞書(Map)から最大の値を取得","content":" 辞書(Map)から最大の値を取得 辞書(Map)から最大の値を取得する方法についてを示す。\nJava  JavaでMapにある値の最大値を取得するには以下の手順で行う。\n Mapのメソッドvalues()を使い、値のみを格納したListを取得する その値のListをCollectionsクラスのmax()メソッドを用いて最大値を取得する(参考：リストの内一番大きい要素を調べる)  Mapクラスのvalues()メソッドは、Mapにある値をCollection(List,Setの親クラス)に格納したものを返すメソッドである。\nCollection\u0026lt;V\u0026gt; values()\n実行例を以下に示す。\nimport java.util.List; import java.util.ArrayList; import java.util.Map; import java.util.HashMap; import java.util.Collections; class Main{ public static void main(String args[]){ Map\u0026lt;String,String\u0026gt; m = new HashMap\u0026lt;\u0026gt;(); m.put(\u0026#34;key\u0026#34;,\u0026#34;value\u0026#34;); m.put(\u0026#34;key2\u0026#34;,\u0026#34;value2\u0026#34;); m.put(\u0026#34;key3\u0026#34;,\u0026#34;value3\u0026#34;); System.out.println(m); List\u0026lt;String\u0026gt; value = new ArrayList\u0026lt;\u0026gt;(m.values()); String maxval = Collections.max(value); System.out.println(\u0026#34;max value: \u0026#34; + maxval); } } 実行結果\n\u0026gt; java Main {key2=value2, key3=value3, key=value} max value: value3   Python  Pythonでは辞書の関数values()で値のみのビューオブジェクト(イテラブル)を取得できるので、これに組み込み関数max()を適用すると、値の最大値を取得できる。\n\u0026gt;\u0026gt;\u0026gt; d={\u0026#39;key\u0026#39;:\u0026#39;value\u0026#39;, \u0026#39;key2\u0026#39;:\u0026#39;value2\u0026#39;, \u0026#39;key3\u0026#39;:\u0026#39;value3\u0026#39;} \u0026gt;\u0026gt;\u0026gt; d {\u0026#39;key\u0026#39;: \u0026#39;value\u0026#39;, \u0026#39;key2\u0026#39;: \u0026#39;value2\u0026#39;, \u0026#39;key3\u0026#39;: \u0026#39;value3\u0026#39;} \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; v=d.values() \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; max(v) \u0026#39;value3\u0026#39; \u0026gt;\u0026gt;\u0026gt;    "},{"idx":206,"href":"/docs/programming/map/minkey/","title":"辞書(Map)から最小のキーを取得","content":" 辞書(Map)から最小のキーを取得 辞書(Map)から最小のキーを取得する方法についてを示す。\nJava  JavaでMapにあるキーの最小値を取得するには、最大値と同じで以下の手順で行う。\n MapのメソッドkeySet()を使い、キーのみをSetに格納したデータを取得する そのキーのSetをCollectionsクラスのmin()メソッドを用いて最小値を取得する(参考：リストの内一番小さい要素を調べる)  MapクラスのkeySet()メソッドは、MapにあるキーをSetに格納したものを返すメソッドである。SetはListから重複要素を除外させたデータ構造である。\nSet\u0026lt;K\u0026gt; keySet()\n実行例を以下に示す。\nimport java.util.Set; import java.util.Map; import java.util.HashMap; import java.util.Collections; class Main{ public static void main(String args[]){ Map\u0026lt;String,String\u0026gt; m = new HashMap\u0026lt;\u0026gt;(); m.put(\u0026#34;key\u0026#34;,\u0026#34;value\u0026#34;); m.put(\u0026#34;key2\u0026#34;,\u0026#34;value2\u0026#34;); m.put(\u0026#34;key3\u0026#34;,\u0026#34;value3\u0026#34;); System.out.println(m); Set\u0026lt;String\u0026gt; key = m.keySet(); String minkey = Collections.min(key); System.out.println(\u0026#34;min key: \u0026#34; + minkey); } } 実行結果\n\u0026gt; java Main {key2=value2, key3=value3, key=value} min key: key   Python  Pythonでは単に組み込み関数min()を使えば、辞書にある最小のキーを取得できる。\n\u0026gt;\u0026gt;\u0026gt; d={\u0026#39;key\u0026#39;:\u0026#39;value\u0026#39;, \u0026#39;key2\u0026#39;:\u0026#39;value2\u0026#39;, \u0026#39;key3\u0026#39;:\u0026#39;value3\u0026#39;} \u0026gt;\u0026gt;\u0026gt; d {\u0026#39;key\u0026#39;: \u0026#39;value\u0026#39;, \u0026#39;key2\u0026#39;: \u0026#39;value2\u0026#39;, \u0026#39;key3\u0026#39;: \u0026#39;value3\u0026#39;} \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; min(d) \u0026#39;key\u0026#39; \u0026gt;\u0026gt;\u0026gt;    "},{"idx":207,"href":"/docs/programming/map/minval/","title":"辞書(Map)から最小の値を取得","content":" 辞書(Map)から最小の値を取得 辞書(Map)から最小の値を取得する方法についてを示す。\nJava  JavaでMapにある値の最小値を取得するには、最大値の時と同様に以下の手順で行う。\n Mapのメソッドvalues()を使い、値のみを格納したListを取得する その値のListをCollectionsクラスのmin()メソッドを用いて最小値を取得する(参考：リストの内一番小さい要素を調べる)  実行例を以下に示す。\nimport java.util.List; import java.util.ArrayList; import java.util.Map; import java.util.HashMap; import java.util.Collections; class Main{ public static void main(String args[]){ Map\u0026lt;String,String\u0026gt; m = new HashMap\u0026lt;\u0026gt;(); m.put(\u0026#34;key\u0026#34;,\u0026#34;value\u0026#34;); m.put(\u0026#34;key2\u0026#34;,\u0026#34;value2\u0026#34;); m.put(\u0026#34;key3\u0026#34;,\u0026#34;value3\u0026#34;); System.out.println(m); List\u0026lt;String\u0026gt; value = new ArrayList\u0026lt;\u0026gt;(m.values()); String maxval = Collections.min(value); System.out.println(\u0026#34;min value: \u0026#34; + maxval); } } 実行結果\n\u0026gt; java Main {key2=value2, key3=value3, key=value} min value: value   Python  Pythonでは辞書の関数values()で値のみのビューオブジェクト(イテラブル)を取得できるので、これに組み込み関数min()を適用すると、値の最小値を取得できる。\n\u0026gt;\u0026gt;\u0026gt; d={\u0026#39;key\u0026#39;:\u0026#39;value\u0026#39;, \u0026#39;key2\u0026#39;:\u0026#39;value2\u0026#39;, \u0026#39;key3\u0026#39;:\u0026#39;value3\u0026#39;} \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; d {\u0026#39;key\u0026#39;: \u0026#39;value\u0026#39;, \u0026#39;key2\u0026#39;: \u0026#39;value2\u0026#39;, \u0026#39;key3\u0026#39;: \u0026#39;value3\u0026#39;} \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; v=d.values() \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; min(v) \u0026#39;value\u0026#39; \u0026gt;\u0026gt;\u0026gt;    "},{"idx":208,"href":"/docs/programming/map/pop/","title":"辞書(Map)から要素削除","content":" 辞書(Map)から要素削除 辞書(Map)から要素を削除する方法についてを示す。\nJava  JavaではMapクラスにremove()というメソッドがあり、引数にキーを指定すると、Map内でそのキーの要素が削除される。\nV remove(Object key)\n指定したキーがMapに無い場合はnullが返る。\nまた、Mapから全ての要素を削除したいときは、clear()というメソッドを用いると全ての要素を削除できる。\nvoid clear()\n実行例を以下に示す。\nimport java.util.Map; import java.util.HashMap; class Main{ public static void main(String args[]){ Map\u0026lt;String,String\u0026gt; m = new HashMap\u0026lt;\u0026gt;(); m.put(\u0026#34;key\u0026#34;,\u0026#34;value\u0026#34;); m.put(\u0026#34;key2\u0026#34;,\u0026#34;value2\u0026#34;); m.put(\u0026#34;key3\u0026#34;,\u0026#34;value3\u0026#34;); System.out.println(m); m.remove(\u0026#34;key2\u0026#34;); //key2削除  System.out.println(m); m.clear(); //全削除  System.out.println(m); } } 実行結果\n\u0026gt; java Main {key2=value2, key3=value3, key=value} {key3=value3, key=value} {}   Python  Pythonでは以下の二つの方法がある。\n del文を使い要素を削除する (使用例： del 辞書[キー]) 辞書の関数pop()を使う (使用例： 辞書.pop(キー) )  どちらの方法でも削除は行える。違う点は、del文の場合は実行した時何も返されないが、pop関数の場合は削除された値が返される。\n存在しないキーを指定した場合はエラーになる。\nまた、辞書から全ての要素を削除したい時は、辞書にclear()という関数があるのでこれを使うと便利。\n実行例を以下に示す。\n\u0026gt;\u0026gt;\u0026gt; d={} \u0026gt;\u0026gt;\u0026gt; d[\u0026#34;key\u0026#34;]=\u0026#34;value\u0026#34; \u0026gt;\u0026gt;\u0026gt; d[\u0026#34;key2\u0026#34;]=\u0026#34;value2\u0026#34; \u0026gt;\u0026gt;\u0026gt; d[\u0026#34;key3\u0026#34;]=\u0026#34;value3\u0026#34; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; d {\u0026#39;key\u0026#39;: \u0026#39;value\u0026#39;, \u0026#39;key2\u0026#39;: \u0026#39;value2\u0026#39;, \u0026#39;key3\u0026#39;: \u0026#39;value3\u0026#39;} \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; del d[\u0026#34;key2\u0026#34;] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; d {\u0026#39;key\u0026#39;: \u0026#39;value\u0026#39;, \u0026#39;key3\u0026#39;: \u0026#39;value3\u0026#39;} \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; d.pop(\u0026#34;key3\u0026#34;) \u0026#39;value3\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; d {\u0026#39;key\u0026#39;: \u0026#39;value\u0026#39;} \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; del d[\u0026#34;key2\u0026#34;] Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; KeyError: \u0026#39;key2\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; d.pop(\u0026#34;key3\u0026#34;) Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; KeyError: \u0026#39;key3\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; d {\u0026#39;key\u0026#39;: \u0026#39;value\u0026#39;} \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; d.clear() \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; d {} \u0026gt;\u0026gt;\u0026gt;    "},{"idx":209,"href":"/docs/programming/map/put/","title":"辞書(Map)に要素を追加する","content":" 辞書(Map)に要素を追加する 辞書(Map)に要素(キー・値)を追加する方法についてを示す。\nJava  JavaではMapクラスにput()というメソッドがあり、引数にキー・値を指定すると、そのMap内にキー・値が入る。\nV put(K key, V value)\n既に同じキーがあった場合は上書きされて入る。\n実行例を以下に示す。\nimport java.util.Map; import java.util.HashMap; class Main{ public static void main(String args[]){ Map\u0026lt;String,String\u0026gt; m = new HashMap\u0026lt;\u0026gt;(); m.put(\u0026#34;key\u0026#34;,\u0026#34;value\u0026#34;); m.put(\u0026#34;key2\u0026#34;,\u0026#34;value\u0026#34;); m.put(\u0026#34;key\u0026#34;,\u0026#34;value3\u0026#34;); System.out.println(m); } } 実行結果\n\u0026gt; java Main {key2=value, key=value3}   Python  Pythonでは以下のような記法で辞書にキー・値を追加できる。\n辞書[キー] = 値\n既に同じキーがあった場合は、値が上書きされる。\n実行例を以下に示す。\n\u0026gt;\u0026gt;\u0026gt; d[\u0026#34;key\u0026#34;] = \u0026#34;value\u0026#34; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; d {\u0026#39;key\u0026#39;: \u0026#39;value\u0026#39;} \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; d[\u0026#34;key2\u0026#34;] = \u0026#34;value2\u0026#34; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; d {\u0026#39;key\u0026#39;: \u0026#39;value\u0026#39;, \u0026#39;key2\u0026#39;: \u0026#39;value2\u0026#39;} \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; d[\u0026#34;key\u0026#34;] = \u0026#34;value3\u0026#34; \u0026gt;\u0026gt;\u0026gt; d {\u0026#39;key\u0026#39;: \u0026#39;value3\u0026#39;, \u0026#39;key2\u0026#39;: \u0026#39;value2\u0026#39;} \u0026gt;\u0026gt;\u0026gt;    "},{"idx":210,"href":"/docs/programming/map/dict_loop/","title":"辞書(Map)のループ","content":" 辞書(Map)のループ 辞書(Map)のループを行う方法についてを示す。\nJava  JavaでMapにループを掛けるには、MapのメソッドであるentrySet()を利用してMap内の全てのキー・値の組み合わせを取得し、それを拡張for文などでループさせる。\nfor( Map.entry\u0026lt;キーの型,値の型\u0026gt; entry: (Mapの変数).entrySet() ){ キーの型 key = entry.getKey(); 値の型 value = entry.getValue(); }  実行例を以下に示す。\nimport java.util.Map; import java.util.HashMap; class Main{ public static void main(String args[]){ Map\u0026lt;String,String\u0026gt; m = new HashMap\u0026lt;\u0026gt;(); m.put(\u0026#34;key1\u0026#34;,\u0026#34;val1\u0026#34;); m.put(\u0026#34;key2\u0026#34;,\u0026#34;val2\u0026#34;); m.put(\u0026#34;key3\u0026#34;,\u0026#34;val3\u0026#34;); for(Map.Entry\u0026lt;String,String\u0026gt; e : m.entrySet()){ System.out.println(e.getKey() + \u0026#34; \u0026#34; + e.getValue()); } } } 実行結果\n\u0026gt; java Main key1 val1 key2 val2 key3 val3   Python  Pythonで辞書にループをかけるには、for文のループに辞書のitems()関数を使いループすると行える。\nitems関数は辞書にあるキーと値の組み合わせを全て取得する関数である。\nこれを利用し、以下のように行うと辞書のループが行える。\nfor k,v in 辞書.items(): //kにはキー、vには値が入る //処理文  キーだけを取り出したい時はkeys()、値のみで行いたい時はvalues()関数を利用する。\n  "},{"idx":211,"href":"/docs/programming/map/map_index/","title":"辞書、Map","content":" 辞書、Map 辞書、Mapについての記事。\n多くの言語でこれに似たようなデータ構造がある（と予想している）が、言語により名前が違うので注意。\nJavaではMap、Pythonでは辞書と呼ばれている。\n辞書、Map  辞書(Map) 辞書(Map)に要素を追加する 辞書(Map)からキーを指定して値を取得 辞書(Map)から要素削除 辞書(Map)から最大のキーを取得 辞書(Map)から最小のキーを取得 辞書(Map)から最大の値を取得 辞書(Map)から最小の値を取得 辞書(Map)からキーのリストを取得 辞書(Map)から値のリストを取得 辞書(Map)のループ  "},{"idx":212,"href":"/docs/programming/math/inv/","title":"逆行列","content":" 逆行列 逆行列を算出する方法についてを述べる。\nPython  逆行列を算出したいときは、numpy.linalgモジュールにある関数invを使用する。\nnumpy.linalg.inv(A)\n上記の式により、行列Aの逆行列が生成される。\n実行例を以下に示す。\n\u0026gt;\u0026gt;\u0026gt; import numpy as np \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #行列Aの定義 \u0026gt;\u0026gt;\u0026gt; a=np.array([[1,2],[3,4]]) \u0026gt;\u0026gt;\u0026gt; print(a) [[1 2] [3 4]] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #行列Aの逆行列 \u0026gt;\u0026gt;\u0026gt; print(np.linalg.inv(a)) [[-2. 1. ] [ 1.5 -0.5]] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #行列B（逆行列は存在しない） \u0026gt;\u0026gt;\u0026gt; b=np.array([[1,1],[1,1]]) \u0026gt;\u0026gt;\u0026gt; print(b) [[1 1] [1 1]] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #Bの逆行列 -\u0026gt; 逆行列は存在しないのでエラー \u0026gt;\u0026gt;\u0026gt; print(np.linalg.inv(b)) Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; File \u0026#34;/Users/***/.pyenv/versions/3.7.3/lib/python3.7/site-packages/numpy/linalg/linalg.py\u0026#34;, line 551, in inv ainv = _umath_linalg.inv(a, signature=signature, extobj=extobj) File \u0026#34;/Users/***/.pyenv/versions/3.7.3/lib/python3.7/site-packages/numpy/linalg/linalg.py\u0026#34;, line 97, in _raise_linalgerror_singular raise LinAlgError(\u0026#34;Singular matrix\u0026#34;) numpy.linalg.LinAlgError: Singular matrix \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt;    "},{"idx":213,"href":"/docs/programming/list/array/","title":"配列","content":" 配列 配列とは、同じデータ型の値をまとめて扱いたい時に利用するデータ構造である。ここでは配列の定義方法についてを述べる。\nなお、Pythonには配列という概念は存在しない（リストとひっくるめている？）のでここでは述べない。\nJava  Javaでは以下の形式で配列を宣言する。\nデータ型[] 配列名 = new データ型[要素数];  この方法により、配列内に指定したデータ型の値を、指定した要素数の数まで入れることができる。\n配列への値の代入及び取得は、以下のようにインデックスを指定して行う。\n配列名[インデックス] = 値; 変数 = 配列名[インデックス];   Javascript  Javascriptでは以下の形式で配列を宣言する。Javaのような要素数の指定は不要である。\nvar 配列名 = [(値、カンマ区切りで複数入力可)]  配列への値の代入及び取得は、Javaと同じようにインデックスを指定して行う。\n配列名[インデックス] = 値; 変数 = 配列名[インデックス];     配列の長さ(要素数)を確認する 配列の長さ、つまりは入っている要素の数を表示する方法についてを述べる。\nJava  Javaでは配列オブジェクトにlengthという属性があり、それが配列の長さを示している。\n配列.length  この方法により、配列の長さを表示することができる。\n Javascript  JavascriptもJavaと同じく配列にlengthという属性がある。それが配列の長さを示している。\n配列.length     配列に値を追加する 言語により概念が異なるが、配列に値を追加する方法についてを述べる。\nなお、Javaでは配列の長さが固定されているので、値を追加するという概念は基本ない。（配列の指定したインデックスに値を入れることは可能）\nJavascriptでは配列の長さは固定されてはおらず、リストのように配列の後ろに値を追加することができる。（じゃあそれはリストではないか？とも考えてはいるが）\nJavascript  Javascriptでは以下の形式で配列に要素を追加できる。\n配列.push(要素)    "},{"idx":214,"href":"/docs/programming/class_func/func/","title":"関数(メソッド)の定義","content":" 関数(メソッド)の定義 関数・メソッドを定義する方法についてを示す。\nJava  Javaではメソッドと言う名で呼ばれる。定義するための記法は以下の通り。クラス内で記述する。\n[アクセス修飾子] [static] [返り値の型] メソッド名 { //処理文 return 返り値; //返り値がvoidなら不要 }  アクセス修飾子はpublic,private,protectedなど。publicの場合は他のクラスからも利用できる。privateにすると自身のクラスからしか利用することができない。 staticを書くとそのメソッドは静的メソッドとなり、外部のクラスから クラス名.メソッド名 の形で利用することができる。staticがないとインスタンスメソッドとなり、インスタンスを生成してそのインスタンス名.メソッド名　の形でしか利用することができない。（通常はインスタンスメソッドで利用する）\nまた、メソッドには返り値が必要である。メソッドの最後にreturn文を利用して、メソッドの出力としての返り値を指定してやる必要がある。この返り値の型は、メソッド宣言時に指定した型と同じでないといけない。\nただし、返り値の型にvoidとした場合は返り値がないと言う意味なので、returnは不要である。\n Python  Pythonでは関数と言う名で呼ばれる。定義方法は以下の通り。\ndef 関数名(引数): #処理文 return 返り値 #関数に返り値を設ける場合はreturnを記載する。無い場合は記載しなくて良い。  関数の処理文はdefの次の行から、インデントを一つずらして書く。このインデントの段階にある文が関数の処理文として扱われる。\n Javascript  Javascriptでは関数とメソッドで意味合いが微妙に異なるので注意。\n関数 関数について、Javascriptではfunctionキーワードを用いて関数を定義する。\nfunction 関数名(引数) { //関数内の処理 }  引数は0個でも、複数個でも設定できる。\n戻り値を設定したい場合は、return文を使って戻したい値を記載する。\nまた、Javascriptでは無名関数という使用があり、変数に直接関数を代入することができる。\nvar 変数名 = function(引数){ //処理 };  呼び出すときは、変数名(引数);という形で利用できる。\nメソッド Javascriptでは、オブジェクト型データのプロパティに定義した関数のことをメソッドと呼んでいる。\nvar 変数名 = { (key名) : function(){ //メソッド }, ・・・ }  メソッドを使用するには、オブジェクト型の変数のメソッドが指定されているキーを呼び出せば良い。\n  "},{"idx":215,"href":"/docs/programming/other/help/","title":"関数、メソッドのヘルプを見る","content":" 関数、メソッドのヘルプを見る 関数やメソッドの使い方がわからないとき、ヘルプを見る方法がある。それについてを述べる。\nただし、対話型などこちらがコマンドライン上で扱える言語に限る。故に今はPythonのみ記載する。\nPython  Pythonにhelp()という組み込み関数がある。引数に関数名を入力すると、文字列として扱われて検索し、得たレファレンスなどを返してくれる。\nhelp()は、対話モードで使用する。\n例えば関数maxをhelpで調べて見ると以下のようになる。\n\u0026gt;\u0026gt;\u0026gt; help(max) 実行結果\nHelp on built-in function max in module builtins: max(...) max(iterable, *[, default=obj, key=func]) -\u0026gt; value max(arg1, arg2, *args, *[, key=func]) -\u0026gt; value With a single iterable argument, return its biggest item. The default keyword-only argument specifies an object to return if the provided iterable is empty. With two or more arguments, return the largest argument. (END)    "},{"idx":216,"href":"/docs/programming/number/factorial/","title":"階乗","content":" 階乗 階乗計算についてを示す。\n基本、階乗計算はn * n-1 * n-2 * \u0026hellip; * 1を地道にやっていく計算量O(n)の計算を行うので、時間がかかりやすいという特徴がある。\nJava  Javaには階乗計算を行うライブラリは現時点ではない（はず。広ーく探せばもしかしたら存在するかもしれないが）。\nそのため、独自で階乗計算を行うメソッドを実装する必要がある。\n階乗計算を行う上で有名なのが、再帰を使った方法である。実装例を以下に示す。\npublic static int factorial(int n){ if(n == 0 || n == 1){ return 1; }else{ return n * factorial(n-1); } } 再帰計算を用いることにより、上記メソッドfactorial(n)はn!を意味する。 実行例を下記に示す。\nimport java.lang.Math; class Main{ public static int factorial(int n){ if(n == 0 || n == 1){ return 1; }else{ return n * factorial(n-1) } public static void main(String args[]){ int a = 1; int b = 5; int c = 10; System.out.println(factorial(a)); System.out.println(factorial(b)); System.out.println(factorial(c)); } } 実行結果\n\u0026gt; java Main 1 120 3628800  但し、再帰計算は線形的に計算を行うため、計算量もO(n)となり、大きな数を入力すると計算に時間がかかる。\n上記メソッドfactorialは引数n以下の全ての数字の階乗の結果も計算するので、複数回計算を行う場合にはそれまでの計算結果も別の配列などに保存しておくと、階乗計算が1回で済むので計算時間もいくらか短縮される（これでも足りない場合もあるが）\n Python  pythonにはmathモジュールに階乗計算を行う関数factorial() があるのでこれを利用する。\n\u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; import math \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a=1 \u0026gt;\u0026gt;\u0026gt; b=5 \u0026gt;\u0026gt;\u0026gt; c=10 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; math.factorial(a) 1 \u0026gt;\u0026gt;\u0026gt; math.factorial(b) 120 \u0026gt;\u0026gt;\u0026gt; math.factorial(c) 3628800 \u0026gt;\u0026gt;\u0026gt;   "},{"idx":217,"href":"/docs/ctf/esolang/","title":"難解プログラミング言語","content":" 難解プログラミング言語 難解プログラミング言語とは、意図的に解読が困難になるように設計されたプログラミング言語である。\n実用性を考慮して作られたものではなく、技術者やハッカーの間で使われるネタ（？）のような言語。\n一例としてwhitespaceというのがある。これはスペース、タブ、改行のみで内容を記述するものである。\n専用のインタプリタもあり、スペース、タブ、改行の並び順を元に解釈し、実行する。\n原理としては、スペース、タブ、改行の組み合わせで演算、命令、スタック操作を表現し、実行している。\n公式サイトに詳細やパッケージ等があるようだが、現在は利用できない状態のため、インタプリタは入手できない(?)\nwhitespace以外にも、これと似たような難解プログラミング言語は多数存在する。\n(後日また何か追記します・・)\n"},{"idx":218,"href":"/docs/programming/math/zero/","title":"零行列","content":" 零行列 零行列を生成する方法についてを示す。\nPython  零行列はnumpyの関数zerosで生成できる。\n引数に１つの整数を渡した場合は1次元(ベクトル)、行列のサイズ(タプル型)を渡した場合は行列になる。サイズの長さに制限はなく、行列は何次元でも生成可能である。\n\u0026gt;\u0026gt;\u0026gt; import numpy as np \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #引数に１つの整数 -\u0026gt; その長さ分の零ベクトル \u0026gt;\u0026gt;\u0026gt; np.zeros(10) array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(np.zeros(10)) [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #引数に行列のサイズ(タプル型) -\u0026gt; そのサイズの零行列 \u0026gt;\u0026gt;\u0026gt; np.zeros((4,3)) array([[0., 0., 0.], [0., 0., 0.], [0., 0., 0.], [0., 0., 0.]]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; print(np.zeros((4,3))) [[0. 0. 0.] [0. 0. 0.] [0. 0. 0.] [0. 0. 0.]] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #3次元 \u0026gt;\u0026gt;\u0026gt; np.zeros((2,2,2)) array([[[0., 0.], [0., 0.]], [[0., 0.], [0., 0.]]]) \u0026gt;\u0026gt;\u0026gt;    "},{"idx":219,"href":"/docs/programming/machine_learning/1d_2class/","title":"１次元入力２クラス分類","content":" １次元入力２クラス分類  先述までに述べた回帰問題は、入力データから具体的な連続した数値を予測するものであったが、ここからの分類問題は入力データから目標データとなる離散値を予測する手法になる。但し分類問題では、目標となる離散値はそれぞれ対応する固有名詞(クラス、カテゴリ)を指すための値であり、その離散値自体には意味を持たないことが多い。ここではまず単純な、１次元の入力データから２つのクラスに分類を行う問題についてを示す。\n まず入力データをxnとおき、それに対する目標データをtnとおく。(nはインデックス)\n今回は２クラスへの分類なので、tnは0か1のみをとる。\nクラスAの時はtn=0、クラスBの時は1を指すものとする。分類問題の時、このtnをクラス、カテゴリ、またはラベルと呼ぶ。\n入力データx、目標データtを行列で表すと以下のようになる。\n  $$ {\\bf x} = \\left[ \\begin{array}{cccc} x_{0} \\\\ x_{1} \\\\ \\vdots \\\\ x_{N-1} \\end{array} \\right] , {\\bf t} = \\left[ \\begin{array}{cccc} t_{0} \\\\ t_{1} \\\\ \\vdots \\\\ t_{N-1} \\end{array} \\right] $$ 例として、以下の温泉の温度とお客さんがいい湯と感じたか否かを答えた回答データ　を考えてみる。\n   温泉の温度 いい湯(=1)か否(=0)か     35.9 0   42.3 1   36.6 0   40.0 1   42.1 1   37.8 1   38.9 0   41.1 1   39.2 1   40.2 0   43.3 1   39.3 1   37.2 0   39.5 1   40.4 1   41.5 0   35.1 0   44.1 1   43.7 1   39.4 0    念のため、上記データをプロットすると以下のようになる。（コードはこちら）\nこのデータと図より、いい湯か否かが分けるには何度を境界にすれば良いかを考えてみよう。\n直線モデルで分類できる？ まずは前章まで行なっていた回帰分析として、直線モデルを使えないか？と考えてみる。\nデータを直線モデルにフィットさせ、ちょうど中間であるt=0.5の時のxを境界としてみなせないだろうか、と想定してみる。\n直線モデルを適用してみると下図の通り。(コードはこちら)\n上図において黒線がデータをフィットさせた直線モデル、赤点線が直線モデルからt=0.5の時のxを元に作成した決定境界である。\nこれにより決定境界を定められないか？と考えるが、データの分散が大きい場合（極端に大きい値や小さい値を持つデータなどがあった場合）、この方法を適用すると決定境界も大幅に偏ってしまうという懸念点があり、あまり望ましくないと考える。\nでは、どのような方法を用いるのが良いのだろうか。\nここで、確率を用いて分類をしてみることを考えてみる。\n確率を用いた分類 まず、そもそもの分類問題について考える。\n先ほどの直線モデルの例でも述べたように、分類問題の目的はどこに決定境界を引くのが最適か、ということである。\nここでもう一つ認識して欲しいのは、決定境界を引いたからといって100%完璧な分類が未知のデータに対して行われるというわけではないということである。というより、入力データに対しても目標データ通りの分類にはならない場合もある。\nまさに今回のデータの場合、t=0の時の最大のx以上かつt=1の時の最小のx以下となるようなxに決定境界を引けば100%完璧な分類を行えるが、そのようなxは存在しないので完璧な分類が行えないことは明らかである。\nそのため、xに決定境界を引いた時に、誤分類となる結果が最も少なくなるようなxを求めることを考えてみる。これが、確率を用いて分類を考える方法である。\nその方法についての一例を次章で述べる。\n"},{"idx":220,"href":"/docs/programming/machine_learning/2d_2class/","title":"２次元入力２クラス分類","content":" ２次元入力２クラス分類 前章では１次元入力であったが、次は２次元入力の場合を考えてみる。\n１次元入力２クラス分類で使用したデータに、pHのデータも加えた２次元入力のデータを新たに作成する。(入力データはこちら、目標データはこちら)\n図示すると以下のようになる。(コードはこちら)\nこのデータから、２次元入力２クラス分類についてを考えてみよう。\nロジスティック回帰モデル 前述の１次元入力２クラス分類と同じく、２次元入力２クラス分類のときもロジスティック回帰モデルを適用することを考えてみる。２次元入力２クラス分類の場合のロジスティック回帰モデルはどのようになるだろうか。\n１次元入力の場合は\n  $$ \\begin{aligned} \\tag{1} y \u0026= \\sigma ( w_{0} x + w_{1} ) \\\\ \u0026= \\frac{1}{1 + \\exp(-(w_{0} x + w_{1}))} \\end{aligned} $$ であった。\n２次元入力の場合は、パラメータw0,w1,w2、入力変数をx0,x1と置いたとき、以下のように表される。\n$$ \\begin{aligned} \\tag{2} y \u0026= \\sigma ( w_{0} x_{0} + w_{1} x_{1} + w_{2} ) \\\\ \u0026= \\frac{1}{1 + \\exp(-(w_{0} x_{0} + w_{1} x_{1} + w_{2}))} \\end{aligned} $$ ここから、最適なパラメータwを求めていこう。\n１次元入力２クラス分類の時と同じく、平均交差エントロピー誤差関数は以下の式の通りになる。\n$$ \\tag{3} E( { \\bf w } ) = - \\frac{1}{N} \\sum_{n=0}^{N-1} ( t_{n} \\log y_{n} + (1 - t_{n}) \\log (1 - y_{n}) ) $$ 同様にしてパラメータw0,w1,w2での偏微分を求めると以下のようになる。\n$$ \\tag{4} \\frac{\\partial }{\\partial w_{0} }　E( { \\bf w } ) = \\frac{1}{N} \\sum_{n=0}^{N-1} ( y_{n} - t_{n} ) x_{n,0} $$ $$ \\tag{5} \\frac{\\partial }{\\partial w_{1} }　E( { \\bf w } ) = \\frac{1}{N} \\sum_{n=0}^{N-1} ( y_{n} - t_{n} ) x_{n,1} $$ $$ \\tag{6} \\frac{\\partial }{\\partial w_{2} }　E( { \\bf w } ) = \\frac{1}{N} \\sum_{n=0}^{N-1} ( y_{n} - t_{n} ) $$ ここで、xn,iはxnのi番目の入力である。\nよって、これらを元に勾配法を用いて、平均交差エントロピー誤差が最小となるようなパラメータwの値を求めてみよう。\nまず、２次元入力のロジスティック回帰モデルのコードは以下の通り。\n(logistic_regression_2d.py)\nfrom sigmoid import sigmoid import numpy as np #ロジスティック回帰モデル(２次元入力) def logistic_regression_2d(w,x): x = w[0]*x[:,0] + w[1]*x[:,1] + w[2] return sigmoid(x) ２次元入力での平均交差エントロピー誤差のコードは以下の通り。\n(cross_entropy_error_2d.py)\nfrom logistic_regression_2d import logistic_regression_2d import numpy as np #交差エントロピー誤差 def cross_entropy_error_2d(w,x,t): y=logistic_regression_2d(w,x) cee=0 for n in range(len(y)): cee -= (t[n]*np.log(y[n]) + (1-t[n])*np.log(1-y[n])) return cee #平均交差エントロピー誤差 def ave_cross_entropy_error_2d(w,x,t): return cross_entropy_error_2d(w,x,t)/len(x) 続いて、平均交差エントロピー誤差の偏微分を求めるコードは以下の通り。\n(d_cee_2d.py)\nfrom logistic_regression_2d import logistic_regression_2d import numpy as np #平均交差エントロピー誤差の微分(２次元入力) def d_cee_2d(w,x,t): y = logistic_regression_2d(w,x) d_cee=np.zeros(3) for n in range(len(y)): #w0 d_cee[0]+=(y[n]-t[n])*x[n,0] #w1 d_cee[1]+=(y[n]-t[n])*x[n,1] #w2 d_cee[2]+=y[n]-t[n] d_cee /= len(y) return d_cee ではこれらを元に、１次元入力２クラス分類で行ったような勾配法を用いて、最適なパラメータwを求めてみよう。\nパラメータwを求めるコードは以下の通り。\n(fit_2d_2class.py)\nfrom cross_entropy_error_2d import ave_cross_entropy_error_2d from scipy.optimize import minimize from d_cee_2d import d_cee_2d import numpy as np #勾配法 def fit_2d_2class(w,x,t): result=minimize(ave_cross_entropy_error_2d,w,args=(x,t),jac=d_cee_2d,method=\u0026#34;CG\u0026#34;) return result.x (solve_2d_2class.py)\nfrom fit_2d_2class import fit_2d_2class import numpy as np #入力値 x = np.load(\u0026#39;x_2d2class.npy\u0026#39;) #実測値 t = np.load(\u0026#39;t_2d2class.npy\u0026#39;) #wの初期値 w_init=[1,1,1] #勾配法でwを求める w=fit_2d_2class(w_init,x,t) print(\u0026#34;w0:{0}\u0026#34;.format(w[0])) print(\u0026#34;w1:{0}\u0026#34;.format(w[1])) print(\u0026#34;w2:{0}\u0026#34;.format(w[2])) 実行結果\nw0:2.2211059806431024 w1:2.5337217620823123 w2:-103.76947792619409  となり、パラメータwが求められる。\nよって、このwを使ったロジスティック回帰モデルを入力データとともに図示してみると、以下のようになる。(コードはこちら)。\nこれを元に、１次元入力２クラス分類の時と同様にして決定境界をロジスティック回帰モデルの値が0.5になる値のところに引いてみよう。\n入力データ、ロジスティック回帰モデル及び決定境界を等高線プロットで表した図は以下の通り。(コードはこちら)\nこの方法により、２次元入力２クラス分類の決定境界を求められる。\n"},{"idx":221,"href":"/docs/programming/machine_learning/2d_3class/","title":"２次元入力３クラス分類","content":" ２次元入力３クラス分類 次は２次元入力において、３クラス分類を行うケースについてを考える。\n先程の２次元入力２クラス分類のデータに、良いでも悪いでもない「まあまあ」というカテゴリ(クラス)を追加したようなデータを考えてみよう。\nそのようなデータを新たに作成し(入力データはこちら、目標データはこちら)、図示してみる。\nここから３クラス分類を行うための決定境界を求めてみる。\nしかし３クラス以上の分類の時は、２クラス分類で使用したロジスティック回帰モデルを適用するのは難しい。(使用しているシグモイド関数が0または1に近い値を取るため)\nそのため、入力データとパラメータを用いて計算した値を、シグモイド関数ではない方法を用いることで条件付き確率・交差エントロピー誤差・決定境界を求めることを考える。\nでは、シグモイド関数ではない方法に何があるだろうか。\n方法の一つとして、ここではソフトマックス関数を利用することを考える。\nソフトマックス関数を利用することで、出力値が全て0以上1以下の値に収まるので、この値を条件付き確率として用いる。\np次元入力qクラス分類において、入力データxn (n=0,..,p-1)とした時、常に１を取る入力データxpを追加、出力値がq個得られるようにパラメータをq×(p+1)行列で用意し、以下のように計算して値を取る。\n例として２次元入力３クラス分類においては以下のような設定をし、出力値を得る。\nこの図より、入力データxとパラメータwから出力データaを以下のように計算する。\n  $$ \\begin{aligned} \\tag{1} a_{k} \u0026= w_{k0} x_{0} + w_{k1} x_{1} + w_{k2} x_{2} (k=0,1,2) \\\\ \u0026= \\sum_{i=0}^{p} w_{ki} x_{i} (k=0,1,2) \\end{aligned} $$ これにより、まず出力値akを得られる。\n次に、この出力値akに対し、ソフトマックス関数を適用して0~1の値に収まらせ、条件付き確率とする。\nまずはソフトマックス関数で用いる総和uを以下の式(2)で定義する。\n$$ \\begin{aligned} \\tag{2} u \u0026= \\exp(a_{0}) + \\exp(a_{1}) + \\cdots + \\exp(a_{q-1}) \\\\ \u0026= \\sum_{i=0}^{q-1} \\exp(a_{i}) \\end{aligned} $$ これを利用し、出力値akにソフトマックス関数を適用した出力値ykを以下の式(3)のように定義する。\n$$ \\tag{3} y_{k} = \\frac{ \\exp(a_{k}) }{u} (k=0,1,2) $$ このykを入力データxがクラスkに属する条件付き確率とする。\n例えばk=0の時(クラス0に分類される確率)は以下のようになる。\n$$ \\tag{4} P( { \\bf t} =[1,0,0] \\mid { \\bf x } ) = y_{0} $$ k=1の時(クラス1に分類される確率)は以下のようになる。\n$$ \\tag{5} P( { \\bf t} =[0,1,0] \\mid { \\bf x } ) = y_{1} $$ 式(4),(5)を例として述べたが、P(t|x)を一般化すると以下の式(6)のようになる。\n$$ \\tag{6} P( { \\bf t} \\mid { \\bf x } ) = {y_{0}}^{t_{0}} {y_{1}}^{t_{1}} {y_{2}}^{t_{2}} $$ このように表すことで、例えばクラス０だったらt=[1,0,0]なのでP(t|x)=y0 1 y1 0 y2 0 = y0 のようになる。\nこれにより、p次元入力qクラス分類において全ての入力データXから全クラスデータTが得られる確率は以下のように表される。\n$$ \\tag{6} \\begin{aligned} P( { \\bf T } \\mid { \\bf X } ) \u0026= \\prod_{n=0}^{p-1} P( t_{n} \\mid x_{n} ) \\\\ \u0026= \\prod_{n=0}^{p-1} y_{n0}^{t_{n0}} y_{n1}^{t_{n1}} \\cdots y_{n(q-1)}^{t_{n(q-1)}} \\\\ \u0026= \\prod_{n=0}^{p-1} \\prod_{k=0}^{q-1} (y_{nk})^{t_{nk}} \\end{aligned} $$ これより、平均交差エントロピー誤差関数は以下のようになる。\n$$ \\tag{7} \\begin{aligned} E( { \\bf w } ) \u0026= - \\frac{1}{N} \\log P( { \\bf T } \\mid { \\bf X } ) \\\\ \u0026= - \\frac{1}{N} \\log \\prod_{n=0}^{p-1} P( t_{n} \\mid x_{n} ) \\\\ \u0026= - \\frac{1}{N} \\sum_{n=0}^{p-1} \\sum_{k=0}^{q-1} t_{nk} \\log y_{nk} \\end{aligned} $$ 次に、勾配法で利用するためこの平均交差エントロピー誤差をwkiで偏微分した結果を求めてみると以下のようになる。\n$$ \\tag{8} \\frac{\\partial }{\\partial w_{ki} }E( { \\bf w } ) = \\frac{1}{N} \\sum_{n=0}^{p-1} ( y_{nk} - t_{nk} ) x_{ni} $$ では、これらより勾配法を利用して決定境界を求めてみよう。\n諸関数を求めるコードは以下のとおり。\nfrom scipy.optimize import minimize import numpy as np #ロジスティック回帰モデル(２次元入力３クラス分類) def logistic_regression_2d_3class(w,x): #w:1*9行列 -\u0026gt; 3*3行列 w=w.reshape((3,3)) #x:n*2行列 (xの転置) n=len(x) #a:n*3行列 a=np.zeros((n,3)) for k in range(3): a[:,k] = np.exp( w[k,0]*x[:,0] + w[k,1]*x[:,1] +w[k,2] ) #u:aの１行の要素の合計、n*1行列にする u = np.sum(a,axis=1) u = u.reshape(n,1) #y:n*3行列 y = a/u return y #平均交差エントロピー誤差（２次元入力３クラス分類用） def cross_entropy_error_for_2d_3class(w,x,t): #w:1*9行列 -\u0026gt; 3*3行列 w=w.reshape((3,3)) #x:n*2行列（xの転置） #t:n*3行列（t[i]がクラスkにb分類された時t[i.k]=1,それ以外は0） y=logistic_regression_2d_3class(w,x) N=y.shape[0] #cee:平均交差エントロピー誤差 cee=0 for n in range(N): for k in range(3): cee = cee - (t[n,k] * np.log(y[n,k])) cee = cee / N return cee #平均交差エントロピー誤差の偏微分（２次元入力３クラス分類用） def d_cee_for_2d_3class(w,x,t): #w:1*9行列 -\u0026gt; 3*3行列 w=w.reshape((3,3)) #x:n*2行列（xの転置） #t:n*3行列（t[i]がクラスkにb分類された時t[i.k]=1,それ以外は0） y=logistic_regression_2d_3class(w,x) #d_cee:3*3 (クラスの数k*(xの次元+1)) 行列 d_cee=np.zeros((3,3)) N=x.shape[0] for n in range(N): for k in range(3): d_cee[k,:] = d_cee[k,:] + (y[n,k]-t[n,k])*np.r_[x[n,:],1] d_cee = d_cee / N #3*3-\u0026gt;1*1行列(minimizeの仕様上)で返す return d_cee.reshape(-1) #勾配法 def fit_2d_3class(w,x,t): result = minimize(cross_entropy_error_for_2d_3class,w,args=(x,t),jac=d_cee_for_2d_3class,method=\u0026#34;CG\u0026#34;) return result.x 次に、決定境界及びデータをプロットするコードは以下のとおり。\nfrom logistic_regression_2d_3class import logistic_regression_2d_3class from logistic_regression_2d_3class import cross_entropy_error_for_2d_3class from logistic_regression_2d_3class import fit_2d_3class from plot_2d_3class import plot_2d_3class import matplotlib.pyplot as plt import numpy as np def contour_for_2d_3class(w,x): xn=30 x0=np.linspace(min(x[:,0])-1,max(x[:,0])+1,xn) x1=np.linspace(min(x[:,1])-1,max(x[:,1])+1,xn) xx0,xx1=np.meshgrid(x0,x1) y=np.zeros((xn,xn,3)) for i in range(xn): wk=logistic_regression_2d_3class(w,np.concatenate([xx0[:,i].reshape(xn,1),xx1[:,i].reshape(xn,1)],1)) for j in range(3): y[:,i,j]=wk[:,j] for j in range(3): cont=plt.contour(xx0,xx1,y[:,:,j],levels=(0.25,0.5,0.75),colors=[\u0026#39;lightgray\u0026#39;,\u0026#39;red\u0026#39;,\u0026#39;lightgray\u0026#39;]) cont.clabel(fmt=\u0026#39;%1.1f\u0026#39;,fontsize=9) plt.grid(True) #入力値 x = np.load(\u0026#39;x_2d3class.npy\u0026#39;) #目標値 t = np.load(\u0026#39;t_2d3class.npy\u0026#39;) #目標値をn*3行列にする temp_t=t t=np.zeros((t.shape[0],3)) for i in range(t.shape[0]): t[i,temp_t[i]]=1 w_init=np.zeros((3,3)) w=fit_2d_3class(w_init,x,t) cee=cross_entropy_error_for_2d_3class(w,x,t) print(\u0026#34;CEE={0:.2f}\u0026#34;.format(cee)) plot_2d_3class(x,temp_t) contour_for_2d_3class(w,x) plt.show() 実行結果\nCEE=0.23  また、これにより出力した図は以下のようになる。\n"},{"idx":222,"href":"/docs/programming/number/bin/","title":"２進数に変換して表示","content":" 2進数に変換して表示 数値を2進数に変換して表示する方法についてを示す。\nJava  JavaではラッパークラスIntegerに数値を2進数に変換するメソッドtoBinaryString()があるのでそれを利用する。\npublic static String toBinaryString(int i)\n戻り値はStringであり、引数の数値を2進数に表記したものが出力される。\nclass Main{ public static void main(String args[]){ int a = 10; System.out.println(Integer.toBinaryString(a)); } } 実行結果\n\u0026gt; java Main 1010   Python  pythonに関しては、数値を2進数に変換して表示する組み込み関数bin()がある。\n表示される文字はプレフィックスとして\u0026rdquo;0b\u0026rdquo;が頭について表示される。\n\u0026gt;\u0026gt;\u0026gt; a = 10 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; bin(a) \u0026#39;0b1010\u0026#39; \u0026gt;\u0026gt;\u0026gt;    "},{"idx":223,"href":"/docs/sample/creating-a-new-theme/","title":"Creating a New Theme","content":" Introduction This tutorial will show you how to create a simple theme in Hugo. I assume that you are familiar with HTML, the bash command line, and that you are comfortable using Markdown to format content. I\u0026rsquo;ll explain how Hugo uses templates and how you can organize your templates to create a theme. I won\u0026rsquo;t cover using CSS to style your theme.\nWe\u0026rsquo;ll start with creating a new site with a very basic template. Then we\u0026rsquo;ll add in a few pages and posts. With small variations on that, you will be able to create many different types of web sites.\nIn this tutorial, commands that you enter will start with the \u0026ldquo;$\u0026rdquo; prompt. The output will follow. Lines that start with \u0026ldquo;#\u0026rdquo; are comments that I\u0026rsquo;ve added to explain a point. When I show updates to a file, the \u0026ldquo;:wq\u0026rdquo; on the last line means to save the file.\nHere\u0026rsquo;s an example:\n## this is a comment $ echo this is a command this is a command ## edit the file $ vi foo.md +++ date = \u0026quot;2014-09-28\u0026quot; title = \u0026quot;creating a new theme\u0026quot; +++ bah and humbug :wq ## show it $ cat foo.md +++ date = \u0026quot;2014-09-28\u0026quot; title = \u0026quot;creating a new theme\u0026quot; +++ bah and humbug $  Some Definitions There are a few concepts that you need to understand before creating a theme.\nSkins Skins are the files responsible for the look and feel of your site. It’s the CSS that controls colors and fonts, it’s the Javascript that determines actions and reactions. It’s also the rules that Hugo uses to transform your content into the HTML that the site will serve to visitors.\nYou have two ways to create a skin. The simplest way is to create it in the layouts/ directory. If you do, then you don’t have to worry about configuring Hugo to recognize it. The first place that Hugo will look for rules and files is in the layouts/ directory so it will always find the skin.\nYour second choice is to create it in a sub-directory of the themes/ directory. If you do, then you must always tell Hugo where to search for the skin. It’s extra work, though, so why bother with it?\nThe difference between creating a skin in layouts/ and creating it in themes/ is very subtle. A skin in layouts/ can’t be customized without updating the templates and static files that it is built from. A skin created in themes/, on the other hand, can be and that makes it easier for other people to use it.\nThe rest of this tutorial will call a skin created in the themes/ directory a theme.\nNote that you can use this tutorial to create a skin in the layouts/ directory if you wish to. The main difference will be that you won’t need to update the site’s configuration file to use a theme.\nThe Home Page The home page, or landing page, is the first page that many visitors to a site see. It is the index.html file in the root directory of the web site. Since Hugo writes files to the public/ directory, our home page is public/index.html.\nSite Configuration File When Hugo runs, it looks for a configuration file that contains settings that override default values for the entire site. The file can use TOML, YAML, or JSON. I prefer to use TOML for my configuration files. If you prefer to use JSON or YAML, you’ll need to translate my examples. You’ll also need to change the name of the file since Hugo uses the extension to determine how to process it.\nHugo translates Markdown files into HTML. By default, Hugo expects to find Markdown files in your content/ directory and template files in your themes/ directory. It will create HTML files in your public/ directory. You can change this by specifying alternate locations in the configuration file.\nContent Content is stored in text files that contain two sections. The first section is the “front matter,” which is the meta-information on the content. The second section contains Markdown that will be converted to HTML.\nFront Matter The front matter is information about the content. Like the configuration file, it can be written in TOML, YAML, or JSON. Unlike the configuration file, Hugo doesn’t use the file’s extension to know the format. It looks for markers to signal the type. TOML is surrounded by “+++”, YAML by “---”, and JSON is enclosed in curly braces. I prefer to use TOML, so you’ll need to translate my examples if you prefer YAML or JSON.\nThe information in the front matter is passed into the template before the content is rendered into HTML.\nMarkdown Content is written in Markdown which makes it easier to create the content. Hugo runs the content through a Markdown engine to create the HTML which will be written to the output file.\nTemplate Files Hugo uses template files to render content into HTML. Template files are a bridge between the content and presentation. Rules in the template define what content is published, where it\u0026rsquo;s published to, and how it will rendered to the HTML file. The template guides the presentation by specifying the style to use.\nThere are three types of templates: single, list, and partial. Each type takes a bit of content as input and transforms it based on the commands in the template.\nHugo uses its knowledge of the content to find the template file used to render the content. If it can’t find a template that is an exact match for the content, it will shift up a level and search from there. It will continue to do so until it finds a matching template or runs out of templates to try. If it can’t find a template, it will use the default template for the site.\nPlease note that you can use the front matter to influence Hugo’s choice of templates.\nSingle Template A single template is used to render a single piece of content. For example, an article or post would be a single piece of content and use a single template.\nList Template A list template renders a group of related content. That could be a summary of recent postings or all articles in a category. List templates can contain multiple groups.\nThe homepage template is a special type of list template. Hugo assumes that the home page of your site will act as the portal for the rest of the content in the site.\nPartial Template A partial template is a template that can be included in other templates. Partial templates must be called using the “partial” template command. They are very handy for rolling up common behavior. For example, your site may have a banner that all pages use. Instead of copying the text of the banner into every single and list template, you could create a partial with the banner in it. That way if you decide to change the banner, you only have to change the partial template.\nCreate a New Site Let\u0026rsquo;s use Hugo to create a new web site. I\u0026rsquo;m a Mac user, so I\u0026rsquo;ll create mine in my home directory, in the Sites folder. If you\u0026rsquo;re using Linux, you might have to create the folder first.\nThe \u0026ldquo;new site\u0026rdquo; command will create a skeleton of a site. It will give you the basic directory structure and a useable configuration file.\n$ hugo new site ~/Sites/zafta $ cd ~/Sites/zafta $ ls -l total 8 drwxr-xr-x 7 quoha staff 238 Sep 29 16:49 . drwxr-xr-x 3 quoha staff 102 Sep 29 16:49 .. drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 archetypes -rw-r--r-- 1 quoha staff 82 Sep 29 16:49 config.toml drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 content drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 layouts drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 static $  Take a look in the content/ directory to confirm that it is empty.\nThe other directories (archetypes/, layouts/, and static/) are used when customizing a theme. That\u0026rsquo;s a topic for a different tutorial, so please ignore them for now.\nGenerate the HTML For the New Site Running the hugo command with no options will read all the available content and generate the HTML files. It will also copy all static files (that\u0026rsquo;s everything that\u0026rsquo;s not content). Since we have an empty site, it won\u0026rsquo;t do much, but it will do it very quickly.\n$ hugo --verbose INFO: 2014/09/29 Using config file: config.toml INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/ WARN: 2014/09/29 Unable to locate layout: [index.html _default/list.html _default/single.html] WARN: 2014/09/29 Unable to locate layout: [404.html] 0 draft content 0 future content 0 pages created 0 tags created 0 categories created in 2 ms $  The \u0026ldquo;--verbose\u0026rdquo; flag gives extra information that will be helpful when we build the template. Every line of the output that starts with \u0026ldquo;INFO:\u0026rdquo; or \u0026ldquo;WARN:\u0026rdquo; is present because we used that flag. The lines that start with \u0026ldquo;WARN:\u0026rdquo; are warning messages. We\u0026rsquo;ll go over them later.\nWe can verify that the command worked by looking at the directory again.\n$ ls -l total 8 drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 archetypes -rw-r--r-- 1 quoha staff 82 Sep 29 16:49 config.toml drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 content drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 layouts drwxr-xr-x 4 quoha staff 136 Sep 29 17:02 public drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 static $  See that new public/ directory? Hugo placed all generated content there. When you\u0026rsquo;re ready to publish your web site, that\u0026rsquo;s the place to start. For now, though, let\u0026rsquo;s just confirm that we have what we\u0026rsquo;d expect from a site with no content.\n$ ls -l public total 16 -rw-r--r-- 1 quoha staff 416 Sep 29 17:02 index.xml -rw-r--r-- 1 quoha staff 262 Sep 29 17:02 sitemap.xml $  Hugo created two XML files, which is standard, but there are no HTML files.\nTest the New Site Verify that you can run the built-in web server. It will dramatically shorten your development cycle if you do. Start it by running the \u0026ldquo;server\u0026rdquo; command. If it is successful, you will see output similar to the following:\n$ hugo server --verbose INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/ WARN: 2014/09/29 Unable to locate layout: [index.html _default/list.html _default/single.html] WARN: 2014/09/29 Unable to locate layout: [404.html] 0 draft content 0 future content 0 pages created 0 tags created 0 categories created in 2 ms Serving pages from /Users/quoha/Sites/zafta/public Web Server is available at http://localhost:1313 Press Ctrl+C to stop  Connect to the listed URL (it\u0026rsquo;s on the line that starts with \u0026ldquo;Web Server\u0026rdquo;). If everything is working correctly, you should get a page that shows the following:\nindex.xml sitemap.xml  That\u0026rsquo;s a listing of your public/ directory. Hugo didn\u0026rsquo;t create a home page because our site has no content. When there\u0026rsquo;s no index.html file in a directory, the server lists the files in the directory, which is what you should see in your browser.\nLet’s go back and look at those warnings again.\nWARN: 2014/09/29 Unable to locate layout: [index.html _default/list.html _default/single.html] WARN: 2014/09/29 Unable to locate layout: [404.html]  That second warning is easier to explain. We haven’t created a template to be used to generate “page not found errors.” The 404 message is a topic for a separate tutorial.\nNow for the first warning. It is for the home page. You can tell because the first layout that it looked for was “index.html.” That’s only used by the home page.\nI like that the verbose flag causes Hugo to list the files that it\u0026rsquo;s searching for. For the home page, they are index.html, _default/list.html, and _default/single.html. There are some rules that we\u0026rsquo;ll cover later that explain the names and paths. For now, just remember that Hugo couldn\u0026rsquo;t find a template for the home page and it told you so.\nAt this point, you\u0026rsquo;ve got a working installation and site that we can build upon. All that’s left is to add some content and a theme to display it.\nCreate a New Theme Hugo doesn\u0026rsquo;t ship with a default theme. There are a few available (I counted a dozen when I first installed Hugo) and Hugo comes with a command to create new themes.\nWe\u0026rsquo;re going to create a new theme called \u0026ldquo;zafta.\u0026rdquo; Since the goal of this tutorial is to show you how to fill out the files to pull in your content, the theme will not contain any CSS. In other words, ugly but functional.\nAll themes have opinions on content and layout. For example, Zafta uses \u0026ldquo;post\u0026rdquo; over \u0026ldquo;blog\u0026rdquo;. Strong opinions make for simpler templates but differing opinions make it tougher to use themes. When you build a theme, consider using the terms that other themes do.\nCreate a Skeleton Use the hugo \u0026ldquo;new\u0026rdquo; command to create the skeleton of a theme. This creates the directory structure and places empty files for you to fill out.\n$ hugo new theme zafta $ ls -l total 8 drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 archetypes -rw-r--r-- 1 quoha staff 82 Sep 29 16:49 config.toml drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 content drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 layouts drwxr-xr-x 4 quoha staff 136 Sep 29 17:02 public drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 static drwxr-xr-x 3 quoha staff 102 Sep 29 17:31 themes $ find themes -type f | xargs ls -l -rw-r--r-- 1 quoha staff 1081 Sep 29 17:31 themes/zafta/LICENSE.md -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/archetypes/default.md -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/_default/list.html -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/_default/single.html -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/index.html -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/partials/footer.html -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/partials/header.html -rw-r--r-- 1 quoha staff 93 Sep 29 17:31 themes/zafta/theme.toml $  The skeleton includes templates (the files ending in .html), license file, a description of your theme (the theme.toml file), and an empty archetype.\nPlease take a minute to fill out the theme.toml and LICENSE.md files. They\u0026rsquo;re optional, but if you\u0026rsquo;re going to be distributing your theme, it tells the world who to praise (or blame). It\u0026rsquo;s also nice to declare the license so that people will know how they can use the theme.\n$ vi themes/zafta/theme.toml author = \u0026quot;michael d henderson\u0026quot; description = \u0026quot;a minimal working template\u0026quot; license = \u0026quot;MIT\u0026quot; name = \u0026quot;zafta\u0026quot; source_repo = \u0026quot;\u0026quot; tags = [\u0026quot;tags\u0026quot;, \u0026quot;categories\u0026quot;] :wq ## also edit themes/zafta/LICENSE.md and change ## the bit that says \u0026quot;YOUR_NAME_HERE\u0026quot;  Note that the the skeleton\u0026rsquo;s template files are empty. Don\u0026rsquo;t worry, we\u0026rsquo;ll be changing that shortly.\n$ find themes/zafta -name '*.html' | xargs ls -l -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/_default/list.html -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/_default/single.html -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/index.html -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/partials/footer.html -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/partials/header.html $  Update the Configuration File to Use the Theme Now that we\u0026rsquo;ve got a theme to work with, it\u0026rsquo;s a good idea to add the theme name to the configuration file. This is optional, because you can always add \u0026ldquo;-t zafta\u0026rdquo; on all your commands. I like to put it the configuration file because I like shorter command lines. If you don\u0026rsquo;t put it in the configuration file or specify it on the command line, you won\u0026rsquo;t use the template that you\u0026rsquo;re expecting to.\nEdit the file to add the theme, add a title for the site, and specify that all of our content will use the TOML format.\n$ vi config.toml theme = \u0026quot;zafta\u0026quot; baseurl = \u0026quot;\u0026quot; languageCode = \u0026quot;en-us\u0026quot; title = \u0026quot;zafta - totally refreshing\u0026quot; MetaDataFormat = \u0026quot;toml\u0026quot; :wq $  Generate the Site Now that we have an empty theme, let\u0026rsquo;s generate the site again.\n$ hugo --verbose INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/ INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/ WARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html] 0 draft content 0 future content 0 pages created 0 tags created 0 categories created in 2 ms $  Did you notice that the output is different? The warning message for the home page has disappeared and we have an additional information line saying that Hugo is syncing from the theme\u0026rsquo;s directory.\nLet\u0026rsquo;s check the public/ directory to see what Hugo\u0026rsquo;s created.\n$ ls -l public total 16 drwxr-xr-x 2 quoha staff 68 Sep 29 17:56 css -rw-r--r-- 1 quoha staff 0 Sep 29 17:56 index.html -rw-r--r-- 1 quoha staff 407 Sep 29 17:56 index.xml drwxr-xr-x 2 quoha staff 68 Sep 29 17:56 js -rw-r--r-- 1 quoha staff 243 Sep 29 17:56 sitemap.xml $  Notice four things:\n Hugo created a home page. This is the file public/index.html. Hugo created a css/ directory. Hugo created a js/ directory. Hugo claimed that it created 0 pages. It created a file and copied over static files, but didn\u0026rsquo;t create any pages. That\u0026rsquo;s because it considers a \u0026ldquo;page\u0026rdquo; to be a file created directly from a content file. It doesn\u0026rsquo;t count things like the index.html files that it creates automatically.  The Home Page Hugo supports many different types of templates. The home page is special because it gets its own type of template and its own template file. The file, layouts/index.html, is used to generate the HTML for the home page. The Hugo documentation says that this is the only required template, but that depends. Hugo\u0026rsquo;s warning message shows that it looks for three different templates:\nWARN: 2014/09/29 Unable to locate layout: [index.html _default/list.html _default/single.html]  If it can\u0026rsquo;t find any of these, it completely skips creating the home page. We noticed that when we built the site without having a theme installed.\nWhen Hugo created our theme, it created an empty home page template. Now, when we build the site, Hugo finds the template and uses it to generate the HTML for the home page. Since the template file is empty, the HTML file is empty, too. If the template had any rules in it, then Hugo would have used them to generate the home page.\n$ find . -name index.html | xargs ls -l -rw-r--r-- 1 quoha staff 0 Sep 29 20:21 ./public/index.html -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 ./themes/zafta/layouts/index.html $  The Magic of Static Hugo does two things when generating the site. It uses templates to transform content into HTML and it copies static files into the site. Unlike content, static files are not transformed. They are copied exactly as they are.\nHugo assumes that your site will use both CSS and JavaScript, so it creates directories in your theme to hold them. Remember opinions? Well, Hugo\u0026rsquo;s opinion is that you\u0026rsquo;ll store your CSS in a directory named css/ and your JavaScript in a directory named js/. If you don\u0026rsquo;t like that, you can change the directory names in your theme directory or even delete them completely. Hugo\u0026rsquo;s nice enough to offer its opinion, then behave nicely if you disagree.\n$ find themes/zafta -type d | xargs ls -ld drwxr-xr-x 7 quoha staff 238 Sep 29 17:38 themes/zafta drwxr-xr-x 3 quoha staff 102 Sep 29 17:31 themes/zafta/archetypes drwxr-xr-x 5 quoha staff 170 Sep 29 17:31 themes/zafta/layouts drwxr-xr-x 4 quoha staff 136 Sep 29 17:31 themes/zafta/layouts/_default drwxr-xr-x 4 quoha staff 136 Sep 29 17:31 themes/zafta/layouts/partials drwxr-xr-x 4 quoha staff 136 Sep 29 17:31 themes/zafta/static drwxr-xr-x 2 quoha staff 68 Sep 29 17:31 themes/zafta/static/css drwxr-xr-x 2 quoha staff 68 Sep 29 17:31 themes/zafta/static/js $  The Theme Development Cycle When you\u0026rsquo;re working on a theme, you will make changes in the theme\u0026rsquo;s directory, rebuild the site, and check your changes in the browser. Hugo makes this very easy:\n Purge the public/ directory. Run the built in web server in watch mode. Open your site in a browser. Update the theme. Glance at your browser window to see changes. Return to step 4.  I’ll throw in one more opinion: never work on a theme on a live site. Always work on a copy of your site. Make changes to your theme, test them, then copy them up to your site. For added safety, use a tool like Git to keep a revision history of your content and your theme. Believe me when I say that it is too easy to lose both your mind and your changes.\nCheck the main Hugo site for information on using Git with Hugo.\nPurge the public/ Directory When generating the site, Hugo will create new files and update existing ones in the public/ directory. It will not delete files that are no longer used. For example, files that were created in the wrong directory or with the wrong title will remain. If you leave them, you might get confused by them later. I recommend cleaning out your site prior to generating it.\nNote: If you\u0026rsquo;re building on an SSD, you should ignore this. Churning on a SSD can be costly.\nHugo\u0026rsquo;s Watch Option Hugo\u0026rsquo;s \u0026ldquo;--watch\u0026rdquo; option will monitor the content/ and your theme directories for changes and rebuild the site automatically.\nLive Reload Hugo\u0026rsquo;s built in web server supports live reload. As pages are saved on the server, the browser is told to refresh the page. Usually, this happens faster than you can say, \u0026ldquo;Wow, that\u0026rsquo;s totally amazing.\u0026rdquo;\nDevelopment Commands Use the following commands as the basis for your workflow.\n## purge old files. hugo will recreate the public directory. ## $ rm -rf public ## ## run hugo in watch mode ## $ hugo server --watch --verbose  Here\u0026rsquo;s sample output showing Hugo detecting a change to the template for the home page. Once generated, the web browser automatically reloaded the page. I\u0026rsquo;ve said this before, it\u0026rsquo;s amazing.\n$ rm -rf public $ hugo server --watch --verbose INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/ INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/ WARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html] 0 draft content 0 future content 0 pages created 0 tags created 0 categories created in 2 ms Watching for changes in /Users/quoha/Sites/zafta/content Serving pages from /Users/quoha/Sites/zafta/public Web Server is available at http://localhost:1313 Press Ctrl+C to stop INFO: 2014/09/29 File System Event: [\u0026quot;/Users/quoha/Sites/zafta/themes/zafta/layouts/index.html\u0026quot;: MODIFY|ATTRIB] Change detected, rebuilding site WARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html] 0 draft content 0 future content 0 pages created 0 tags created 0 categories created in 1 ms  Update the Home Page Template The home page is one of a few special pages that Hugo creates automatically. As mentioned earlier, it looks for one of three files in the theme\u0026rsquo;s layout/ directory:\n index.html _default/list.html _default/single.html  We could update one of the default templates, but a good design decision is to update the most specific template available. That\u0026rsquo;s not a hard and fast rule (in fact, we\u0026rsquo;ll break it a few times in this tutorial), but it is a good generalization.\nMake a Static Home Page Right now, that page is empty because we don\u0026rsquo;t have any content and we don\u0026rsquo;t have any logic in the template. Let\u0026rsquo;s change that by adding some text to the template.\n$ vi themes/zafta/layouts/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;hugo says hello!\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; :wq $  Build the web site and then verify the results.\n$ hugo --verbose INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/ INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/ WARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html] 0 draft content 0 future content 0 pages created 0 tags created 0 categories created in 2 ms $ find public -type f -name '*.html' | xargs ls -l -rw-r--r-- 1 quoha staff 78 Sep 29 21:26 public/index.html $ cat public/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;hugo says hello!\u0026lt;/p\u0026gt; \u0026lt;/html\u0026gt;  Live Reload Note: If you\u0026rsquo;re running the server with the --watch option, you\u0026rsquo;ll see different content in the file:\n$ cat public/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;hugo says hello!\u0026lt;/p\u0026gt; \u0026lt;script\u0026gt;document.write('\u0026lt;script src=\u0026quot;http://' + (location.host || 'localhost').split(':')[0] + ':1313/livereload.js?mindelay=10\u0026quot;\u0026gt;\u0026lt;/' + 'script\u0026gt;')\u0026lt;/script\u0026gt;\u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  When you use --watch, the Live Reload script is added by Hugo. Look for live reload in the documentation to see what it does and how to disable it.\nBuild a \u0026ldquo;Dynamic\u0026rdquo; Home Page \u0026ldquo;Dynamic home page?\u0026rdquo; Hugo\u0026rsquo;s a static web site generator, so this seems an odd thing to say. I mean let\u0026rsquo;s have the home page automatically reflect the content in the site every time Hugo builds it. We\u0026rsquo;ll use iteration in the template to do that.\nCreate New Posts Now that we have the home page generating static content, let\u0026rsquo;s add some content to the site. We\u0026rsquo;ll display these posts as a list on the home page and on their own page, too.\nHugo has a command to generate a skeleton post, just like it does for sites and themes.\n$ hugo --verbose new post/first.md INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml INFO: 2014/09/29 attempting to create post/first.md of post INFO: 2014/09/29 curpath: /Users/quoha/Sites/zafta/themes/zafta/archetypes/default.md ERROR: 2014/09/29 Unable to Cast \u0026lt;nil\u0026gt; to map[string]interface{} $  That wasn\u0026rsquo;t very nice, was it?\nThe \u0026ldquo;new\u0026rdquo; command uses an archetype to create the post file. Hugo created an empty default archetype file, but that causes an error when there\u0026rsquo;s a theme. For me, the workaround was to create an archetypes file specifically for the post type.\n$ vi themes/zafta/archetypes/post.md +++ Description = \u0026quot;\u0026quot; Tags = [] Categories = [] +++ :wq $ find themes/zafta/archetypes -type f | xargs ls -l -rw-r--r-- 1 quoha staff 0 Sep 29 21:53 themes/zafta/archetypes/default.md -rw-r--r-- 1 quoha staff 51 Sep 29 21:54 themes/zafta/archetypes/post.md $ hugo --verbose new post/first.md INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml INFO: 2014/09/29 attempting to create post/first.md of post INFO: 2014/09/29 curpath: /Users/quoha/Sites/zafta/themes/zafta/archetypes/post.md INFO: 2014/09/29 creating /Users/quoha/Sites/zafta/content/post/first.md /Users/quoha/Sites/zafta/content/post/first.md created $ hugo --verbose new post/second.md INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml INFO: 2014/09/29 attempting to create post/second.md of post INFO: 2014/09/29 curpath: /Users/quoha/Sites/zafta/themes/zafta/archetypes/post.md INFO: 2014/09/29 creating /Users/quoha/Sites/zafta/content/post/second.md /Users/quoha/Sites/zafta/content/post/second.md created $ ls -l content/post total 16 -rw-r--r-- 1 quoha staff 104 Sep 29 21:54 first.md -rw-r--r-- 1 quoha staff 105 Sep 29 21:57 second.md $ cat content/post/first.md +++ Categories = [] Description = \u0026quot;\u0026quot; Tags = [] date = \u0026quot;2014-09-29T21:54:53-05:00\u0026quot; title = \u0026quot;first\u0026quot; +++ my first post $ cat content/post/second.md +++ Categories = [] Description = \u0026quot;\u0026quot; Tags = [] date = \u0026quot;2014-09-29T21:57:09-05:00\u0026quot; title = \u0026quot;second\u0026quot; +++ my second post $  Build the web site and then verify the results.\n$ rm -rf public $ hugo --verbose INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/ INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/ INFO: 2014/09/29 found taxonomies: map[string]string{\u0026quot;category\u0026quot;:\u0026quot;categories\u0026quot;, \u0026quot;tag\u0026quot;:\u0026quot;tags\u0026quot;} WARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html] 0 draft content 0 future content 2 pages created 0 tags created 0 categories created in 4 ms $  The output says that it created 2 pages. Those are our new posts:\n$ find public -type f -name '*.html' | xargs ls -l -rw-r--r-- 1 quoha staff 78 Sep 29 22:13 public/index.html -rw-r--r-- 1 quoha staff 0 Sep 29 22:13 public/post/first/index.html -rw-r--r-- 1 quoha staff 0 Sep 29 22:13 public/post/index.html -rw-r--r-- 1 quoha staff 0 Sep 29 22:13 public/post/second/index.html $  The new files are empty because because the templates used to generate the content are empty. The homepage doesn\u0026rsquo;t show the new content, either. We have to update the templates to add the posts.\nList and Single Templates In Hugo, we have three major kinds of templates. There\u0026rsquo;s the home page template that we updated previously. It is used only by the home page. We also have \u0026ldquo;single\u0026rdquo; templates which are used to generate output for a single content file. We also have \u0026ldquo;list\u0026rdquo; templates that are used to group multiple pieces of content before generating output.\nGenerally speaking, list templates are named \u0026ldquo;list.html\u0026rdquo; and single templates are named \u0026ldquo;single.html.\u0026rdquo;\nThere are three other types of templates: partials, content views, and terms. We will not go into much detail on these.\nAdd Content to the Homepage The home page will contain a list of posts. Let\u0026rsquo;s update its template to add the posts that we just created. The logic in the template will run every time we build the site.\n$ vi themes/zafta/layouts/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; {{ range first 10 .Data.Pages }} \u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt; {{ end }} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; :wq $  Hugo uses the Go template engine. That engine scans the template files for commands which are enclosed between \u0026ldquo;{{\u0026rdquo; and \u0026ldquo;}}\u0026rdquo;. In our template, the commands are:\n range .Title end  The \u0026ldquo;range\u0026rdquo; command is an iterator. We\u0026rsquo;re going to use it to go through the first ten pages. Every HTML file that Hugo creates is treated as a page, so looping through the list of pages will look at every file that will be created.\nThe \u0026ldquo;.Title\u0026rdquo; command prints the value of the \u0026ldquo;title\u0026rdquo; variable. Hugo pulls it from the front matter in the Markdown file.\nThe \u0026ldquo;end\u0026rdquo; command signals the end of the range iterator. The engine loops back to the top of the iteration when it finds \u0026ldquo;end.\u0026rdquo; Everything between the \u0026ldquo;range\u0026rdquo; and \u0026ldquo;end\u0026rdquo; is evaluated every time the engine goes through the iteration. In this file, that would cause the title from the first ten pages to be output as heading level one.\nIt\u0026rsquo;s helpful to remember that some variables, like .Data, are created before any output files. Hugo loads every content file into the variable and then gives the template a chance to process before creating the HTML files.\nBuild the web site and then verify the results.\n$ rm -rf public $ hugo --verbose INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/ INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/ INFO: 2014/09/29 found taxonomies: map[string]string{\u0026quot;tag\u0026quot;:\u0026quot;tags\u0026quot;, \u0026quot;category\u0026quot;:\u0026quot;categories\u0026quot;} WARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html] 0 draft content 0 future content 2 pages created 0 tags created 0 categories created in 4 ms $ find public -type f -name '*.html' | xargs ls -l -rw-r--r-- 1 quoha staff 94 Sep 29 22:23 public/index.html -rw-r--r-- 1 quoha staff 0 Sep 29 22:23 public/post/first/index.html -rw-r--r-- 1 quoha staff 0 Sep 29 22:23 public/post/index.html -rw-r--r-- 1 quoha staff 0 Sep 29 22:23 public/post/second/index.html $ cat public/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;second\u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt;first\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; $  Congratulations, the home page shows the title of the two posts. The posts themselves are still empty, but let\u0026rsquo;s take a moment to appreciate what we\u0026rsquo;ve done. Your template now generates output dynamically. Believe it or not, by inserting the range command inside of those curly braces, you\u0026rsquo;ve learned everything you need to know to build a theme. All that\u0026rsquo;s really left is understanding which template will be used to generate each content file and becoming familiar with the commands for the template engine.\nAnd, if that were entirely true, this tutorial would be much shorter. There are a few things to know that will make creating a new template much easier. Don\u0026rsquo;t worry, though, that\u0026rsquo;s all to come.\nAdd Content to the Posts We\u0026rsquo;re working with posts, which are in the content/post/ directory. That means that their section is \u0026ldquo;post\u0026rdquo; (and if we don\u0026rsquo;t do something weird, their type is also \u0026ldquo;post\u0026rdquo;).\nHugo uses the section and type to find the template file for every piece of content. Hugo will first look for a template file that matches the section or type name. If it can\u0026rsquo;t find one, then it will look in the _default/ directory. There are some twists that we\u0026rsquo;ll cover when we get to categories and tags, but for now we can assume that Hugo will try post/single.html, then _default/single.html.\nNow that we know the search rule, let\u0026rsquo;s see what we actually have available:\n$ find themes/zafta -name single.html | xargs ls -l -rw-r--r-- 1 quoha staff 132 Sep 29 17:31 themes/zafta/layouts/_default/single.html  We could create a new template, post/single.html, or change the default. Since we don\u0026rsquo;t know of any other content types, let\u0026rsquo;s start with updating the default.\nRemember, any content that we haven\u0026rsquo;t created a template for will end up using this template. That can be good or bad. Bad because I know that we\u0026rsquo;re going to be adding different types of content and we\u0026rsquo;re going to end up undoing some of the changes we\u0026rsquo;ve made. It\u0026rsquo;s good because we\u0026rsquo;ll be able to see immediate results. It\u0026rsquo;s also good to start here because we can start to build the basic layout for the site. As we add more content types, we\u0026rsquo;ll refactor this file and move logic around. Hugo makes that fairly painless, so we\u0026rsquo;ll accept the cost and proceed.\nPlease see the Hugo documentation on template rendering for all the details on determining which template to use. And, as the docs mention, if you\u0026rsquo;re building a single page application (SPA) web site, you can delete all of the other templates and work with just the default single page. That\u0026rsquo;s a refreshing amount of joy right there.\nUpdate the Template File $ vi themes/zafta/layouts/_default/single.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;{{ .Title }}\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt; {{ .Content }} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; :wq $  Build the web site and verify the results.\n$ rm -rf public $ hugo --verbose INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/ INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/ INFO: 2014/09/29 found taxonomies: map[string]string{\u0026quot;tag\u0026quot;:\u0026quot;tags\u0026quot;, \u0026quot;category\u0026quot;:\u0026quot;categories\u0026quot;} WARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html] 0 draft content 0 future content 2 pages created 0 tags created 0 categories created in 4 ms $ find public -type f -name '*.html' | xargs ls -l -rw-r--r-- 1 quoha staff 94 Sep 29 22:40 public/index.html -rw-r--r-- 1 quoha staff 125 Sep 29 22:40 public/post/first/index.html -rw-r--r-- 1 quoha staff 0 Sep 29 22:40 public/post/index.html -rw-r--r-- 1 quoha staff 128 Sep 29 22:40 public/post/second/index.html $ cat public/post/first/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;first\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;first\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;my first post\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; $ cat public/post/second/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;second\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;second\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;my second post\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; $  Notice that the posts now have content. You can go to localhost:1313/post/first to verify.\nLinking to Content The posts are on the home page. Let\u0026rsquo;s add a link from there to the post. Since this is the home page, we\u0026rsquo;ll update its template.\n$ vi themes/zafta/layouts/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; {{ range first 10 .Data.Pages }} \u0026lt;h1\u0026gt;\u0026lt;a href=\u0026quot;{{ .Permalink }}\u0026quot;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt; {{ end }} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  Build the web site and verify the results.\n$ rm -rf public $ hugo --verbose INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/ INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/ INFO: 2014/09/29 found taxonomies: map[string]string{\u0026quot;tag\u0026quot;:\u0026quot;tags\u0026quot;, \u0026quot;category\u0026quot;:\u0026quot;categories\u0026quot;} WARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html] 0 draft content 0 future content 2 pages created 0 tags created 0 categories created in 4 ms $ find public -type f -name '*.html' | xargs ls -l -rw-r--r-- 1 quoha staff 149 Sep 29 22:44 public/index.html -rw-r--r-- 1 quoha staff 125 Sep 29 22:44 public/post/first/index.html -rw-r--r-- 1 quoha staff 0 Sep 29 22:44 public/post/index.html -rw-r--r-- 1 quoha staff 128 Sep 29 22:44 public/post/second/index.html $ cat public/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;\u0026lt;a href=\u0026quot;/post/second/\u0026quot;\u0026gt;second\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt;\u0026lt;a href=\u0026quot;/post/first/\u0026quot;\u0026gt;first\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; $  Create a Post Listing We have the posts displaying on the home page and on their own page. We also have a file public/post/index.html that is empty. Let\u0026rsquo;s make it show a list of all posts (not just the first ten).\nWe need to decide which template to update. This will be a listing, so it should be a list template. Let\u0026rsquo;s take a quick look and see which list templates are available.\n$ find themes/zafta -name list.html | xargs ls -l -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/_default/list.html  As with the single post, we have to decide to update _default/list.html or create post/list.html. We still don\u0026rsquo;t have multiple content types, so let\u0026rsquo;s stay consistent and update the default list template.\nCreating Top Level Pages Let\u0026rsquo;s add an \u0026ldquo;about\u0026rdquo; page and display it at the top level (as opposed to a sub-level like we did with posts).\nThe default in Hugo is to use the directory structure of the content/ directory to guide the location of the generated html in the public/ directory. Let\u0026rsquo;s verify that by creating an \u0026ldquo;about\u0026rdquo; page at the top level:\n$ vi content/about.md +++ title = \u0026quot;about\u0026quot; description = \u0026quot;about this site\u0026quot; date = \u0026quot;2014-09-27\u0026quot; slug = \u0026quot;about time\u0026quot; +++ ## about us i'm speechless :wq  Generate the web site and verify the results.\n$ find public -name '*.html' | xargs ls -l -rw-rw-r-- 1 mdhender staff 334 Sep 27 15:08 public/about-time/index.html -rw-rw-r-- 1 mdhender staff 527 Sep 27 15:08 public/index.html -rw-rw-r-- 1 mdhender staff 358 Sep 27 15:08 public/post/first-post/index.html -rw-rw-r-- 1 mdhender staff 0 Sep 27 15:08 public/post/index.html -rw-rw-r-- 1 mdhender staff 342 Sep 27 15:08 public/post/second-post/index.html  Notice that the page wasn\u0026rsquo;t created at the top level. It was created in a sub-directory named \u0026lsquo;about-time/\u0026rsquo;. That name came from our slug. Hugo will use the slug to name the generated content. It\u0026rsquo;s a reasonable default, by the way, but we can learn a few things by fighting it for this file.\nOne other thing. Take a look at the home page.\n$ cat public/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;\u0026lt;a href=\u0026quot;http://localhost:1313/post/theme/\u0026quot;\u0026gt;creating a new theme\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt;\u0026lt;a href=\u0026quot;http://localhost:1313/about-time/\u0026quot;\u0026gt;about\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt;\u0026lt;a href=\u0026quot;http://localhost:1313/post/second-post/\u0026quot;\u0026gt;second\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt;\u0026lt;a href=\u0026quot;http://localhost:1313/post/first-post/\u0026quot;\u0026gt;first\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;script\u0026gt;document.write('\u0026lt;script src=\u0026quot;http://' + (location.host || 'localhost').split(':')[0] + ':1313/livereload.js?mindelay=10\u0026quot;\u0026gt;\u0026lt;/' + 'script\u0026gt;')\u0026lt;/script\u0026gt;\u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  Notice that the \u0026ldquo;about\u0026rdquo; link is listed with the posts? That\u0026rsquo;s not desirable, so let\u0026rsquo;s change that first.\n$ vi themes/zafta/layouts/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;posts\u0026lt;/h1\u0026gt; {{ range first 10 .Data.Pages }} {{ if eq .Type \u0026quot;post\u0026quot;}} \u0026lt;h2\u0026gt;\u0026lt;a href=\u0026quot;{{ .Permalink }}\u0026quot;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt;\u0026lt;/h2\u0026gt; {{ end }} {{ end }} \u0026lt;h1\u0026gt;pages\u0026lt;/h1\u0026gt; {{ range .Data.Pages }} {{ if eq .Type \u0026quot;page\u0026quot; }} \u0026lt;h2\u0026gt;\u0026lt;a href=\u0026quot;{{ .Permalink }}\u0026quot;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt;\u0026lt;/h2\u0026gt; {{ end }} {{ end }} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; :wq  Generate the web site and verify the results. The home page has two sections, posts and pages, and each section has the right set of headings and links in it.\nBut, that about page still renders to about-time/index.html.\n$ find public -name '*.html' | xargs ls -l -rw-rw-r-- 1 mdhender staff 334 Sep 27 15:33 public/about-time/index.html -rw-rw-r-- 1 mdhender staff 645 Sep 27 15:33 public/index.html -rw-rw-r-- 1 mdhender staff 358 Sep 27 15:33 public/post/first-post/index.html -rw-rw-r-- 1 mdhender staff 0 Sep 27 15:33 public/post/index.html -rw-rw-r-- 1 mdhender staff 342 Sep 27 15:33 public/post/second-post/index.html  Knowing that hugo is using the slug to generate the file name, the simplest solution is to change the slug. Let\u0026rsquo;s do it the hard way and change the permalink in the configuration file.\n$ vi config.toml [permalinks] page = \u0026quot;/:title/\u0026quot; about = \u0026quot;/:filename/\u0026quot;  Generate the web site and verify that this didn\u0026rsquo;t work. Hugo lets \u0026ldquo;slug\u0026rdquo; or \u0026ldquo;URL\u0026rdquo; override the permalinks setting in the configuration file. Go ahead and comment out the slug in content/about.md, then generate the web site to get it to be created in the right place.\nSharing Templates If you\u0026rsquo;ve been following along, you probably noticed that posts have titles in the browser and the home page doesn\u0026rsquo;t. That\u0026rsquo;s because we didn\u0026rsquo;t put the title in the home page\u0026rsquo;s template (layouts/index.html). That\u0026rsquo;s an easy thing to do, but let\u0026rsquo;s look at a different option.\nWe can put the common bits into a shared template that\u0026rsquo;s stored in the themes/zafta/layouts/partials/ directory.\nCreate the Header and Footer Partials In Hugo, a partial is a sugar-coated template. Normally a template reference has a path specified. Partials are different. Hugo searches for them along a TODO defined search path. This makes it easier for end-users to override the theme\u0026rsquo;s presentation.\n$ vi themes/zafta/layouts/partials/header.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;{{ .Title }}\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; :wq $ vi themes/zafta/layouts/partials/footer.html \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; :wq  Update the Home Page Template to Use the Partials The most noticeable difference between a template call and a partials call is the lack of path:\n{{ template \u0026quot;theme/partials/header.html\u0026quot; . }}  versus\n{{ partial \u0026quot;header.html\u0026quot; . }}  Both pass in the context.\nLet\u0026rsquo;s change the home page template to use these new partials.\n$ vi themes/zafta/layouts/index.html {{ partial \u0026quot;header.html\u0026quot; . }} \u0026lt;h1\u0026gt;posts\u0026lt;/h1\u0026gt; {{ range first 10 .Data.Pages }} {{ if eq .Type \u0026quot;post\u0026quot;}} \u0026lt;h2\u0026gt;\u0026lt;a href=\u0026quot;{{ .Permalink }}\u0026quot;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt;\u0026lt;/h2\u0026gt; {{ end }} {{ end }} \u0026lt;h1\u0026gt;pages\u0026lt;/h1\u0026gt; {{ range .Data.Pages }} {{ if or (eq .Type \u0026quot;page\u0026quot;) (eq .Type \u0026quot;about\u0026quot;) }} \u0026lt;h2\u0026gt;\u0026lt;a href=\u0026quot;{{ .Permalink }}\u0026quot;\u0026gt;{{ .Type }} - {{ .Title }} - {{ .RelPermalink }}\u0026lt;/a\u0026gt;\u0026lt;/h2\u0026gt; {{ end }} {{ end }} {{ partial \u0026quot;footer.html\u0026quot; . }} :wq  Generate the web site and verify the results. The title on the home page is now \u0026ldquo;your title here\u0026rdquo;, which comes from the \u0026ldquo;title\u0026rdquo; variable in the config.toml file.\nUpdate the Default Single Template to Use the Partials $ vi themes/zafta/layouts/_default/single.html {{ partial \u0026quot;header.html\u0026quot; . }} \u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt; {{ .Content }} {{ partial \u0026quot;footer.html\u0026quot; . }} :wq  Generate the web site and verify the results. The title on the posts and the about page should both reflect the value in the markdown file.\nAdd “Date Published” to Posts It\u0026rsquo;s common to have posts display the date that they were written or published, so let\u0026rsquo;s add that. The front matter of our posts has a variable named \u0026ldquo;date.\u0026rdquo; It\u0026rsquo;s usually the date the content was created, but let\u0026rsquo;s pretend that\u0026rsquo;s the value we want to display.\nAdd “Date Published” to the Template We\u0026rsquo;ll start by updating the template used to render the posts. The template code will look like:\n{{ .Date.Format \u0026quot;Mon, Jan 2, 2006\u0026quot; }}  Posts use the default single template, so we\u0026rsquo;ll change that file.\n$ vi themes/zafta/layouts/_default/single.html {{ partial \u0026quot;header.html\u0026quot; . }} \u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;{{ .Date.Format \u0026quot;Mon, Jan 2, 2006\u0026quot; }}\u0026lt;/h2\u0026gt; {{ .Content }} {{ partial \u0026quot;footer.html\u0026quot; . }} :wq  Generate the web site and verify the results. The posts now have the date displayed in them. There\u0026rsquo;s a problem, though. The \u0026ldquo;about\u0026rdquo; page also has the date displayed.\nAs usual, there are a couple of ways to make the date display only on posts. We could do an \u0026ldquo;if\u0026rdquo; statement like we did on the home page. Another way would be to create a separate template for posts.\nThe \u0026ldquo;if\u0026rdquo; solution works for sites that have just a couple of content types. It aligns with the principle of \u0026ldquo;code for today,\u0026rdquo; too.\nLet\u0026rsquo;s assume, though, that we\u0026rsquo;ve made our site so complex that we feel we have to create a new template type. In Hugo-speak, we\u0026rsquo;re going to create a section template.\nLet\u0026rsquo;s restore the default single template before we forget.\n$ mkdir themes/zafta/layouts/post $ vi themes/zafta/layouts/_default/single.html {{ partial \u0026quot;header.html\u0026quot; . }} \u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt; {{ .Content }} {{ partial \u0026quot;footer.html\u0026quot; . }} :wq  Now we\u0026rsquo;ll update the post\u0026rsquo;s version of the single template. If you remember Hugo\u0026rsquo;s rules, the template engine will use this version over the default.\n$ vi themes/zafta/layouts/post/single.html {{ partial \u0026quot;header.html\u0026quot; . }} \u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;{{ .Date.Format \u0026quot;Mon, Jan 2, 2006\u0026quot; }}\u0026lt;/h2\u0026gt; {{ .Content }} {{ partial \u0026quot;footer.html\u0026quot; . }} :wq  Note that we removed the date logic from the default template and put it in the post template. Generate the web site and verify the results. Posts have dates and the about page doesn\u0026rsquo;t.\nDon\u0026rsquo;t Repeat Yourself DRY is a good design goal and Hugo does a great job supporting it. Part of the art of a good template is knowing when to add a new template and when to update an existing one. While you\u0026rsquo;re figuring that out, accept that you\u0026rsquo;ll be doing some refactoring. Hugo makes that easy and fast, so it\u0026rsquo;s okay to delay splitting up a template.\n"},{"idx":224,"href":"/docs/sample/migrate-from-jekyll/","title":"Migrate to Hugo from Jekyll","content":" Move static content to static Jekyll has a rule that any directory not starting with _ will be copied as-is to the _site output. Hugo keeps all static content under static. You should therefore move it all there. With Jekyll, something that looked like\n▾ \u0026lt;root\u0026gt;/ ▾ images/ logo.png  should become\n▾ \u0026lt;root\u0026gt;/ ▾ static/ ▾ images/ logo.png  Additionally, you\u0026rsquo;ll want any files that should reside at the root (such as CNAME) to be moved to static.\nCreate your Hugo configuration file Hugo can read your configuration as JSON, YAML or TOML. Hugo supports parameters custom configuration too. Refer to the Hugo configuration documentation for details.\nSet your configuration publish folder to _site The default is for Jekyll to publish to _site and for Hugo to publish to public. If, like me, you have _site mapped to a git submodule on the gh-pages branch, you\u0026rsquo;ll want to do one of two alternatives:\n Change your submodule to point to map gh-pages to public instead of _site (recommended).\ngit submodule deinit _site git rm _site git submodule add -b gh-pages git@github.com:your-username/your-repo.git public  Or, change the Hugo configuration to use _site instead of public.\n{ .. \u0026quot;publishdir\u0026quot;: \u0026quot;_site\u0026quot;, .. }   Convert Jekyll templates to Hugo templates That\u0026rsquo;s the bulk of the work right here. The documentation is your friend. You should refer to Jekyll\u0026rsquo;s template documentation if you need to refresh your memory on how you built your blog and Hugo\u0026rsquo;s template to learn Hugo\u0026rsquo;s way.\nAs a single reference data point, converting my templates for heyitsalex.net took me no more than a few hours.\nConvert Jekyll plugins to Hugo shortcodes Jekyll has plugins; Hugo has shortcodes. It\u0026rsquo;s fairly trivial to do a port.\nImplementation As an example, I was using a custom image_tag plugin to generate figures with caption when running Jekyll. As I read about shortcodes, I found Hugo had a nice built-in shortcode that does exactly the same thing.\nJekyll\u0026rsquo;s plugin:\nmodule Jekyll class ImageTag \u0026lt; Liquid::Tag @url = nil @caption = nil @class = nil @link = nil // Patterns IMAGE_URL_WITH_CLASS_AND_CAPTION = IMAGE_URL_WITH_CLASS_AND_CAPTION_AND_LINK = /(\\w+)(\\s+)((https?:\\/\\/|\\/)(\\S+))(\\s+)\u0026quot;(.*?)\u0026quot;(\\s+)-\u0026gt;((https?:\\/\\/|\\/)(\\S+))(\\s*)/i IMAGE_URL_WITH_CAPTION = /((https?:\\/\\/|\\/)(\\S+))(\\s+)\u0026quot;(.*?)\u0026quot;/i IMAGE_URL_WITH_CLASS = /(\\w+)(\\s+)((https?:\\/\\/|\\/)(\\S+))/i IMAGE_URL = /((https?:\\/\\/|\\/)(\\S+))/i def initialize(tag_name, markup, tokens) super if markup =~ IMAGE_URL_WITH_CLASS_AND_CAPTION_AND_LINK @class = $1 @url = $3 @caption = $7 @link = $9 elsif markup =~ IMAGE_URL_WITH_CLASS_AND_CAPTION @class = $1 @url = $3 @caption = $7 elsif markup =~ IMAGE_URL_WITH_CAPTION @url = $1 @caption = $5 elsif markup =~ IMAGE_URL_WITH_CLASS @class = $1 @url = $3 elsif markup =~ IMAGE_URL @url = $1 end end def render(context) if @class source = \u0026quot;\u0026lt;figure class='#{@class}'\u0026gt;\u0026quot; else source = \u0026quot;\u0026lt;figure\u0026gt;\u0026quot; end if @link source += \u0026quot;\u0026lt;a href=\\\u0026quot;#{@link}\\\u0026quot;\u0026gt;\u0026quot; end source += \u0026quot;\u0026lt;img src=\\\u0026quot;#{@url}\\\u0026quot;\u0026gt;\u0026quot; if @link source += \u0026quot;\u0026lt;/a\u0026gt;\u0026quot; end source += \u0026quot;\u0026lt;figcaption\u0026gt;#{@caption}\u0026lt;/figcaption\u0026gt;\u0026quot; if @caption source += \u0026quot;\u0026lt;/figure\u0026gt;\u0026quot; source end end end Liquid::Template.register_tag('image', Jekyll::ImageTag)  is written as this Hugo shortcode:\n\u0026lt;!-- image --\u0026gt; \u0026lt;figure {{ with .Get \u0026quot;class\u0026quot; }}class=\u0026quot;{{.}}\u0026quot;{{ end }}\u0026gt; {{ with .Get \u0026quot;link\u0026quot;}}\u0026lt;a href=\u0026quot;{{.}}\u0026quot;\u0026gt;{{ end }} \u0026lt;img src=\u0026quot;{{ .Get \u0026quot;src\u0026quot; }}\u0026quot; {{ if or (.Get \u0026quot;alt\u0026quot;) (.Get \u0026quot;caption\u0026quot;) }}alt=\u0026quot;{{ with .Get \u0026quot;alt\u0026quot;}}{{.}}{{else}}{{ .Get \u0026quot;caption\u0026quot; }}{{ end }}\u0026quot;{{ end }} /\u0026gt; {{ if .Get \u0026quot;link\u0026quot;}}\u0026lt;/a\u0026gt;{{ end }} {{ if or (or (.Get \u0026quot;title\u0026quot;) (.Get \u0026quot;caption\u0026quot;)) (.Get \u0026quot;attr\u0026quot;)}} \u0026lt;figcaption\u0026gt;{{ if isset .Params \u0026quot;title\u0026quot; }} {{ .Get \u0026quot;title\u0026quot; }}{{ end }} {{ if or (.Get \u0026quot;caption\u0026quot;) (.Get \u0026quot;attr\u0026quot;)}}\u0026lt;p\u0026gt; {{ .Get \u0026quot;caption\u0026quot; }} {{ with .Get \u0026quot;attrlink\u0026quot;}}\u0026lt;a href=\u0026quot;{{.}}\u0026quot;\u0026gt; {{ end }} {{ .Get \u0026quot;attr\u0026quot; }} {{ if .Get \u0026quot;attrlink\u0026quot;}}\u0026lt;/a\u0026gt; {{ end }} \u0026lt;/p\u0026gt; {{ end }} \u0026lt;/figcaption\u0026gt; {{ end }} \u0026lt;/figure\u0026gt; \u0026lt;!-- image --\u0026gt;  Usage I simply changed:\n{% image full http://farm5.staticflickr.com/4136/4829260124_57712e570a_o_d.jpg \u0026quot;One of my favorite touristy-type photos. I secretly waited for the good light while we were \u0026quot;having fun\u0026quot; and took this. Only regret: a stupid pole in the top-left corner of the frame I had to clumsily get rid of at post-processing.\u0026quot; -\u0026gt;http://www.flickr.com/photos/alexnormand/4829260124/in/set-72157624547713078/ %}  to this (this example uses a slightly extended version named fig, different than the built-in figure):\n{{% fig class=\u0026quot;full\u0026quot; src=\u0026quot;http://farm5.staticflickr.com/4136/4829260124_57712e570a_o_d.jpg\u0026quot; title=\u0026quot;One of my favorite touristy-type photos. I secretly waited for the good light while we were having fun and took this. Only regret: a stupid pole in the top-left corner of the frame I had to clumsily get rid of at post-processing.\u0026quot; link=\u0026quot;http://www.flickr.com/photos/alexnormand/4829260124/in/set-72157624547713078/\u0026quot; %}}  As a bonus, the shortcode named parameters are, arguably, more readable.\nFinishing touches Fix content Depending on the amount of customization that was done with each post with Jekyll, this step will require more or less effort. There are no hard and fast rules here except that hugo server --watch is your friend. Test your changes and fix errors as needed.\nClean up You\u0026rsquo;ll want to remove the Jekyll configuration at this point. If you have anything else that isn\u0026rsquo;t used, delete it.\nA practical example in a diff Hey, it\u0026rsquo;s Alex was migrated in less than a father-with-kids day from Jekyll to Hugo. You can see all the changes (and screw-ups) by looking at this diff.\n"},{"idx":225,"href":"/posts/20200708/","title":"2020年0708月の活動 \u0026 HTML5 Level1試験合格しました","content":" タイトルにもある通り、07月、08月の活動について。\n先月も気づいたら飛ばしていたのでここでまとめる。\nと言っても、平日はほぼ仕事\u0026amp;連日による猛暑と感染拡大で引きこもり気味だったので、、プライベートではそんなに遊べられてなかったですね残念。。\nでもその間、興味のあったHTML5プロフェッショナル技術者認定　Level1 に取り組んでいました。\nHTML5プロフェッショナル技術者認定　Level1 この資格はLPI-Japanが主催する資格試験で、HTML5・CSS3についての知識を問われる試験である。\n HTML5 Professional Certification Level.1について（Ver2.0）｜試験概要  受けようと思った理由は、フロントエンドの基本的な知識について体系的に学べ、身につけられると思ったから。\nプライベートでも仕事でもあまり触れられてこなかった領域で最近興味が出ていたこともあり、フロントエンドの根幹となるHTMLやCSSについて学んで見たいというのがありました。\nただ勉強するなら何か適当な書籍を見てやるのも良かったが、どうせなら何か形に残せる結果も欲しかったということでこの資格試験を勉強・受験するに至った。\n勉強法  実際にコードに書き起こして表示結果を確認する  特に急いでいるわけでもなかったので、書籍を初めから読みつつ、またフロントエンドに関してはコードに書いて表示したらすぐに結果が分かるので、このブログに色々とページを作って試していたりしました（その結果、当ブログのフロントエンドのセクションは今では結構ページが多くなった）\n 問題集で繰り返しアウトプットする  HTML5 Level1試験に関しては、この試験のスポンサーにもなっているPing-tがオンライン問題集を公開(有料)しているため、そちらを利用して全問題(400問近く)が全て正答できるようになるまで繰り返していた。お金はかかるが、自分は課金してもここは利用する価値があると思っております。\n実際の試験 試験は自分でテストセンターを予約し、指定時間に行ってPC上で受験するという形式で、60問を90分で解き、合格基準(７割程度)を上回っていれば合格となります。ちなみに合否は試験終了と同時に知らされます。\n形式はPing-tと似ていたので少し慣れた感じで取り組めることができました。Ping-tを隈無くやっていれば合格は十分狙えると思います。\n今後 折角HTML\u0026amp;CSSの知識を(ある程度)身につけられたので何かプロダクトを作ってみたいところですが、今のご時世フロントエンドと言ったらやっぱりJavascriptが主流じゃないか？と思っているので、今度はJavascriptも試験範囲に入っているHTML5 Level2試験も狙っていきたいと考えている。\nでも一区切りついて今度は別の試験を考えたいと思っているので・・ちまちま程度に進めようかなとも思います。。\n とまあ、必死に勉強しておいてなんですが、自分の中ではLevel1は一つの通過点にすぎないので、Level2も次の目標の一つとしていきたいと言うのが今の心境。\nだけど、順番的に次はTOEIC \u0026amp; Python3技術者試験　かなあ。その後かなあ。\n"},{"idx":226,"href":"/posts/","title":"Posts","content":""},{"idx":227,"href":"/posts/20200406/","title":"2020年04~06月の活動","content":" さーて、毎月やろうと決めていたこの振り返りですが\n普通に4,5月は忘れていました。。\n多分、ずっと在宅だったせいですね\nまあ何はともあれ、4月から6月までの分を振り返ろうかと。\n職場環境の変化 4月から在宅勤務となりました。（今現在も続いてます）\n思えば在宅勤務って入社以来初でしたが、\n意外と通勤しなくて良いっていいね、と感じてます。\nこれに慣れてしまうと、出社可能になった時に体がついていけなくなると密かに心配・・(w)\nブログ記事 在宅時間が多くなったのでこのブログの記事の作成も結構捗ったかなと（決して勤務時間中にやったという意味ではない）。\n4~6月分では\n フロントエンド ：11記事 データサイエンス ：13記事 競技プログラミング ：4記事  という進捗！　こうして振り返ると意外と進めたなと実感。\nまだ在宅期間は続くので、ちょくちょく進められると良いかなと。このペースはキープしたい所。\nランニング 外出自粛と騒がれてますが、家にいることが多くなったので気晴らしにジョギングを始めました。\n前からやろうとは思っていたけども、普通に出社してたときは帰宅時にはすでに暗くなったりでやる気が起きない状態が続いてたので、在宅環境になることで始められるようになれたというのが意外にもいい効果かなと考えてます。\nまあ、自粛もあるのでガッツリではありません。今は週2日ほどですが、危険でない、気分転換程度に続けられたら良いなと思っています。\n  あー、いざ３ヶ月分振り返ろうとしても全然思い浮かばん。\n今後は忘れないようにちょくちょく書き留めながらやろうと思います反省しよう・・\n"},{"idx":228,"href":"/posts/slack_request/","title":"指定URLにWebリクエストを送るSlack Appの作成","content":" Slackには自作のアプリを作成でき、またコマンドを指定することで指定した動作を行える。\n今回はSlackアプリの作成方法、及びコマンドの作成方法、コマンド実行時に指定URLへWebリクエストを送信する方法をまとめる。\n1. Slack Appを作成する  https://api.slack.com/appsのページに行く。  2. (指定URLへWebリクエストを送る)コマンドを作成する Slackアプリのコマンドはスラッシュコマンドと言われる（スラッシュから始まるので）\nここではこの作成方法についてを示す。\n2.1 Slack Appのトップページへ行く スラッシュコマンドを作りたいSlack Appのページに行く。\n具体的には、https://api.slack.com/appsのページに行くと、作成したSlack Appが表示されるので、そのアプリ名をクリックする。\n2.2 Slash Commandを作成する ページ左側にある「Slash Command」をクリックする。\nその後、「Create New Command」をクリックする。\nするとコマンド名、リクエスト先のURL等の入力を求められるので、入力する。\n入力後、右下の「Save」を押すとコマンドが作成される。\nなお、この形式で作ったSlash Commandは、指定URLにJSON形式のデータをPOSTで送る。\nコマンド実行時に引数も指定できるが、引数に指定したデータはJSONの\u0026rdquo;text\u0026rdquo;というキーに渡されて送られる。\n"},{"idx":229,"href":"/posts/aws_create_api_gateway/","title":"API GatewayでのAPI作成方法(AWS)","content":" AWSでのAPI GatewayでのAPI作成方法について、備忘がてら手順をのせる。\n1. AWSマネジメントコンソールにログインする AWSマネジメントコンソールのページに行き、ログインする。\n2. API Gatewayのページを開く マネジメントコンソールにログインしたら、サービスの検索ボックスにAPIと入力し、API Gatewayのページを開く。\n3. APIを作成する 右上の「APIの作成」ボタンを押す。\n4. 作成するAPIタイプを選択する どのタイプのAPIを作成するかが画面に出るので、適切なものを作成する。\n今回はREST APIを作成する。\n5. API名を設定する API名などを設定して「APIの作成」をクリック\nするとAPIの設定画面が表示される。\nというように、REST API自体の土台はこれで完成になる。\nこの後は各自の都合により具体的なAPIをこの上に作っていく。\n"},{"idx":230,"href":"/posts/aws_create_lambda/","title":"Lambda関数の作成方法(AWS)","content":" AWSでLambdaの関数を作る方法について、またまた備忘がてら手順をのせておく。\n1. AWSマネジメントコンソールにログインする AWSマネジメントコンソールのページに行き、ログインする。\n2. Lambdaのページを開く マネジメントコンソールにログインしたら、サービスの検索ボックスにLambdaと入力し、Lambdaのページを開く。\n3. 関数を作成する Lambdaのページを開くと関数の画面になり、今ある関数の一覧が表示される。\n関数を作成するには画面にある「関数の作成」ボタンを押す。\nすると関数の作成画面に行き、どのような方法で関数を作成するかを選ぶ。\n今回は自作のコードを元に作成したいので、「一から作成」を選択。\n下の「基本的な情報」の欄に、関数名とランタイム(言語)、また適切な実行ロールを設定する。\n(3.5 IAMロールの作成方法) Lambda関数で別のサービス等を利用するときは、用途に応じたIAMロールを作成して付与してやる必要がある。\n念のため、ここではその手順を示す。\n例として、DynamoDBにアクセスが必要なLambda関数に対するIAMロールの作成方法についてを示す。\n サービス から「IAM」を選択し、IAMのページへ行く。\n 「ロール」＞「ロールの作成」へ行く\n 「ユースケースの選択」で、今回はLambda用のIAMロールなので「Lambda」を選択する。\n 「次のステップ(:アクセス権限)」ボタンを押す\n Attachアクセス権限ポリシー　で次の２つのポリシーを選択する。\n   AmazonDynamoDBFullAccess AWSLambdaBasicExecutionRole   選択したら「次のステップ(:タグ)」ボタンを押す\n 「次のステップ(:確認)」を押す\n ロール名を入力して「ロールの作成」を押す\n ロールが完成される\n  ロールを作成したら、Lambda関数作成時に アクセス権限＞実行ロールの選択または作成＞既存のロールを使用する　から作成したロールを選択する\nそれが終わったら、「関数の作成」ボタンを押す\n4. コードを設定する 「関数の作成」ボタンを押すと関数の設定画面へ行き、コードなどの設定が行える。\nコードの部分に設定したいコードを入力する。\nテストをしたいときは「テスト」ボタンを押してテストする。\n以上、Lambda関数の作成方法である。\n"},{"idx":231,"href":"/posts/aws_create_dynamo_table/","title":"DynamoDBテーブルの作成方法(AWS)","content":" AWSでDynamoDBのテーブルを作る方法について、備忘がてら手順をのせる。\n1. AWSマネジメントコンソールにログインする AWSマネジメントコンソールのページに行き、ログインする。\n2. DynamoDBのページを開く マネジメントコンソールにログインしたら、サービスの検索ボックスにDynamoDBと入力し、DynamoDBのページを開く。\n3. テーブル名・キーを設定する DynamoDBのページから「テーブルの作成」ボタンを押すとテーブル作成の画面へ行く。\nまずは、テーブル名とプライマリーキー名をここで設定する。プライマリーキーは最大２個設定でき、２個設定したい場合は「ソートキーを追加」から追加する。\n「デフォルト設定の適用」は外した方が良い。入力が終わったら「作成」を押す。\n4. テーブルが作成される。 「作成」ボタンを押すとテーブルの詳細ページに行き、先程のテーブルが作成されていることがわかる。\n5. テーブルに項目を追加する 「項目」タブを押すとテーブル定義、入っているデータが表示される（しかし、ここでは作成したばかりなのでデータは入っていない）\nここで「項目の作成」ボタンを押すと項目作成のウィンドウが表示される。\nここで項目を追加したいときは「Append」または「Insert」、項目を削除したいときは「Remove」でできる。\n具体的なデータを入力したいときは「VALUE」のところに具体的な値を入れて「保存」ボタンを押すとデータが追加される。\n"},{"idx":232,"href":"/posts/202003/","title":"2020年03月の活動","content":" 3月も終わり、同時に私も社会人4年目に突入しようとしている時期。\n色々将来について考えたい時だが、コロナウイルスの爆発的流行により行動範囲がより狭まっているWATです。\nあんまり目立ったことしてないが、とりあえず3月の活動まとめを。\nAWS(資格試験) 今月は主にAWS Solution Architect Associates試験のために勉強していた。\nこの試験、3月下旬に旧バージョンでの受験が終了することと、身近にある参考書や問題集は旧バージョンのものだったので、終了ギリギリの日程で受験を申し込み、それまで必死に勉強していた。\n使った教材は以下の通り。\n 書籍「AWS認定資格試験テキスト　AWS認定 ソリューションアーキテクト-アソシエイト」\n AWS WEB問題集「koiwaclub」\n Udemy 「AWS 認定ソリューションアーキテクト アソシエイト模擬試験問題集（5回分325問）」\n  以上の教材に取り組んだ上で挑戦したが・・\n結果はあと一歩で惨敗。\nあと40点なので１問か２問といったとこか？\nなんとも捨てがたいのでもう１回受験を予定。予定日は4月末あたり。もう新バージョンになるので厳しくなるだろうが・・\nできればkoiwaclub、Udemyは完璧にした上で行きたい。\nあと、勉強の上でもう１個有用な資料見つけた\n (公式)AWS サービス別資料  サービス毎にBlackBelt(AWS公式が主催するオンラインセミナー)の過去資料が置いてある。参考書より見やすそう？\nこれらを活用した上で、、是非再チャレンジして見たいねえ。。\n ４月初っ端、遂に弊社もコロナウイルスの影響により全社員の出社が禁止になった。\n今月いっぱいはテレワークで過ごすと言うことだが、果たしてどうなるか・・\n"},{"idx":233,"href":"/posts/202002/","title":"2020年02月の活動まとめ","content":" ふと、月ごとに何をやったかを簡単でいいので書き留めておいた方が良いのではないかと思ったため、2月も終わるこのタイミングで書き記しておくことにした。\nAWS 昨年末にAWS Cloud Practitionerを取得し、その勢いで20年1Q（3月まで）の間にAWS Solution Architect Associateを受験することになったため勉強し始めた。\n書籍も買い始めたが、実機も触りながら学べられたら良いと思ったため、SlackとAWSを利用した自作のAWSクイズ出題アプリを作成した。(詳細、のちに余裕あれば記事上げます)\n大体１週間で作成し、書籍をもとに200問ほど登録も行ったため、活用中。同時に現在はWebでの問題集も実施中。\n現行SAA試験は3/22までとのことなので、ここに間に合う事を考慮しつつ進める予定。\n一応3/18(水)に受験を予定しているが、コロナウイルスの影響で受験できるかが心配・・（配信元のPeasonVUEによると、現時点で中国での受験は全面中止にしているらしい。最悪日本にも影響あるかもだが）\n勉強会 Pythonで行う自然言語処理の勉強会に出席した。\njanomeというライブラリを主に利用するそうだが、まだ自分の中で内容をまとめきれてないので復習せねば・・\n競プロ 昨年末ごろはAOJ,Leetcodeも触っていたが、最近はAtcoderに絞ることにした。\n現在のランクは緑色なので、Atcoder Problemsで緑問をひたすら取り組んでいる。\nただ、前述の資格勉強があるので規模は縮小中・・\nちなみにStreak数は2月末で200日達成したのでこちらも根気強く励みたい\nブログ プログラミングブログとデータサイエンス進行中\nこちらも資格勉強に伴い1月より頻度減りつつある・・\nイベント 2/8にStartup Aquarium@虎ノ門ヒルズ　に参加した。\nスタートアップ企業は普段見る事ないので実際どういうものなんだろう？と思い参加してみたが、多くの業界で多くの企業がそれぞれ主力となるサービスを開発・展開していて、とても自由で羨ましく感じられた。\nちなみにメモによるとスタートアップに向いている人というのは\n 何かに取り組む時に過去の成功体験ばかりを参考にするのではなく、いろんな人にヒアリングして回って、この業界ならどういう風に回っていくのがよいのだろうという思考の解像度を高くしていける人 こういうルールがあるけどこうしたらうまく行くとか、ルールが無いならこういうのを作ればよいと考えられる人。ルールがないからどうしようみたいな人は向いてない 一流層であっても謙虚である人  だそうである。またこのようなイベントがあれば参加してみたい。\nあと、スタートアップってただ単に「新しく出来た企業」のことを言うのだと思っていたが、正しくは「新しいビジネスモデルを開発し、短期間のうちに急成長とエクジットを狙うことで一攫千金を狙う人々の一時的な集合体」のことを言うらしい。これも改めて初めて知った。\n とりあえず以上、来月(3月)は絶対AWS SAA合格目指して頑張ろう！\nちなみにコロナウイルス流行でついに常駐先への出社が当面禁止に。けど自社はそんなことないとか・・\n"},{"idx":234,"href":"/posts/warshall_floyd/","title":"ワーシャル・フロイド法","content":" 経路探索アルゴリズムの一つ「ワーシャル・フロイド法」についてを調べてみた。\nワーシャル・フロイド法とは？ ワーシャル・フロイド法とは、グラフのある頂点からある頂点までの最短経路を全ての組み合わせにおいて探索するアルゴリズムである。\n 入力  グラフ G = (V,E) Eの各辺の重み(コスト)  出力  全ての頂点i,j(∈V)における最短経路   アルゴリズム アルゴリズムは以下の通り。\nV = (頂点の数) d[V][V] // d[i][j]は頂点iから頂点jまでにかかるコスト。経路が存在しない場合はINF、i==jの時は0で初期化する d ← E // dに辺Eの長さを反映させる (d[i][j]にEの長さを入れる) for(a = 0;a = V;a++){ for(b = 0;b \u0026lt; V;b++){ for(c = 0;c \u0026lt; V;c++){ d[b][c] = min(d[b][c], d[b][a] + d[a][c]) } } } return d  考え方としては、頂点iからグラフGの頂点それぞれを経由して頂点jまで行く計|V|通りの経路を調べ、調べた|V|通りのパターンの中から最小のコストを取り出したものが、頂点iから頂点jへの最小コストとなる。\nこれを全ての(i,j)の組み合わせにおいて調べることで、グラフGの全ての頂点間の最小コストを調べられる。全体の計算量はO(|V|3)となる。\n"},{"idx":235,"href":"/posts/graph_coloring/","title":"グラフの彩色問題 ～Welsh・Powellのアルゴリズム～","content":" 競プロでグラフの彩色問題が出てきたので、今回はグラフの頂点彩色問題について、復習がてら記事を書いてみる。\nグラフの彩色 そもそもグラフの彩色とは何か？\n グラフ彩色（英: Graph coloring）とは、グラフの何らかの要素に、ある制約条件を満たすように色を割り当てることである。最も単純なものは、隣接する頂点同士が同じ色にならないように全頂点に彩色する問題である。これを頂点彩色という。同様に辺彩色は、隣接する辺同士が同じ色にならないように全辺を彩色する問題、面彩色は、平面グラフの辺で囲まれた各領域（面）を隣接する面同士が同じ色にならないように彩色する問題である。 (Wikipedia引用)\n 要は、グラフの隣接する頂点が全て違う色になるように頂点を色分けできるか？というものである。\n辺彩色の場合は辺、面彩色の場合は面になる。\n頂点彩色の一例は以下の図のようなものがある。\n頂点彩色のアルゴリズム (Welsh・Powellのアルゴリズム) グラフの頂点彩色のアルゴリズムとしてWelsh・Powellのアルゴリズムが知られている。 これは彩色を貪欲法で行う方法であり、ある頂点の色に隣接する頂点で使っていない色を設定していき、それまでに使ったどの色も頂点に設定できない場合は新たな色を設定するというアルゴリズムである。\n調べる頂点の順番によっては最適な彩色が行えないため、最適な彩色を行うために頂点は次数の大きい順に行う。\n疑似的なアルゴリズムを以下に示す。\n グラフGの頂点次数の大きい順にソートし、 Vi (i=1,2,…n)とする。\n i = 1 とする\n c = 1 とする\n Vi の隣接点で色cを持つものが存在しなければ、Vi に色cを与えて6.へ進む\n c = c + 1 として4.に戻る\n i \u0026lt; |V| ならば、i = i + 1 として3.に戻る。i = |V| なら終了。\n  面彩色 面彩色は頂点彩色を応用して行える。 面をグラフの一つの頂点とみなし、接している面（頂点）同士を辺で繋げたグラフに頂点彩色を行い、彩色された頂点の色をそのまま対応する面に置き換えれば面彩色が行える。\nイメージとしては以下のような図。\n辺彩色 辺彩色は専用のアルゴリズムがある？と聞いたが調べても見つからず、そのため問題にもよるが、これも頂点彩色を応用して行えると予想している。\n１つの辺において、隣接辺（＝辺が結んでいる頂点が結んでいる他の辺）の数が大きい順に辺をソートし、\n大きい辺から頂点彩色アルゴリズムを応用して行えば、彩色が行える（・・・はず）\n グラフGの辺を隣接辺の数の大きい順にソートし、 Ei (i=1,2,…n)とする。\n i = 1 とする\n c = 1 とする\n Ei の隣接辺で色cを持つものが存在しなければ、Ei に色cを与えて6.へ進む\n c = c + 1 として4.に戻る\n i \u0026lt; |E| ならば、i = i + 1 として3.に戻る。i = |E| なら終了。\n  イメージとしては以下のような図。\n"},{"idx":236,"href":"/posts/queue_py/","title":"キューとPythonでの実装モジュール「deque」","content":" 幅優先探索を実装する時にキューと言うデータ構造を使用するのが良いそうなので、 今回はキューについてを調べて見た。（幅優先探索については後日・・機会あれば）\nキューとは  キュー（英: queue）、あるいは待ち行列はコンピュータの基本的なデータ構造の一つ。データを先入れ先出しのリスト構造で保持するものである。キューからデータを取り出すときには、先に入れられたデータから順に取り出される。キューにデータを入れることをエンキュー(enqueue)、取り出すことをデキュー(dequeue)という。(Wikipediaより)\n 図にすると以下のような構造を持つデータ構造である。\nイメージとしては筒のようなもの。\nキューの中にキューの後ろからデータを入れる事ができ（エンキュー）、\nキューの先頭からデータを取り出す事ができる（デキュー）。\n構造上取り出せるデータはキューに入れた順となる。\nエンキュー、デキューを下図に示す。\nPythonでの実装方法 Pythonにはキューを実装するには、 collections モジュールの deque 型を利用する。\nこのdeque型だが、キューに加えスタックの機能も持ったようなデータ構造であり、使い方次第ではスタックとしても使用できる。\n今回はキューとして利用することを前提に説明する。\nキューの作成 dequeをインポートしてキューのオブジェクトを作成する。\n\u0026gt;\u0026gt;\u0026gt; from collections import deque \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a=deque() \u0026gt;\u0026gt;\u0026gt;  キューへの要素の追加 dequeに要素を追加するにはappend()メソッドで行う。\nappendメソッドにより、要素がキューの右側から追加される。\n本来のキューの使い方ではないが、左から追加するにはappendleft()メソッドを使う。\n\u0026gt;\u0026gt;\u0026gt; a deque([]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a.append(1) \u0026gt;\u0026gt;\u0026gt; a deque([1]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a.append(2) \u0026gt;\u0026gt;\u0026gt; a deque([1, 2]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a.appendleft(3) \u0026gt;\u0026gt;\u0026gt; a deque([3, 1, 2]) \u0026gt;\u0026gt;\u0026gt;  キューに別リストの要素を一挙に追加 キューに別のリストにある要素を一挙に追加したい時はextendメソッドを使う。\nキューの左から追加したい時はextendleftメソッドを使う。（リストの左の要素から順にキューに追加されていく。）\n\u0026gt;\u0026gt;\u0026gt; a deque([1]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; b=[2,3,4] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a.extend(b) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a deque([1, 2, 3, 4]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a.extendleft(b) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a deque([4, 3, 2, 1, 2, 3, 4]) \u0026gt;\u0026gt;\u0026gt;  キューから要素を取り出す・削除 dequeから要素を取り出すときはpopメソッドを使う。\npopメソッドにより、dequeの右側から要素を一つ削除し、その要素が返される。\ndequeの左側から要素を取り出したい時はpopleftメソッドを使う。\nまた、dequeから特定の要素を削除したい時はremoveメソッドを使う。\ndeque.remove(x) でdeque内に最初に現れるxを削除する。\n\u0026gt;\u0026gt;\u0026gt; a deque([3, 1, 2]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a.pop() 2 \u0026gt;\u0026gt;\u0026gt; a deque([3, 1]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a.popleft() 3 \u0026gt;\u0026gt;\u0026gt; a deque([1]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a.append(2) \u0026gt;\u0026gt;\u0026gt; a.append(2) \u0026gt;\u0026gt;\u0026gt; a.append(3) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a deque([1, 2, 2, 3]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a.remove(2) \u0026gt;\u0026gt;\u0026gt; a deque([1, 2, 3]) \u0026gt;\u0026gt;\u0026gt;  キューから要素を全削除する キューから要素を全て削除するにはclearメソッドを使う。\n\u0026gt;\u0026gt;\u0026gt; a deque([1, 2, 3]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a.clear() \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a deque([]) \u0026gt;\u0026gt;\u0026gt;  キューの要素の順を逆にする キュー内の要素の順番を逆にするにはreverseメソッドを使う。\n\u0026gt;\u0026gt;\u0026gt; a deque([1, 2, 3, 4]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a.reverse() \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a deque([4, 3, 2, 1]) \u0026gt;\u0026gt;\u0026gt;  今後活用していきたい。\n"},{"idx":237,"href":"/docs/","title":"Docs","content":""},{"idx":238,"href":"/docs/programming/number/number_index/","title":"数値","content":" 数値 数値についての記事。\n 数値の演算  対数  常用対数(底10) 自然対数(底e) 任意の底の対数  小数点以下切り捨て 小数点以下切り上げ 小数点以下四捨五入 論理演算 ビット演算  論理和(OR) 論理積(AND) 排他的論理和(XOR)  三項演算子 階乗 絶対値 平方根・n乗根 複数の数字のうち最も大きい数字をとる 複数の数字のうち最も小さい数字をとる 変数の値を1増やす・減らす（インクリメント・デクリメント）  数値の表記を変換する  数値を文字列に変換する 数字の頭をゼロ詰して表示する 基数変換  ２進数に変換して表示 ８進数に変換して表示 １６進数に変換して表示 ２、８、１６進数を１０進数に変換して表示   数値の定数  円周率(π)  その他  数値（整数）の桁数を調べる 数値をランダムに取得する\u001c(乱数)   "},{"idx":239,"href":"/docs/programming/string/contain/","title":"文字列中にある文字列が含まれているかを確認する","content":" 文字列中にある文字列が含まれているかを確認する 文字列中に特定の文字列を含んでいるかを確認したい場合どうするか？ ここではその方法についてを示す。\nJava  Javaで文字列中にある文字列が含まれているかを確認するにはStringのメソッドであるcontains()を利用する。\npublic boolean split(String s)\n呼び出し元の文字列中に引数に指定した文字列が含まれていればtrue、そうでない場合はfalseを返す。\nclass Main{ public static void main(String args[]){ String s = \u0026#34;apple,banana,cherry,durian\u0026#34;; System.out.println(s.contains(\u0026#34;banana\u0026#34;)); System.out.println(s.contains(\u0026#34;grape\u0026#34;)); } } 実行結果を以下に示す。\n\u0026gt; java Main true false   Python  pythonで文字列中にある文字列が含まれているかを確認するにはin演算子を使う。\n含まれているとTrue、そうでない場合はFalseを返す。\n\u0026gt;\u0026gt;\u0026gt; s = \u0026#34;apple,banana,cherry\u0026#34; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026#34;banana\u0026#34; in s True \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026#34;grape\u0026#34; in s False \u0026gt;\u0026gt;\u0026gt;   "},{"idx":240,"href":"/docs/programming/string/split/","title":"文字列をある文字で分割する","content":" 文字列をある文字で分割する 文字列に対して、ある文字を境に複数に分割したいという場面もあるだろう。 ここではその方法についてを示す。\nJava  Javaで文字列の分割を行うにはStringのメソッドであるsplitを利用する。\npublic String[] split(String regex, int limit)\n第1引数には分割する際の境目となる文字列を正規表現で入力し、\n第2引数には分割を行う回数を入力する。負の数を入力すると無制限に分割を行う。０を入力した場合、分割後の末尾が空白になる場合はそれを格納しない。\n使用例を以下に示す。\nimport java.util.Arrays; class Main{ public static void main(String args[]){ String s = \u0026#34;apple-banana-cherry-durian--\u0026#34;; String[] t = s.split(\u0026#34;-\u0026#34;,-1); System.out.println(Arrays.toString(t)); //[apple, banana, cherry, durian, , ]  t = s.split(\u0026#34;-\u0026#34;,0); System.out.println(Arrays.toString(t)); //[apple, banana, cherry, durian]  t = s.split(\u0026#34;-\u0026#34;,2); System.out.println(Arrays.toString(t)); //[apple, banana-cherry-durian--]  } } splitメソッドの返り値はString型の配列になるので、結果を格納したい場合はString型の配列を用意する。\n Python  pythonで文字列を分割するには文字列(str)のsplit関数を使う。\nstr.split(sep=None, maxsplit=-1)\n第1引数sep には区切り文字を入れる。入力しない場合は、デフォルトで空白文字が使われる。またこの時、連続している空白文字は一つの区切り文字として扱われる。\n第2引数maxsplitには分割する回数を入力する。-1の場合、無制限に分割する。入力しない場合はデフォルトで-1が入る。\n戻り値はリストになる。\n\u0026gt;\u0026gt;\u0026gt; s = \u0026#34;apple-banana-cherry-durian--\u0026#34; \u0026gt;\u0026gt;\u0026gt; print(s.split(\u0026#34;-\u0026#34;,-1)) [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;, \u0026#39;durian\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;\u0026#39;] \u0026gt;\u0026gt;\u0026gt; print(s.split(\u0026#34;-\u0026#34;,0)) [\u0026#39;apple-banana-cherry-durian--\u0026#39;] \u0026gt;\u0026gt;\u0026gt; print(s.split(\u0026#34;-\u0026#34;,2)) [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry-durian--\u0026#39;] \u0026gt;\u0026gt;\u0026gt;  cf. 組み込み型 - split() https://docs.python.org/ja/3/library/stdtypes.html#str.split\n   "},{"idx":241,"href":"/docs/programming/string/ascii/","title":"1文字からその文字の文字コード（アスキーコード）を取得する","content":" 1文字からその文字の文字コード（アスキーコード）を取得する コンピュータは二進数しか扱えないため、文字データも二進数（つまり整数）として扱われる。 つまり１文字に対して対応する整数が割り当てられており、コンピュータはその数を特定の文字と思い込み処理する。この数の事を文字コードという。 文字１文字から、その文字の文字コードを取得する方法をまとめる。\nJava  クラスはここではMain.javaとする\nclass Main{ public static void main(String args[]){ char c = \u0026#39;a\u0026#39;; int a = c; System.out.println(a); // 97  String s = \u0026#34;aaaaa\u0026#34;; a = s //コンパイルエラー  c = s.charAt(0) // sの0文字目をchar型で返す  System.out.println(c); // a  a = c; System.out.println(a); // 97  } } Javaでは１文字のchar型と文字列のString型があるが、 文字コードに変換できるのはchar型のほうであり、String型の変換はできない。 char型のデータをint型の変数に代入するのは可能なのか？という疑問もあるだろうが、 Javaには代入する変数とデータの型が違っていても、片方がもう片方の型に変換が可能であれば代入は行える。 char型の変数はint型、double型などの数値データ型に変換が可能であり、この例ではint型の変数に代入できる。 対してString型はint,doubleなどの数値データ型には変換できないので、変換したい1文字をchar型として取り出してから行う。\n Python  Pythonで文字から文字コードを取得するにはord()関数を利用する。 ord()関数は1文字を受け取りその文字コードを出力する。入力する文字は半角でも全角でも良い。 ２文字以上を入力するとエラーになる。\n\u0026gt;\u0026gt;\u0026gt; ord(\u0026#34;a\u0026#34;) 97 \u0026gt;\u0026gt;\u0026gt; ord(\u0026#34;aa\u0026#34;) Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; TypeError: ord() expected a character, but string of length 2 found \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; ord(\u0026#34;あ\u0026#34;) 12354 \u0026gt;\u0026gt;\u0026gt; また、逆の文字コードから対応する文字を出力する関数chr()もある。\n\u0026gt;\u0026gt;\u0026gt; chr(97) \u0026#39;a\u0026#39; \u0026gt;\u0026gt;\u0026gt; chr(98) \u0026#39;b\u0026#39;   "},{"idx":242,"href":"/docs/programming/string/string/","title":"文字列を宣言する","content":" 文字列を宣言する 文字列のデータ（文字列リテラル）を宣言するにはどうすればよいか？\nJava  クラスはここではMain.javaとする\nclass Main{ public static void main(String args[]){ char c = \u0026#39;c\u0026#39;; System.out.println(c); // c  String s = \u0026#34;Words\u0026#34;; System.out.println(s); // Words  } } Javaで文字を扱うには、基本データ型であり1文字のみを扱えるchar型と、 2文字以上の文字列を扱えるString型がある。（もう少し言うとStringBuilder型というのもあるがここでは割愛する ） char型の場合は1文字をシングルクォート(\u0026ldquo;)で囲んで宣言する。char型で2文字以上の文字を宣言するとコンパイルエラ ーとなる。\nString型の場合は文字列をダブルクォート(\u0026ldquo;\u0026rdquo;)で囲んで宣言する。文字列は0文字から扱える。\n Python  Pythonでは文字列を扱うには\n(変数) = \u0026quot;文字列\u0026quot;  または\n(変数) = '文字列'  のようにする。 Javaとは違い、Pythonでは文字列を宣言するときにはシングルクォート(\u0026ldquo;)、ダブルクォート(\u0026rdquo;\u0026ldquo;)のどちらを利用しても よい。\n\u0026gt;\u0026gt;\u0026gt; s = \u0026#34;a\u0026#34; \u0026gt;\u0026gt;\u0026gt; print(s) a \u0026gt;\u0026gt;\u0026gt; c = \u0026#39;c\u0026#39; \u0026gt;\u0026gt;\u0026gt; print(c) c \u0026gt;\u0026gt;\u0026gt;   Javascript  Javascriptでも、シングルクォート(\u0026ldquo;)、ダブルクォート(\u0026rdquo;\u0026ldquo;)を利用して文字列を宣言する。\nvar h1 = \u0026#39;Hello! World!\u0026#39; var h2 = \u0026#34;Hello! World!\u0026#34;    "},{"idx":243,"href":"/posts/file_magic/","title":"fileコマンドとファイルのマジックナンバーについて","content":" 先日CTFの勉強会に参加してきた。\n勉強会といっても、今回参加したのは総まとめ回だったそうで、実践演習的な回だったが、、\n運営側が用意した問題をそれぞれ解いていくという形式だったが、最初の問題から解けないという体たらくっぷりであったので、他の参加者や講師の方から教えて頂いたことだけでも備忘のために書いておく。\nfileコマンド CTFは正体不明なファイルを渡されることが多いのだが、まずはそのファイルの形式を知るということから始めることが多いと思う。\n普通、ファイルには.txtや.jpgなどといったような、ファイルの形式を示す文字列である「拡張子」というのがファイル名の末尾についており、ユーザーはこれを見ることによってそのファイルが何なのかを認識しているだろう。\nしかし、拡張子もファイル名の一部なので、ユーザー側で自由かつ容易に変更することは可能であり、ファイルの拡張子がそのファイルの形式を示しているとは必ずしも限りはしない。\n拡張子ではなく、ファイルの内容からそのファイルが何なのかを判別するにはどうすれば良いのか？\nその際に使うのがUNIXの「file」コマンドである。\nfileコマンドはファイルを引数としてとり、ファイルの内容を見ることでそのファイルのファイル形式を表示してくれるコマンドである。\n使用法 $ file [オプション] ファイル 引数にファイルを指定する。\nオプション  -f・・・検査するファイルの名前をリストファイルから読み込む -L・・・シンボリックリンクの参照先を調べる -z・・・圧縮ファイルの中も調べる -b・・・出力行の最初にファイル名を表示しない -N・・・出力を整列するためのファイル名への空白の追加を行わない  マジックナンバー fileコマンドは拡張子(ファイル名)ではなくファイルの内容を見てファイル形式を確認するとは言ったが、具体的にはどのようにして判断しているのか？\nと言うより、そもそもファイルの形式って拡張子ではなくどのようにして決められているものなのか？\nその秘密がこのマジックナンバーと呼ばれるものである。 マジックナンバーとはファイルの特定の位置に記載されている、ファイルの種類を判別する識別子である。\n マジックナンバーとは、ファイルなどオブジェクト類の形式を識別するもの、フォーマット識別子のことである。 フォーマット識別子としてのマジックナンバーとは、ファイルの種類を識別するのに使われるファイル本文中の（内容中の）特定の位置にある特定の数値のことである。 ファイルの種類を識別する方法としてはファイルの拡張子や属性値（プロパティ）を使う場合もあるが、マジックナンバーとはそれらのことではなく、ファイルの本文中に表れる特定の数値のことである。ほとんどの場合、マジックナンバーはファイルの先頭に位置し、数バイト程度である。(Wikipediaより)\n マジックナンバーはファイルの先頭数バイトに記述されており、この値によってそのファイルの形式が何であるかと言うのが決定される。 fileコマンドはファイルの内容を見るとき、このマジックナンバーを見てそのファイルが何なのであるかを判別している、と言うわけだ。\nマジックナンバーの定義ファイル マジックナンバーのリストはUNIX系OSの場合\n/usr/share/file/magic\nに定義されている（ディストリビューションの違い等により、定義ファイルは異なる場合もある）\nこのファイル内に、各ファイル形式ごとにマジックナンバーが書かれている模様。\n例えばjpegは0xffd8となっている。\n"},{"idx":244,"href":"/docs/programming/string/parseInt/","title":"文字列を数値に変換する","content":" 文字列を数値に変換する 数字の文字列を数値に変換する方法を述べる。\nちなみに、逆の数値を文字列にする方法もある。\nJava  クラスはここではMain.javaとする\nclass Main{ public static void main(String args[]){ String s = \u0026#34;1\u0026#34;; int i = Integer.parseInt(s); System.out.println(i) // 1  } } Javaでは各数値型のラッパークラスに parsexxx(String s) というメソッドがあり、これにより文字列を数値リテラルに変換してくれる。\nint型の場合はintのラッパークラスIntegerにparseIntというメソッドがあり、そのメソッドに文字列を入力すると、対応する数値に変換してくれる。上記例では\u0026rdquo;1\u0026rdquo;という文字列をparseIntに入力すると、int型(数値リテラル)の1が返る。\n数値リテラルに変換できないような文字列を入力するとNumberFormatExceptionという例外エラーが発生する。\n他の数値型に変換したいときは、それぞれ対応するラッパークラスにparsexxメソッドがあるのでそれを活用する。\nclass Main{ public static void main(String args[]){ String s = \u0026#34;1\u0026#34;; long l = Long.parseLong(s); //\u0026#34;1\u0026#34;をLong型に変換  byte b = Byte.parseByte(s); //\u0026#34;1\u0026#34;をByte型に変換  double d = Double.parseDouble(s); //\u0026#34;1\u0026#34;をDouble型に変換  float f = Float.parseFloat(s); //\u0026#34;1\u0026#34;をFloat型に変換  } }  Python  Pythonで数値の文字列を数値リテラルに変換したい時は組み込み関数のint()やfloat()を利用する。\ns = \u0026#34;1\u0026#34; print(s) #\u0026#39;1\u0026#39; s = int(s) print(s) # 1 s = float(s) print(s) # 1.0 数値リテラルに変換できないような文字列を入力したときは、例外ValueErrorを返す。\n\u0026gt;\u0026gt;\u0026gt;s = \u0026#34;+\u0026#34; \u0026gt;\u0026gt;\u0026gt;s = int(s) Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; ValueError: invalid literal for int() with base 10: \u0026#39;+\u0026#39;   "},{"idx":245,"href":"/docs/programming/string/append/","title":"文字列に別の文字列を追加する","content":" 文字列に別の文字列を追加する 文字列の末尾に別の文字列を繋げる方法についてまとめる。\nJava  javaの場合は使用しているクラスにより方法が異なる。\nStringでは + 演算子を使うっことで文字列を連結できる。\n文字列の先頭・末尾に連結する場合はこれで良いが、文字列の途中に別の文字列を追加したい場合は、String.substring(int beginindex, int endindex) メソッドで文字列の一部分のみを取り出せるので、これと + 演算子を利用して連結する。 ちなみにsubstringメソッドはbeginindex〜(endindex-1)までの位置の文字列を取ってくるので注意。\n以下に使用例を示す。\nString s = \u0026#34;test\u0026#34;; String t = \u0026#34;1\u0026#34; + s; System.out.println(t); // 1test String t = \u0026#34;1\u0026#34; + s; System.out.println(t); // test1 String t = s.substring(0,2) + \u0026#34;1\u0026#34; s.substring(2,4); System.out.println(t); // te1st また、StringBuilderクラスを使っている場合は、append(追加する値) メソッドを使うと末尾に追加されるので便利。\n指定した位置に追加したい場合は insert(追加する位置,追加する値) メソッドを使う。 ちなみに、これらメソッドは引数の型にかかわらず入力でき、引数は自動的に文字列型に置き換えられて追加される。\nStringBuilder sb = new StringBuilder(\u0026#34;test\u0026#34;); sb.append(\u0026#34;1\u0026#34;); System.out.println(sb.toString()); // test1 sb.insert(0,\u0026#34;1\u0026#34;); System.out.println(sb.toString()); // 1test1  Python  Pythonでも \u0026ldquo; + \u0026ldquo;,\u0026rdquo; += \u0026ldquo; 演算子を使って文字列を連結できる。\nまた\u0026rdquo; * \u0026ldquo;演算子を使って同じ文字を指定回数連結することもできる。 以下に使用例を示す。\ns = \u0026#34;test\u0026#34; t = s + \u0026#34;1\u0026#34; print(t) # s1 t = s * 5 print(t) # testtesttesttesttest  Javascript  Javascriptでも\u0026rdquo; + \u0026ldquo; 演算子を使って文字列を連結できる。\nvar str = \u0026#39;Hello!\u0026#39; + \u0026#39;World!\u0026#39; console.log(str)    "},{"idx":246,"href":"/docs/programming/string/replace/","title":"文字列を別の文字列に置換する","content":" 文字列を別の文字列に置換する 文字列を別の文字列に置換する方法。 その文字列全ての他、文字列の一部分または文字列中の条件に合う文字列に対する置換も行える。\nJava  javaで文字列を置換したい時は replace() メソッドを使う。\n使用法は以下の通り。\n文字列.replace(置換前の文字列,置換後の文字列); 以下に使用例を示す。\nString s = \u0026#34;test\u0026#34;; String t = s.replace(\u0026#34;t\u0026#34;,\u0026#34;b\u0026#34;); System.out.println(t); // besb 上記例では\u0026rdquo;test\u0026rdquo;という文字列をreplaceメソッドで\u0026rdquo;t\u0026rdquo;を\u0026rdquo;b\u0026rdquo;に置換し、結果を表示している。結果として\u0026rdquo;besb\u0026rdquo;という文字列が表示される。\n Python  Pythonでは文字列型のstrオブジェクトにメソッド replace() があり、これにより文字列中の文字を置換できる。\n使用法は以下の通り。\n文字列.replace(old,new [,count]); これにより文字列中のoldの部分をnewに変換する。 また、オプション引数countがあり、指定すると先頭からcount個分のoldのみを置換する。\nなお、文字列にoldが無い場合は、置換されずにそのまま出力される。\n使用例を以下に示す。\ns = \u0026#34;test\u0026#34; t = s.replace(\u0026#34;t\u0026#34;,\u0026#34;b\u0026#34;) print(t) # \u0026#34;besb\u0026#34; t = s.replace(\u0026#34;t\u0026#34;,\u0026#34;b\u0026#34;,1) print(t) # \u0026#34;best\u0026#34;   "},{"idx":247,"href":"/docs/programming/string/lower/","title":"英字文字列を全て英字小文字にする","content":" 英字文字列を全て英字小文字にする 英字の文字列を全て小文字にする方法について。 小文字の場合も、大文字同様にほとんどの言語で関数やメソッドが用意されているので、それを利用する。\nJava  クラスはここではMain.javaとする\nclass Main{ public static void main(String args[]){ String s = \u0026#34;test\u0026#34;; s = s.toLowerCase(); } } JavaではStringクラスに toLowerCase() というメソッドがあり、これにより文字列を全て英小文字に変換して表示してくれる。\nただし、これも文字列自体が変換されるわけではないので、反映させたい場合は出力を元の変数に代入してやる必要がある。\n Python  s = \u0026#34;test\u0026#34; s = s.lower() Pythonは文字列型のstrオブジェクトにメソッド lower() があり、これにより文字列を全て小文字にできる。\nただし、これも文字列自体が変換されるわけではないので、反映させたい場合は出力を元の変数に代入してやる必要がある。\n  "},{"idx":248,"href":"/docs/programming/string/upper/","title":"英字文字列を全て英字大文字にする","content":" 英字文字列を全て英字大文字にする 英字の文字列を全て大文字にする方法について。 ほとんどの言語では、だいたいこの手の関数やメソッドが用意されているので、それを利用する。\nJava  クラスはここではMain.javaとする\nclass Main{ public static void main(String args[]){ String s = \u0026#34;test\u0026#34;; s = s.toUpperCase(); } } JavaではStringクラスに toUpperCase() というメソッドがあり、これにより文字列を全て英大文字に変換して表示してくれる。\nただし、文字列自体が変換されるわけではないので、反映させたい場合は出力を元の変数に代入してやる必要がある。\n Python  s = \u0026#34;test\u0026#34; s = s.upper() Pythonは文字列型のstrオブジェクトにメソッド upper() があり、これにより文字列を全て大文字にできる。\nただし、これも文字列自体が変換されるわけではないので、反映させたい場合は出力を元の変数に代入してやる必要がある。\n  "},{"idx":249,"href":"/docs/programming/string/string_index/","title":"文字列","content":" 文字列 文字列についての記事。\n 文字列の宣言  文字列を宣言する  文字列の変換・置換  英字文字列を全て英字大文字にする 英字文字列を全て英字小文字にする 文字列を別の文字列に置換する 文字列を数値に変換する １文字からその文字のアスキーコードを取得する  文字列の追加・削除・分割  文字列に別の文字列を追加する 文字列をある文字で分割する  文字列の検索  文字列中にある文字列が含まれているかを確認する 文字列中にある文字列が含まれているときにその位置を確認する 文字列がある文字で始まっている（終わっている）かを確認する  その他  文字列の長さ（文字数）を調べる   "},{"idx":250,"href":"/docs/programming/stdio/stderr/","title":"標準エラー出力","content":" 標準エラー出力 標準エラー出力について。\nJava  クラスはここではMain.javaとする\nclass Main{ public static void main(String args[]){ //出力後、改行したい時  System.err.println(変数もしくはデータ); //出力後、改行したくない時  System.err.print(変数もしくはデータ); } } 基本標準出力の時と同じ。\nただし、エラー出力はjavaの場合例外処理を受け取ったときに利用するため、そのときに出たエラーメッセージを出力するのが普通。\n Python  import sys print(x,file=sys.stderr) # xを画面にエラー出力する Pythonでエラー出力を扱うにはまずsysモジュールをインポートし、\nprint()のfileパラメータに sys.stderr を指定する。\n  "},{"idx":251,"href":"/docs/programming/stdio/stdout/","title":"標準出力","content":" 標準出力 標準出力について。\nJava  クラスはここではMain.javaとする\nclass Main{ public static void main(String args[]){ //出力後、改行したい時  System.out.println(変数もしくはデータ); //出力後、改行したくない時  System.out.print(変数もしくはデータ); } } javaで画面に出力したい時は System.out.println() を利用する。\n引数には画面に出力したい変数またはデータを入れる。 出力後改行したくない時は System.out. print() を使う。\n Python  x=(変数もしくはデータ) print(x) # xを画面に出力して改行する print(x,end=\u0026#34;\u0026#34;) # xを画面に出力して改行しない Pythonでコンソール画面への出力を扱うには組み込み関数の print() を使う。\n基本、入力された引数を画面に出力する。\n改行したくない場合はprint()のendパラメータに\u0026rdquo;\u0026ldquo;を指定。\n詳しくは以下の公式ドキュメント参照。\nhttps://docs.python.org/ja/3/library/functions.html#print\n Javascript  Javascriptはブラウザ上で扱う言語のため、ここではブラウザ上のログ画面への出力という意味で記す。\nJavascriptでは、console.log()を利用する。 引数には出力したい値及び変数を入力する。\nconsole.log(5)    "},{"idx":252,"href":"/docs/programming/stdio/console_input/","title":"コンソール入力","content":" コンソール入力 標準入力のコンソール入力について。\nJava  クラスはここではMain.javaとする\nimport java.util.Scanner class Main{ public static void main(String args[]){ //Scannerのインスタンスを生成  Scanner sc = new Scanner(System.in); //入力を何のデータ型で受け取るかで別れる  //(例)int型  int i = sc.nextInt(); //String型（１行分全て）  String s = sc.nextLine(); //String型（スペース等で区切った一部分ずつ）  String s = sc.next(); } } javaでコンソールからの入力を扱うには Scanner クラスをインポートし、インスタンスを生成する。\nその後、入力データを何のデータ型で受け取るかにより利用するScannerクラスのメソッドが別れるが、多いので一部に留める。\n全て知りたい人は以下の公式サイトを参照。\nhttps://docs.oracle.com/javase/jp/8/docs/api/java/util/Scanner.html\n Python  s = input() # コンソールからの入力をsに格納する Pythonでコンソールからの入力を扱うには組み込み関数の input() を使う。\n基本入力１行を読み込み、文字列に変換して渡される。\n数値にしたい場合はint()で囲うなどし、スペースを区切りたい時などはsplit()等を使う。\n詳しくは以下の公式ドキュメント参照。\nhttps://docs.python.org/ja/3/library/functions.html#input\n  "},{"idx":253,"href":"/docs/programming/stdio/commandline_input/","title":"コマンドライン引数","content":" コマンドライン引数 標準入力のコマンドライン引数について。\nJava  クラスはここではMain.javaとする\nclass Main{ public static void main(String args[]){ String[] input = args //コマンドライン引数を格納した配列を取得する  } } Javaではコマンドライン引数は クラス内で宣言するmainメソッドの引数であるString型の配列(上記コード中の\u0026rdquo;args\u0026rdquo;)に入る。\nコマンドライン引数をスペースで区切って何個かに分けて入力した場合、初めから順にargsの0番目から順に入る。\n Python  import sys inputs = sys.argv # コマンドライン引数を格納したリストを取得する Pythonはsysモジュールのargv属性にコマンドライン引数がリストとして入る。\nコマンドライン引数を取得するには、sysモジュールをインポートしてargvを参照する。\n  "},{"idx":254,"href":"/docs/programming/stdio/stdio_index/","title":"標準入力・出力","content":" 標準入力・出力 標準入力・出力についての記事。\n 標準入力  コマンドライン引数 コンソール入力  標準出力  標準出力 標準エラー出力    データの入力について\nソースコードを実行する時及び実行中に、何かデータを入力して実行することができる。\n具体的な方法としては、\nソースコードを実行するときに、引数としてデータを入力（ コマンドライン引数 と呼ぶ）して実行する方法と、\nソースコードを実行した後に、キーボード等でデータを打ち込んで入力する方法がある。\n（後者はここではコンソール入力と呼ぶことにする、何か具体的な名前ってあったか？）\nデータの出力について\n標準出力は指定したデータの内容をコンソール画面に出力する事を言うが、\n標準出力にも通常の標準出力の他に、エラー発生時用の出力である標準エラー出力というのもある。\n"},{"idx":255,"href":"/posts/heapq/","title":"優先度付きキュー（ヒープ）とPythonで実装するライブラリ「heapq」について","content":" 先日Atcoder Beginner Contest 141に参加してきたが、D問題がいくらやってもTLEになり詰まった挙句TIME UPになった。 原因はリストから最大値を取り出してくる箇所。 リストから最大値を取り出し、２で割って（点以下切り捨て）再度リストに格納、という動作をループで回す必要があったのだが、いくら直してもTLEになり続けた。 自分が考えていた方法としては\n リストの最大値を取る組み込み関数 max() を使う リストをソート ( sort() ) して一番後のインデックスにある要素（＝最大値）を取る  だったのだが、いずれの場合も時間がかかってしまうらしい。 どのようにすれば良かったのか・・？\n解説を見て学んだのが \u0026ldquo;優先度付きキュー\u0026rdquo; というアルゴリズム。 この優先度付きキューについて、調べて見た。\n優先度付きキュー 優先度付きキュー (Priority Queue) とは以下の操作が行えるデータ構造。\n キューに数\u001c（要素）を優先度付きで追加する。 最も高い優先度を持つ要素を取り出す（値を取得し、削除する）  これを二分木（ヒープ）を用いて効率的に実現したデータ構造の事を言う。 ヒープの特性上、優先度付きキューにおいて最も高い優先度を持つ要素とは最小値のことになり、 優先度付きキューとは最小値を取り出す事の出来るデータ構造と言うことになる。\nヒープとは ではヒープ（二分木）とは何か？\n ヒープとは、「子要素は親要素より常に大きいか等しい（または常に小さいか等しい）」と言う制約を持つ木構造の事。単に「ヒープ」という場合、二分木を使った二分ヒープを指すことが多いため、そちらを参照すること。 ヒープは最小値（または最大値）を求めるのに適した木構造の一種であり、「子要素は親要素より常に大きいか等しい（または常に小さいか等しい）」と言う制約を持つ。子要素が複数ある場合、子要素間の大小関係に制約はない。 （Wikipediaより）\n 図に表すと以下のような構造を持つデータ構造である。\n図にある通り、ヒープの特徴としては「子要素は親要素より常に大きいか等しい」と言うところである。 また、ヒープは上から下へ、左から右へ順にノードが詰まっていく。\n「子要素は親要素より常に大きいか等しい」と言う定義から、ヒープの一番親の要素（根）は、ヒープで一番小さい値(最小値)ということになる。\nデータの挿入 ヒープにデータを挿入すると、入力したデータはまずヒープの最後尾に追加され、親要素と大小を比較し、親要素よりも大きくなるまで上に上げていく。（下図）\nデータの削除 ヒープからデータを削除（＝最小値を削除）した時は、根の位置に最後尾の要素を持っていき、その後子要素と大小を比較していずれの子要素よりも小さくなるまで下に下げていく。（下図）\nPythonでの優先度付きキュー ではこのヒープ及び優先度付きキューをプログラミングで実装するにはどうすれば良いのか？ 今回も私が現在競プロでよく使用しているPythonで考えてみることにした。\nしかし、調べてみると何と優先度付きキューもPythonではライブラリが実装されているそうだ。 それがこの heapq と言うライブラリで、このライブラリについて調べて見た。\nバージョン Python : 3.7.4\nheapq heapqライブラリの諸関数を以下に記載する。\nheapify heapify関数はリストをヒープに変換する関数である。\n\u0026gt;\u0026gt;\u0026gt; import heapq \u0026gt;\u0026gt;\u0026gt; a = [7,5,3,2,4,8,10,1] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a [7, 5, 3, 2, 4, 8, 10, 1] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; heapq.heapify(a) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a [1, 2, 3, 5, 4, 8, 10, 7] 変換し作成されたヒープはリストを使って表現される。 このリストでのヒープの見方は、リストのインデックスをkとした時、\n 親要素 : リスト[k] 子要素 : リスト[2k+1]、リスト[2k+2]  となる。\nheappush,heappop heappush関数は要素をヒープにpushする関数である。\npushされた要素は前述のヒープ挿入例に基づき、ヒープ内で要素が移動され、最終的にヒープ内で親子間の大小が保たれた形で保持される。\n対して、heappop関数はヒープから要素を取り出し取得する関数である。 なお、heappopで取り出すのはヒープにおける最小の要素である。\nheappop後のヒープはheappushの時と同様に前述のヒープ削除例に基づき、ヒープ内で要素が移動され、最終的にヒープ内で親子間の大小が保たれた形で保持される。\n使用例を以下に示す。\n\u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; import heapq \u0026gt;\u0026gt;\u0026gt; a=[5,3,2,1,6,13,4,12,14,9,10] \u0026gt;\u0026gt;\u0026gt; heapq.heapify(a) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a [1, 3, 2, 5, 6, 13, 4, 12, 14, 9, 10] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; heapq.heappush(a,7) #7をヒープにプッシュ \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a [1, 3, 2, 5, 6, 7, 4, 12, 14, 9, 10, 13] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; heapq.heappop(a) #ヒープから要素をpop 1 \u0026gt;\u0026gt;\u0026gt; #最小の要素(1)がヒープからpopされる \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a [2, 3, 4, 5, 6, 7, 13, 12, 14, 9, 10] \u0026gt;\u0026gt;\u0026gt;  heappushpop,heapreplace heappushpop関数はheappushとheappopを同時に行う関数である。\n順序としてはheappushを行ってからheappopを行う。\nheapreplace関数はその逆でheappopとheappushを同時に行うと言う点では同じだが、\n順序はheappopを行ってからheappushを行う。\n公式によるとheappushとheappopを別々に行うよりも、これらの関数を使う方が効率的に行えるとの事。\n使用例を以下に示す。\n\u0026gt;\u0026gt;\u0026gt; import heapq \u0026gt;\u0026gt;\u0026gt; a=[5,3,2,1,6,13,4,12,14,9,10] \u0026gt;\u0026gt;\u0026gt; heapq.heapify(a) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a [1, 3, 2, 5, 6, 13, 4, 12, 14, 9, 10] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; heapq.heappushpop(a,11) 1 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a [2, 3, 4, 5, 6, 13, 11, 12, 14, 9, 10] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; heapq.heappushpop(a,1) 1 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a [2, 3, 4, 5, 6, 13, 11, 12, 14, 9, 10] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; heapq.heapreplace(a,7) 2 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a [3, 5, 4, 7, 6, 13, 11, 12, 14, 9, 10] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; heapq.heapreplace(a,1) 3 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a [1, 5, 4, 7, 6, 13, 11, 12, 14, 9, 10] \u0026gt;\u0026gt;\u0026gt;  heappushpop,heapreplaceはpushとpopを行う順序から、popした時に取り出される要素は最小の要素でない場合もあると言うことに注意する。\n上記の例でいうと、ヒープにヒープのどの要素よりも小さい要素をpushした時、heappushpopの場合は要素をpushしてからpopするためpushした要素がpopされるが、 heapreplaceはヒープからpopしてから要素をpushするため、popされる要素はpushする前のヒープの最小値であり、また動作後のヒープはpushした要素が最小値となったヒープになる。\nヒープから最大値を取り出すには？ ヒープはその特性上、最小値しか取り出すことはできない。\nもし、最大値を取り出したいといった時はどうするか？\n方法の一例としては、要素の符号を全て逆転（-1を掛ける）させてからヒープを組ませる。\nすると、そのヒープの最小値には元の最大値×(-1)した要素が来る。\nその要素を取り出して(pop)また符号を逆転（-1を掛ける）させてやれば、最終的には最大値を取り出すことが可能となる。\n\u0026gt;\u0026gt;\u0026gt; import heapq \u0026gt;\u0026gt;\u0026gt; #リスト（ヒープ）aから最大値を取り出す。最大値は14 \u0026gt;\u0026gt;\u0026gt; a=[5,3,2,1,6,13,4,12,14,9,10] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #要素に全て-1をかけて符号を逆転する \u0026gt;\u0026gt;\u0026gt; a=[-1 * i for i in a] \u0026gt;\u0026gt;\u0026gt; a [-5, -3, -2, -1, -6, -13, -4, -12, -14, -9, -10] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; heapq.heapify(a) \u0026gt;\u0026gt;\u0026gt; a [-14, -12, -13, -5, -10, -2, -4, -3, -1, -9, -6] \u0026gt;\u0026gt;\u0026gt; #元の最大値×(-1)させた-14がヒープの最小値に来る \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; #ヒープから最小値を取り出し-1を掛ける \u0026gt;\u0026gt;\u0026gt; heapq.heappop(a) * -1 14 \u0026gt;\u0026gt;\u0026gt; #元の最大値14が取り出された 今後活用する機会があれば利用していきたい。\n"},{"idx":256,"href":"/posts/strings/","title":"stringsコマンド","content":" CTFに興味が出てきたため、\u0008社内のCTFのコミュニティに参加してちょこちょこ参加してはいるのだが、なかなか解き進めない・知識が定着せずに\u0008困っている。 なので、１個１個覚えた知識をこのブログにつけることにした。 最初はこの「strings」コマンドについてを書く。\nLinuxのコマンドにstringsというのがあるのだが、このコマンドは実行ファイルなどのバイナリファイルやデータファイル内から表示可能な文字列を抽出して表示してくれる。\n使用法 $ strings [オプション] ファイル オプション  -a・・・・・ファイル全体をスキャンする -f・・・・・ファイル名も表示する -n 文字数・・最低でも指定した文字数以上の長さを表示する -t 指定・・・「o（8進数）」「x（16進数）」「d（10進数）」のいずれかを指定して表示する  これまで参加したCTFでもファイルが渡さ\u0008れた事が何回かあるのだが、stringsコマンドをやる事でフラグが出ることが何回かあった。 これがまず基本というとこだろうか？（素人意見だが）\n"},{"idx":257,"href":"/posts/bisect/","title":"Pythonで二分探索を行うライブラリ「bisect」","content":" 趣味で競プロをやるようになり、Atcoderの問題を何問か解いているのだが、\nやっている内に覚えないといけないこともいくつかあるわけで。\nその内の一つに二分探索というアルゴリズムを使うという場面を多く見てきたため、自分が今よく利用しているpythonでいつでも使えるように二分探索を行うスクリプトでも書いておこうかと思った。\nしかし取り掛かろうとして調べて見たところ、なんとpythonには二分探索を行うライブラリが最初から用意されているらしい。 それがこの「bisect」というもので、このライブラリについて調べて見た。\nbisect bisectモジュールのbisect関数はリストと値を入力とし、値をリストに挿入する位置のインデックスを返す。 とりあえずは使用例ということで、bisectを使ってみた。\n\u0026gt;\u0026gt;\u0026gt; import bisect \u0026gt;\u0026gt;\u0026gt; a=[10,20,30,40,50,60,70,80,90,100] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; bisect.bisect(a,55) 5 \u0026gt;\u0026gt;\u0026gt;  この例の場合、リストaに値55を入れようとした時、a[\u00085](50と60の間)に入れるのが適切なため、５を返す。\nちなみにbisectを使う時、入力するリストはすでにソート済みであることが前提である（これは本来の二分探索でも同じ）。ソートされてないリストを入力してもエラーは発生しないが、ソートしていないため間違った形で二分探索が行われてしまう。\n\u0026gt;\u0026gt;\u0026gt; import bisect \u0026gt;\u0026gt;\u0026gt; a=[54,32,76,33,89,44,323,67,88,1] \u0026gt;\u0026gt;\u0026gt; bisect.bisect(a,55) # ソートしなくても二分探索は行うが・・・ 6 また、入力した値が既にリストに入っていた場合、リストでその値の前に入れようとするのか、後に入れようとするのか分かれるがどうなるのか？\nbisectモジュールには更にbisect_leftとbisect_rightという関数があり、各々の場合に応じてこれらを使い分ける。 使用例を示す。\n\u0026gt;\u0026gt;\u0026gt; import bisect \u0026gt;\u0026gt;\u0026gt; a=[1,2,2,2,3] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; bisect.bisect_left(a,2) 1 \u0026gt;\u0026gt;\u0026gt; bisect.bisect_right(a,2) 4 \u0026gt;\u0026gt;\u0026gt; bisect.bisect(a,2) 4 この例の場合、a[1]からa[3]まで2であり、bisect_leftで2をリストaに適用すると、挿入点は2の一番前の位置である1を返す。 bisect_rightを使った場合はその逆で、挿入点は2の一番後の位置である4を返す。 ちなみにbisect関数はbisect_rightと同じ動作をする。\ninsort insort関数はbisect関数の動作に加えて、リストへの挿入も行う関数である。 bisect関数と同様に、リストに入力と同じ値があった場合にその値の前か後のどちらに挿入するかは、insort_leftとinsort_rightという関数があるので使い分ける。 ちなみにinsort関数はinsort_rightと同じ動作をする。\n\u0026gt;\u0026gt;\u0026gt; import bisect \u0026gt;\u0026gt;\u0026gt; a=[10,20,30,40,50,60,70,80,90,100] \u0026gt;\u0026gt;\u0026gt; a [10, 20, 30, 40, 50, 60, 70, 80, 90, 100] \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; bisect.insort(a,55) \u0026gt;\u0026gt;\u0026gt; a [10, 20, 30, 40, 50, 55, 60, 70, 80, 90, 100] \u0026gt;\u0026gt;\u0026gt;  P.S.\n今後二分探索をする必要が出てきたときはこれらを活用していきたい。 まあでも、できればライブラリ頼りではなく、本当はアルゴリズム自体も自分で理解して、一から書けるようにもすべきだけど・・ね\n"},{"idx":258,"href":"/posts/initial/","title":"Hugo初投稿","content":"投稿テスト。\nMy Githubにhugoでブログを立ててみました。\n個人用に、技術的な事をここに色々メモしていく予定。\nでもまず、MarkDownに慣れねばならないね・・\n続けられる様に頑張ります！\n"},{"idx":259,"href":"/docs/programming/list/list_index/","title":"配列・リスト","content":" 配列・リスト 配列・リストについての記事。\nこれらは言語により定義が違うので注意。\n例えばJavaでは配列とリストは別のデータ構造だが、\nPythonではリスト（・タプル）のみで、配列という概念はない。（全部ひっくるめてリストとしている？個人の理解だが）\n配列  配列 多次元配列  リスト（・タプル）  リストの定義 リストの宣言 リストの長さ リストへの要素追加 リストの指定した位置に要素追加 リストの全要素の合計値 リストのソート リストを逆順にソート リストを逆順にする リストa,bに共通して入っている要素のみを表示（積集合） リストaまたはbに入っている要素のみを表示（和集合） リストaにありリストbに入ってない要素のみを表示（差集合） 文字列を１文字ずつのリストにする リストの指定したインデックスの要素を削除する リストの指定した要素を削除する 指定した要素がリスト内にいくつあるか調べる 指定した要素がリスト内にあるか調べる リスト内の指定した２要素を入れ替える リストの全要素を連結して１つの文字列に変換する リストから条件に合う要素のみを取得した新しいリストを作成する 多次元リスト(配列)である列をキーにしてソートする 指定した要素のリスト内でのインデックスを調べる リストの内一番大きい要素を調べる リストの内一番小さい要素を調べる ２つの配列a,bの同じインデックスの要素を１つの組にした２次元配列を作る リストが空であるか判別する リストを空にする (Python)リスト内包表記 Set型 (Python)タプル  "},{"idx":260,"href":"/docs/sample/goisforlovers/","title":"(Hu)go Template Primer","content":" Hugo uses the excellent Go html/template library for its template engine. It is an extremely lightweight engine that provides a very small amount of logic. In our experience that it is just the right amount of logic to be able to create a good static website. If you have used other template systems from different languages or frameworks you will find a lot of similarities in Go templates.\nThis document is a brief primer on using Go templates. The Go docs provide more details.\nIntroduction to Go Templates Go templates provide an extremely simple template language. It adheres to the belief that only the most basic of logic belongs in the template or view layer. One consequence of this simplicity is that Go templates parse very quickly.\nA unique characteristic of Go templates is they are content aware. Variables and content will be sanitized depending on the context of where they are used. More details can be found in the Go docs.\nBasic Syntax Golang templates are HTML files with the addition of variables and functions.\nGo variables and functions are accessible within {{ }}\nAccessing a predefined variable \u0026ldquo;foo\u0026rdquo;:\n{{ foo }}  Parameters are separated using spaces\nCalling the add function with input of 1, 2:\n{{ add 1 2 }}  Methods and fields are accessed via dot notation\nAccessing the Page Parameter \u0026ldquo;bar\u0026rdquo;\n{{ .Params.bar }}  Parentheses can be used to group items together\n{{ if or (isset .Params \u0026quot;alt\u0026quot;) (isset .Params \u0026quot;caption\u0026quot;) }} Caption {{ end }}  Variables Each Go template has a struct (object) made available to it. In hugo each template is passed either a page or a node struct depending on which type of page you are rendering. More details are available on the variables page.\nA variable is accessed by referencing the variable name.\n\u0026lt;title\u0026gt;{{ .Title }}\u0026lt;/title\u0026gt;  Variables can also be defined and referenced.\n{{ $address := \u0026quot;123 Main St.\u0026quot;}} {{ $address }}  Functions Go template ship with a few functions which provide basic functionality. The Go template system also provides a mechanism for applications to extend the available functions with their own. Hugo template functions provide some additional functionality we believe are useful for building websites. Functions are called by using their name followed by the required parameters separated by spaces. Template functions cannot be added without recompiling hugo.\nExample:\n{{ add 1 2 }}  Includes When including another template you will pass to it the data it will be able to access. To pass along the current context please remember to include a trailing dot. The templates location will always be starting at the /layout/ directory within Hugo.\nExample:\n{{ template \u0026quot;chrome/header.html\u0026quot; . }}  Logic Go templates provide the most basic iteration and conditional logic.\nIteration Just like in Go, the Go templates make heavy use of range to iterate over a map, array or slice. The following are different examples of how to use range.\nExample 1: Using Context\n{{ range array }} {{ . }} {{ end }}  Example 2: Declaring value variable name\n{{range $element := array}} {{ $element }} {{ end }}  Example 2: Declaring key and value variable name\n{{range $index, $element := array}} {{ $index }} {{ $element }} {{ end }}  Conditionals If, else, with, or, \u0026amp; and provide the framework for handling conditional logic in Go Templates. Like range, each statement is closed with end.\nGo Templates treat the following values as false:\n false 0 any array, slice, map, or string of length zero  Example 1: If\n{{ if isset .Params \u0026quot;title\u0026quot; }}\u0026lt;h4\u0026gt;{{ index .Params \u0026quot;title\u0026quot; }}\u0026lt;/h4\u0026gt;{{ end }}  Example 2: If -\u0026gt; Else\n{{ if isset .Params \u0026quot;alt\u0026quot; }} {{ index .Params \u0026quot;alt\u0026quot; }} {{else}} {{ index .Params \u0026quot;caption\u0026quot; }} {{ end }}  Example 3: And \u0026amp; Or\n{{ if and (or (isset .Params \u0026quot;title\u0026quot;) (isset .Params \u0026quot;caption\u0026quot;)) (isset .Params \u0026quot;attr\u0026quot;)}}  Example 4: With\nAn alternative way of writing \u0026ldquo;if\u0026rdquo; and then referencing the same value is to use \u0026ldquo;with\u0026rdquo; instead. With rebinds the context . within its scope, and skips the block if the variable is absent.\nThe first example above could be simplified as:\n{{ with .Params.title }}\u0026lt;h4\u0026gt;{{ . }}\u0026lt;/h4\u0026gt;{{ end }}  Example 5: If -\u0026gt; Else If\n{{ if isset .Params \u0026quot;alt\u0026quot; }} {{ index .Params \u0026quot;alt\u0026quot; }} {{ else if isset .Params \u0026quot;caption\u0026quot; }} {{ index .Params \u0026quot;caption\u0026quot; }} {{ end }}  Pipes One of the most powerful components of Go templates is the ability to stack actions one after another. This is done by using pipes. Borrowed from unix pipes, the concept is simple, each pipeline\u0026rsquo;s output becomes the input of the following pipe.\nBecause of the very simple syntax of Go templates, the pipe is essential to being able to chain together function calls. One limitation of the pipes is that they only can work with a single value and that value becomes the last parameter of the next pipeline.\nA few simple examples should help convey how to use the pipe.\nExample 1 :\n{{ if eq 1 1 }} Same {{ end }}  is the same as\n{{ eq 1 1 | if }} Same {{ end }}  It does look odd to place the if at the end, but it does provide a good illustration of how to use the pipes.\nExample 2 :\n{{ index .Params \u0026quot;disqus_url\u0026quot; | html }}  Access the page parameter called \u0026ldquo;disqus_url\u0026rdquo; and escape the HTML.\nExample 3 :\n{{ if or (or (isset .Params \u0026quot;title\u0026quot;) (isset .Params \u0026quot;caption\u0026quot;)) (isset .Params \u0026quot;attr\u0026quot;)}} Stuff Here {{ end }}  Could be rewritten as\n{{ isset .Params \u0026quot;caption\u0026quot; | or isset .Params \u0026quot;title\u0026quot; | or isset .Params \u0026quot;attr\u0026quot; | if }} Stuff Here {{ end }}  Context (aka. the dot) The most easily overlooked concept to understand about Go templates is that {{ . }} always refers to the current context. In the top level of your template this will be the data set made available to it. Inside of a iteration it will have the value of the current item. When inside of a loop the context has changed. . will no longer refer to the data available to the entire page. If you need to access this from within the loop you will likely want to set it to a variable instead of depending on the context.\nExample:\n {{ $title := .Site.Title }} {{ range .Params.tags }} \u0026lt;li\u0026gt; \u0026lt;a href=\u0026quot;{{ $baseurl }}/tags/{{ . | urlize }}\u0026quot;\u0026gt;{{ . }}\u0026lt;/a\u0026gt; - {{ $title }} \u0026lt;/li\u0026gt; {{ end }}  Notice how once we have entered the loop the value of {{ . }} has changed. We have defined a variable outside of the loop so we have access to it from within the loop.\nHugo Parameters Hugo provides the option of passing values to the template language through the site configuration (for sitewide values), or through the meta data of each specific piece of content. You can define any values of any type (supported by your front matter/config format) and use them however you want to inside of your templates.\nUsing Content (page) Parameters In each piece of content you can provide variables to be used by the templates. This happens in the front matter.\nAn example of this is used in this documentation site. Most of the pages benefit from having the table of contents provided. Sometimes the TOC just doesn\u0026rsquo;t make a lot of sense. We\u0026rsquo;ve defined a variable in our front matter of some pages to turn off the TOC from being displayed.\nHere is the example front matter:\n--- title: \u0026quot;Permalinks\u0026quot; date: \u0026quot;2013-11-18\u0026quot; aliases: - \u0026quot;/doc/permalinks/\u0026quot; groups: [\u0026quot;extras\u0026quot;] groups_weight: 30 notoc: true ---  Here is the corresponding code inside of the template:\n {{ if not .Params.notoc }} \u0026lt;div id=\u0026quot;toc\u0026quot; class=\u0026quot;well col-md-4 col-sm-6\u0026quot;\u0026gt; {{ .TableOfContents }} \u0026lt;/div\u0026gt; {{ end }}  Using Site (config) Parameters In your top-level configuration file (eg, config.yaml) you can define site parameters, which are values which will be available to you in chrome.\nFor instance, you might declare:\nparams: CopyrightHTML: \u0026#34;Copyright \u0026amp;#xA9; 2013 John Doe. All Rights Reserved.\u0026#34; TwitterUser: \u0026#34;spf13\u0026#34; SidebarRecentLimit: 5 Within a footer layout, you might then declare a \u0026lt;footer\u0026gt; which is only provided if the CopyrightHTML parameter is provided, and if it is given, you would declare it to be HTML-safe, so that the HTML entity is not escaped again. This would let you easily update just your top-level config file each January 1st, instead of hunting through your templates.\n{{if .Site.Params.CopyrightHTML}}\u0026lt;footer\u0026gt; \u0026lt;div class=\u0026quot;text-center\u0026quot;\u0026gt;{{.Site.Params.CopyrightHTML | safeHtml}}\u0026lt;/div\u0026gt; \u0026lt;/footer\u0026gt;{{end}}  An alternative way of writing the \u0026ldquo;if\u0026rdquo; and then referencing the same value is to use \u0026ldquo;with\u0026rdquo; instead. With rebinds the context . within its scope, and skips the block if the variable is absent:\n{{with .Site.Params.TwitterUser}}\u0026lt;span class=\u0026quot;twitter\u0026quot;\u0026gt; \u0026lt;a href=\u0026quot;https://twitter.com/{{.}}\u0026quot; rel=\u0026quot;author\u0026quot;\u0026gt; \u0026lt;img src=\u0026quot;/images/twitter.png\u0026quot; width=\u0026quot;48\u0026quot; height=\u0026quot;48\u0026quot; title=\u0026quot;Twitter: {{.}}\u0026quot; alt=\u0026quot;Twitter\u0026quot;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/span\u0026gt;{{end}}  Finally, if you want to pull \u0026ldquo;magic constants\u0026rdquo; out of your layouts, you can do so, such as in this example:\n\u0026lt;nav class=\u0026quot;recent\u0026quot;\u0026gt; \u0026lt;h1\u0026gt;Recent Posts\u0026lt;/h1\u0026gt; \u0026lt;ul\u0026gt;{{range first .Site.Params.SidebarRecentLimit .Site.Recent}} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;{{.RelPermalink}}\u0026quot;\u0026gt;{{.Title}}\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; {{end}}\u0026lt;/ul\u0026gt; \u0026lt;/nav\u0026gt;  "},{"idx":261,"href":"/docs/sample/hugoisforlovers/","title":"Getting Started with Hugo","content":" Step 1. Install Hugo Go to Hugo releases and download the appropriate version for your OS and architecture.\nSave it somewhere specific as we will be using it in the next step.\nMore complete instructions are available at Install Hugo\nStep 2. Build the Docs Hugo has its own example site which happens to also be the documentation site you are reading right now.\nFollow the following steps:\n Clone the Hugo repository Go into the repo Run hugo in server mode and build the docs Open your browser to http://localhost:1313  Corresponding pseudo commands:\ngit clone https://github.com/spf13/hugo cd hugo /path/to/where/you/installed/hugo server --source=./docs \u0026gt; 29 pages created \u0026gt; 0 tags index created \u0026gt; in 27 ms \u0026gt; Web Server is available at http://localhost:1313 \u0026gt; Press ctrl+c to stop  Once you\u0026rsquo;ve gotten here, follow along the rest of this page on your local build.\nStep 3. Change the docs site Stop the Hugo process by hitting Ctrl+C.\nNow we are going to run hugo again, but this time with hugo in watch mode.\n/path/to/hugo/from/step/1/hugo server --source=./docs --watch \u0026gt; 29 pages created \u0026gt; 0 tags index created \u0026gt; in 27 ms \u0026gt; Web Server is available at http://localhost:1313 \u0026gt; Watching for changes in /Users/spf13/Code/hugo/docs/content \u0026gt; Press ctrl+c to stop  Open your favorite editor and change one of the source content pages. How about changing this very file to fix the typo. How about changing this very file to fix the typo.\nContent files are found in docs/content/. Unless otherwise specified, files are located at the same relative location as the url, in our case docs/content/overview/quickstart.md.\nChange and save this file.. Notice what happened in your terminal.\n\u0026gt; Change detected, rebuilding site \u0026gt; 29 pages created \u0026gt; 0 tags index created \u0026gt; in 26 ms  Refresh the browser and observe that the typo is now fixed.\nNotice how quick that was. Try to refresh the site before it\u0026rsquo;s finished building. I double dare you. Having nearly instant feedback enables you to have your creativity flow without waiting for long builds.\nStep 4. Have fun The best way to learn something is to play with it.\n"},{"idx":262,"href":"/docs/sample/examples/","title":"Examples","content":" Ubi loqui Mentem genus facietque salire tempus bracchia Lorem markdownum partu paterno Achillem. Habent amne generosi aderant ad pellem nec erat sustinet merces columque haec et, dixit minus nutrit accipiam subibis subdidit. Temeraria servatum agros qui sed fulva facta. Primum ultima, dedit, suo quisque linguae medentes fixo: tum petis.\nRapit vocant si hunc siste adspice Ora precari Patraeque Neptunia, dixit Danae Cithaeron armaque maxima in nati Coniugis templis fluidove. Effugit usus nec ingreditur agmen ac manus conlato. Nullis vagis nequiquam vultibus aliquos altera suum venis teneas fretum. Armos remotis hoc sine ferrea iuncta quam!\nLocus fuit caecis Nefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate.\niscsi_virus = pitch(json_in_on(eupViral), northbridge_services_troubleshooting, personal( firmware_rw.trash_rw_crm.device(interactive_gopher_personal, software, -1), megabit, ergonomicsSoftware(cmyk_usb_panel, mips_whitelist_duplex, cpa))); if (5) { managementNetwork += dma - boolean; kilohertz_token = 2; honeypot_affiliate_ergonomics = fiber; } mouseNorthbridge = byte(nybble_xmp_modem.horse_subnet( analogThroughputService * graphicPoint, drop(daw_bit, dnsIntranet), gateway_ospf), repository.domain_key.mouse(serverData(fileNetwork, trim_duplex_file), cellTapeDirect, token_tooltip_mashup( ripcordingMashup))); module_it = honeypot_driver(client_cold_dvr(593902, ripping_frequency) + coreLog.joystick(componentUdpLink), windows_expansion_touchscreen); bashGigabit.external.reality(2, server_hardware_codec.flops.ebookSampling( ciscNavigationBacklink, table + cleanDriver), indexProtocolIsp);  Placabilis coactis nega ingemuit ignoscat nimia non Frontis turba. Oculi gravis est Delphice; inque praedaque sanguine manu non.\nif (ad_api) { zif += usb.tiffAvatarRate(subnet, digital_rt) + exploitDrive; gigaflops(2 - bluetooth, edi_asp_memory.gopher(queryCursor, laptop), panel_point_firmware); spyware_bash.statePopApplet = express_netbios_digital( insertion_troubleshooting.brouter(recordFolderUs), 65); } recursionCoreRay = -5; if (hub == non) { portBoxVirus = soundWeb(recursive_card(rwTechnologyLeopard), font_radcab, guidCmsScalable + reciprocalMatrixPim); left.bug = screenshot; } else { tooltipOpacity = raw_process_permalink(webcamFontUser, -1); executable_router += tape; } if (tft) { bandwidthWeb *= social_page; } else { regular += 611883; thumbnail /= system_lag_keyboard; }  Caesorum illa tu sentit micat vestes papyriferi Inde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.\nVenasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto! Sedes ante dum superest extrema.\n"},{"idx":263,"href":"/docs/sample/hidden/","title":"Hidden","content":" This page is hidden in menu Quondam non pater est dignior ille Eurotas Latent te facies Lorem markdownum arma ignoscas vocavit quoque ille texit mandata mentis ultimus, frementes, qui in vel. Hippotades Peleus pennas conscia cuiquam Caeneus quas.\n Pater demittere evincitque reddunt Maxime adhuc pressit huc Danaas quid freta Soror ego Luctus linguam saxa ultroque prior Tatiumque inquit Saepe liquitur subita superata dederat Anius sudor  Cum honorum Latona O fallor in sustinui iussorum equidem. Nymphae operi oris alii fronde parens dumque, in auro ait mox ingenti proxima iamdudum maius?\nreality(burnDocking(apache_nanometer), pad.property_data_programming.sectorBrowserPpga(dataMask, 37, recycleRup)); intellectualVaporwareUser += -5 * 4; traceroute_key_upnp /= lag_optical(android.smb(thyristorTftp)); surge_host_golden = mca_compact_device(dual_dpi_opengl, 33, commerce_add_ppc); if (lun_ipv) { verticalExtranet(1, thumbnail_ttl, 3); bar_graphics_jpeg(chipset - sector_xmp_beta); }  Fronde cetera dextrae sequens pennis voce muneris Acta cretus diem restet utque; move integer, oscula non inspirat, noctisque scelus! Nantemque in suas vobis quamvis, et labori!\nvar runtimeDiskCompiler = home - array_ad_software; if (internic \u0026gt; disk) { emoticonLockCron += 37 + bps - 4; wan_ansi_honeypot.cardGigaflops = artificialStorageCgi; simplex -= downloadAccess; } var volumeHardeningAndroid = pixel + tftp + onProcessorUnmount; sector(memory(firewire + interlaced, wired));  "},{"idx":264,"href":"/docs/sample/sample_index/","title":"Sample Index","content":" サンプルページ creating-a-new-theme example goisforlovers hidden hugoisforlovers migrate-from-jekyll shortcodes with-toc without-toc "},{"idx":265,"href":"/docs/sample/shortcodes/","title":"Shortcodes","content":" Shortcodes Expand shortcode Default {{\u0026lt; expand \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /expand \u0026gt;}}  Expand ↕  Markdown content Lorem markdownum insigne\u0026hellip;    With Custom Label {{\u0026lt; expand \u0026#34;Custom Label\u0026#34; \u0026#34;...\u0026#34; \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /expand \u0026gt;}}  Custom Label ...  Markdown content Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.    Buttons {{\u0026lt; button relref=\u0026#34;/\u0026#34; [class=\u0026#34;...\u0026#34;] \u0026gt;}}Get Home{{\u0026lt; /button \u0026gt;}} {{\u0026lt; button href=\u0026#34;https://github.com/alex-shpak/hugo-book\u0026#34; \u0026gt;}}Contribute{{\u0026lt; /button \u0026gt;}}  Get Home  Contribute  Tabs {{\u0026lt; tabs \u0026#34;uniqueid\u0026#34; \u0026gt;}} {{\u0026lt; tab \u0026#34;MacOS\u0026#34; \u0026gt;}} # MacOS Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; tab \u0026#34;Linux\u0026#34; \u0026gt;}} # Linux Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; tab \u0026#34;Windows\u0026#34; \u0026gt;}} # Windows Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; /tabs \u0026gt;}} MacOS  MacOS This is tab MacOS content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\n Linux  Linux This is tab Linux content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\n Windows  Windows This is tab Windows content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\n  Columns {{\u0026lt; columns \u0026gt;}} \u0026lt;!-- begin columns block --\u0026gt; # Left Content Lorem markdownum insigne... \u0026lt;---\u0026gt; \u0026lt;!-- magic sparator, between columns --\u0026gt; # Mid Content Lorem markdownum insigne... \u0026lt;---\u0026gt; \u0026lt;!-- magic sparator, between columns --\u0026gt; # Right Content Lorem markdownum insigne... {{\u0026lt; /columns \u0026gt;}} Left Content Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.  Mid Content Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter!  Right Content Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.   Mermaid Chart {{\u0026lt; mermaid [class=\u0026#34;text-center\u0026#34;]\u0026gt;}} sequenceDiagram Alice-\u0026gt;\u0026gt;Bob: Hello Bob, how are you? alt is sick Bob-\u0026gt;\u0026gt;Alice: Not so good :( else is well Bob-\u0026gt;\u0026gt;Alice: Feeling fresh like a daisy end opt Extra response Bob-\u0026gt;\u0026gt;Alice: Thanks for asking end {{\u0026lt; /mermaid \u0026gt;}}   sequenceDiagram Alice-Bob: Hello Bob, how are you? alt is sick Bob-Alice: Not so good :( else is well Bob-Alice: Feeling fresh like a daisy end opt Extra response Bob-Alice: Thanks for asking end   "},{"idx":266,"href":"/docs/sample/with-toc/","title":"With Toc","content":" Caput vino delphine in tamen vias Cognita laeva illo fracta Lorem markdownum pavent auras, surgit nunc cingentibus libet Laomedonque que est. Pastor An arbor filia foedat, ne fugit aliter, per. Helicona illas et callida neptem est Oresitrophos caput, dentibus est venit. Tenet reddite famuli praesentem fortibus, quaeque vis foret si frondes gelidos gravidae circumtulit inpulit armenta nativum.\n Te at cruciabere vides rubentis manebo Maturuit in praetemptat ruborem ignara postquam habitasse Subitarum supplevit quoque fontesque venabula spretis modo Montis tot est mali quasque gravis Quinquennem domus arsit ipse Pellem turis pugnabant locavit  Natus quaerere Pectora et sine mulcere, coniuge dum tincta incurvae. Quis iam; est dextra Peneosque, metuis a verba, primo. Illa sed colloque suis: magno: gramen, aera excutiunt concipit.\n Phrygiae petendo suisque extimuit, super, pars quod audet! Turba negarem. Fuerat attonitus; et dextra retinet sidera ulnas undas instimulat vacuae generis? Agnus dabat et ignotis dextera, sic tibi pacis feriente at mora euhoeque comites hostem vestras Phineus. Vultuque sanguine dominoque metuit risi fama vergit summaque meus clarissimus artesque tinguebat successor nominis cervice caelicolae.\n Limitibus misere sit Aurea non fata repertis praerupit feruntur simul, meae hosti lentaque citius levibus, cum sede dixit, Phaethon texta. Albentibus summos multifidasque iungitur loquendi an pectore, mihi ursaque omnia adfata, aeno parvumque in animi perlucentes. Epytus agis ait vixque clamat ornum adversam spondet, quid sceptra ipsum est. Reseret nec; saeva suo passu debentia linguam terga et aures et cervix de ubera. Coercet gelidumque manus, doluit volvitur induta?\nEnim sua Iuvenilior filia inlustre templa quidem herbis permittat trahens huic. In cruribus proceres sole crescitque fata, quos quos; merui maris se non tamen in, mea.\nGermana aves pignus tecta Mortalia rudibusque caelum cognosceret tantum aquis redito felicior texit, nec, aris parvo acre. Me parum contulerant multi tenentem, gratissime suis; vultum tu occupat deficeret corpora, sonum. E Actaea inplevit Phinea concepit nomenque potest sanguine captam nulla et, in duxisses campis non; mercede. Dicere cur Leucothoen obitum?\nPostibus mittam est nubibus principium pluma, exsecratur facta et. Iunge Mnemonidas pallamque pars; vere restitit alis flumina quae quoque, est ignara infestus Pyrrha. Di ducis terris maculatum At sede praemia manes nullaque!\n"},{"idx":267,"href":"/docs/sample/without-toc/","title":"Without Toc","content":" At me ipso nepotibus nunc celebratior genus Tanto oblite Lorem markdownum pectora novis patenti igne sua opus aurae feras materiaque illic demersit imago et aristas questaque posset. Vomit quoque suo inhaesuro clara. Esse cumque, per referri triste. Ut exponit solisque communis in tendens vincetis agisque iamque huic bene ante vetat omina Thebae rates. Aeacus servat admonitu concidit, ad resimas vultus et rugas vultu dignamque Siphnon.\nQuam iugulum regia simulacra, plus meruit humo pecorumque haesit, ab discedunt dixit: ritu pharetramque. Exul Laurenti orantem modo, per densum missisque labor manibus non colla unum, obiectat. Tu pervia collo, fessus quae Cretenque Myconon crate! Tegumenque quae invisi sudore per vocari quaque plus ventis fluidos. Nodo perque, fugisse pectora sorores.\nSumme promissa supple vadit lenius Quibus largis latebris aethera versato est, ait sentiat faciemque. Aequata alis nec Caeneus exululat inclite corpus est, ire tibi ostendens et tibi. Rigent et vires dique possent lumina; eadem dixit poma funeribus paret et felix reddebant ventis utile lignum.\n Remansit notam Stygia feroxque Et dabit materna Vipereas Phrygiaeque umbram sollicito cruore conlucere suus Quarum Elis corniger Nec ieiunia dixit  Vertitur mos ortu ramosam contudit dumque; placabat ac lumen. Coniunx Amoris spatium poenamque cavernis Thebae Pleiadasque ponunt, rapiare cum quae parum nimium rima.\nQuidem resupinus inducto solebat una facinus quae Credulitas iniqua praepetibus paruit prospexit, voce poena, sub rupit sinuatur, quin suum ventorumque arcadiae priori. Soporiferam erat formamque, fecit, invergens, nymphae mutat fessas ait finge.\n Baculum mandataque ne addere capiti violentior Altera duas quam hoc ille tenues inquit Sicula sidereus latrantis domoque ratae polluit comites Possit oro clausura namque se nunc iuvenisque Faciem posuit Quodque cum ponunt novercae nata vestrae aratra  Ite extrema Phrygiis, patre dentibus, tonso perculit, enim blanda, manibus fide quos caput armis, posse! Nocendo fas Alcyonae lacertis structa ferarum manus fulmen dubius, saxa caelum effuge extremis fixum tumor adfecit bella, potentes? Dum nec insidiosa tempora tegit spirarunt. Per lupi pars foliis, porreximus humum negant sunt subposuere Sidone steterant auro. Memoraverit sine: ferrum idem Orion caelum heres gerebat fixis?\n"},{"idx":268,"href":"/docs/sub-section/","title":"Sub Section","content":" Fida abluere audiat moram ferarum terram virgae Facere fluidove ab naides ut sic cornu Lorem markdownum Lucifer est, ire tangit inposito terram. Ore et pes lavet nuper longam, longa sub, erat nec Lemnicolae, in. Et nec tantaque sollicitive cognovi et ut videbar verso passis, Epimethida tutos. Dedecus Desine morae.\nFervens esse et tenet cinisque per: et vir equus formaque superorum tollit, vires meae magnum; Latona. Fundamine potitur genialis: imagine gaudet et herba rura vates horrendum, laborum quis: potero aureus habitantque illos nox? E factorum breve ad in verum Euboea templis volitat pompa aureus pallebant videres, replet inque color? Capit et bipennem Finis sonuere magno nec pennis exhortatur tenebat, ait.\nGurgite caede Hippocoon auxilio furit Freta amatos. Saxum vocanti Iovem sui quicquam viro linguae minus, ara nec tu ipsa ars miserae, quam tetigit vacet inque. Fuistis Deucalion, populi invidiae indicat texere est Helicon simul.\n Hominum quantaque membra duos Domum tela Totus penna Charaxi cogitis Hoc caelo est removit Anubis Simulacra Delo posset insula Infelix et nox fixa adhuc  Trabes per coercet mittere toro Cerae movit: patria quid, Alpheias magicaeque puer! Cum venit quidem, sors erigor coniunctis sparsa carpe periuria in vultu temperat gradibus. Tutus fecimus, caput; flamma mentis retia fuit Pallas.\n Arbore et agitasse partes patrem dumque ab, nec infans, sollemnia summis resque, de malles ille? Ultor fugaverat nemus, quaerenti nolle coniugis manibus contraque pace. Fuit verba ipse ignavi vulnus. Nam illud inferius iuvenale iuncta tandem.\n Deus hostia Peneidas ad passu in venerat postes nymphae. Sagittis tabo sibi marmoreum.\n"},{"idx":269,"href":"/docs/sub-section/ego-numen/","title":"Ego Numen","content":" Ego numen obest Mors curru Iove pedibus curva humano salutem Lorem markdownum, mole, profugus. Madida ne quantus, pars verba lacrimis memorique longius cupidi ipse attrahit et. Vota liberiore rector suos fallit videor iustissimus barbara quod habet. Tantum patriaeque omnia spectes inimica mari nec spemque ululare: nuper quodque, sic, quo.\nvar php_wireless = 4; siteWinsock.switch_inbox += so_control_logic; if (target_website.bugCopyrightIcs.cms_digital_method(mca_active) \u0026gt; cloneScrollHttps) { https_drop_hard(97, sshPayload + autoresponder_bmp_file); hypertextCommercialBookmark = optical_impact; } architecture = userRate.unfriend(petabyteFile(irc, wave, logic_tag.impact.cookie_favorites(5, 83)), listserv, malware_cad( disk));  Populi annum deprendere suae recumbis in sedem starent! Super non accedat percepitque negare inconcessisque habitare: puerum: picta. Haec natamque, in rubentem auctore quantas oetaeas certamine levatae sollicitumque mecum vultu obstructaque. Limina subtemen qui trepidare virgine! Enim rumor paenituit haec crimine Melampus sidus.\nPartem robora herbae ilice hic exspectatus tepidique Heu fugit carne, illo ex Iunonis ut tempora sacrata, adhaesi. Fallunt eque amnes!\n Vile ille res sidera gaudebat felicia auxilium Sacra curam adfusique vasti progenitore omnia nutantem Quod notum spesque extentam fores in voces In qualia aequo Auro commoda Mearum huic volucres locorum formosus  Invidiae fidemque cogamque esset potentia Minos Sub silicem, semesaque nec, pone pariterque tendentem, in pactae suarum recurvas et contra tu minister via. Subducere tangeris neque coniunxque utque. Virga altam, mortemque: ubi procul, et vidi committit. Et Alpheos! Perfide age magna per aequor abstulerat, Boeotia sentit succincta ad linquit confugisse certae, de dignatur et!\n Sic nacta saxo crura, iustis rorantia premens tempora lecte sumpsisse nusquam ulvam, apta! Sed sub plumas consueta quae; tibi mihi nec committi mundi?\n Ipsa dea serpentum illic; aspicit reticere Aeaciden mitto; est novis exul. Invidit senior vela, cava sed plumae vident ille ipse domo litus ac fallere lumina, nisi famem cycno.\nNunc miserata admisitque nata, cum loco, iacerent, te medullas matres. Fraude tamen, prorumpit puerum primo polus regalia pampineis iungunt nec, aderis replent carituraque cervus. Primusque lapides ad inpia pedibus; non fare praeterit penetralia in pedum uror. Rapitur vivis lacrimis, vena et dixit.\n"},{"idx":270,"href":"/docs/sub-section/natusque/","title":"Natusque","content":" Natusque putat tu vero Scylaceaque neve coepisse Lorem markdownum hostem et addit arbusta iacuit laetissimus medio, quae quoque faciente. Belli et fuerant fuerat, curas Abas equos sacerdos iactasque videndo tanto, sub. Et simulasse caedis, est nec acre addiderat, manet Phrygiae quisquam, ater, aura sua deique cornua. Bacchi dixi cum tollit, ad sinistra mirum, non se dis fraudare in decimo vocet. Ducunt Acrisio sine ratem: enim illas venti, ferit nam ora.\n Crescente cernis ritusque et vertice potui, fugam conferat enim, quin te Iuno, Calydonia! Cursum est suo lassant quam cutis virgo urbe illa auras, finem. Trabem est secedere Bybli laudant quercus tribuitque relinque et cornua ora, et quoniam maledicere viscera caelobracchia omne hoc. Metaque Arcas patet intraverat tenet.\n Silvisque primae tulisset sive sonuere, incola visa veniat temptantes spernimur et dictis se. Sub gerunt. Aqua tantum templi peregrinis ut aevo cuique falsi, ibat avidae transitus.\nModo auctor imbres est Clanis cernere monstravit illic quoque, in ignis male una deme? Alta sonanti relatus Pindo: nisi Pico edidit data tamen rurigenae avoque. Quotiens vela petis inposuit et parte utque, tempus pars contendere facturus tumidus. Flores culpavit fera retinens, vita puer publica ferebat positas.\nif (mashupTopologyMnemonic(70) \u0026gt;= domain_correction_schema) { romTeraflops = log_android; mms_vrml_alignment(keyboard, oop, computerCodec); } retina_samba_arp *= desktop_itunes_mainframe(leopard, 511935) * 88 / direct_excel(-3, infringement_bespoke_apache, cmyk); drivePowerPlay.registryAix += dma; text_data.upsOdbc = error(user(processor_token_forum) * art_ajax_ldap);  Patriaque volvitur scire Naryciusque iuvenem dixit adfusique bicorni cupido. Tecumque corpore sublato, mox hostibus et muneris, non. Draconum noscit dapibus scopulis spondere lupum diro, illo ille victoque cibis; umentia spes.\nAlumno est postquam gracili adnuimusque ore est praemia, ulla patitur: te disce erat cruribus prosunt. Arboris illis neque, et erubuit Gallicus: iam remisit adimuntque adsuerat nolit attonitus! Torvamque sensi ut fecundo fortuna bracchia fuerant, semper de manet inseris.\nIctibus in cursus in, in isque Polyxena et Solis oris pressa exclamat in tori lactente. Locoque iam fata Stygia lege transire.\n"},{"idx":271,"href":"/categories/","title":"Categories","content":""},{"idx":272,"href":"/docs/ctf/ctf_index/","title":"CTF","content":" CTFメモ 最近CTFにも興味が出て参加しているが、なかなかテクニックが覚えられないため、備忘のために覚えたことを書き記しておくためのページである。\n更新できるように頑張ります・・\n重要事項  binary  シェルコード  Cryptography  シーザー暗号  難解プログラミング言語  writeup "},{"idx":273,"href":"/","title":"Introduction","content":" WAT Notes このページはわたくしWATが日ごろの業務及び業務外等の活動で得た技術的知見を備忘のために書き記しておく事を目的に開設した、個人的なノート代わりのサイトです。 たまに自分で作ったプロダクトや雑品などについても書いていけたら良いなあと思っています。\nこのページはGithub上で、Hugoを使って作成しております。\nまあ、よろしく\n"},{"idx":274,"href":"/tags/","title":"Tags","content":""},{"idx":275,"href":"/docs/front-end/front_index/","title":"フロントエンド","content":" フロントエンド-memo フロントエンドの勉強用メモ。まずはHTMLから頑張ります・・ (初心者なので奥深くは書ききれておりません。悪しからず。)\n HTML  要素とタグ HTMLの全体構造 グローバル属性 セクション テキスト リスト ルビ 画像・動画・音声 フォーム テーブル(表) その他の要素  CSS  CSSとは セレクタ CSS適用の優先順位 CSSでの色 CSSでの背景 CSSでのテキスト CSSでのフォント CSSでのボックス マルチカラム アニメーション その他  レスポンシブWebデザイン スマートフォン最適化 API HTTP・HTTPS その他のWeb関連技術  "},{"idx":276,"href":"/docs/programming/jp_index/","title":"プログラミング言語別対応メモ","content":" プログラミング言語別対応メモ 社会人になってからは業務でJavaをバリバリ書いたり学んだりしていた私が、急にPythonをやる必要が出てきた（自分からやりたくなったというのも半分あるが）ため、 学びやすい様にPythonの文法・関数とJavaの文法とを対応づけさせる様にしたメモである。\n自身もまだ勉強中のため、随時更新予定。\nまたjavaやpythonに関わらず、新しい言語についても随時追加していく予定。\n標準入力・出力 文字列 数値 配列・リスト 制御構文 辞書、Map クラス・関数(メソッド) 例外処理 ファイル その他  数学系 グラフ・データ処理 機械学習  競プロテク "}];window.bookSearch={pages:pages,idx:lunr(function(){this.ref("idx");this.field("title");this.field("content");pages.forEach(this.add,this);}),}})();